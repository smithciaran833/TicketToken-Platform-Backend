--
-- PostgreSQL database dump
--

\restrict wYfCNY6egfx9sfCmL06xmJQZ4FZKTbFhampad9wk23ohBP6KneZDBdCScVI0KHd

-- Dumped from database version 15.14
-- Dumped by pg_dump version 15.14

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: analytics; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA analytics;



--
-- Name: SCHEMA analytics; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA analytics IS 'Materialized views and analytics data';


--
-- Name: audit; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA audit;



--
-- Name: SCHEMA audit; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA audit IS 'Audit logs and data change history';


--
-- Name: blockchain; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA blockchain;



--
-- Name: SCHEMA blockchain; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA blockchain IS 'Blockchain transactions, NFTs, and smart contract data';


--
-- Name: cache; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA cache;



--
-- Name: SCHEMA cache; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA cache IS 'Temporary tables and cached data';


--
-- Name: compliance; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA compliance;



--
-- Name: SCHEMA compliance; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA compliance IS 'KYC, AML, and regulatory compliance data';


--
-- Name: integrations; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA integrations;



--
-- Name: marketplace; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA marketplace;



--
-- Name: notifications; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA notifications;



--
-- Name: SCHEMA public; Type: COMMENT; Schema: -; Owner: pg_database_owner
--

COMMENT ON SCHEMA public IS 'Core application tables and data';


--
-- Name: btree_gist; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS btree_gist WITH SCHEMA public;


--
-- Name: EXTENSION btree_gist; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION btree_gist IS 'GiST index support for common data types';


--
-- Name: citext; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS citext WITH SCHEMA public;


--
-- Name: EXTENSION citext; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION citext IS 'Case-insensitive text type';


--
-- Name: hstore; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS hstore WITH SCHEMA public;


--
-- Name: EXTENSION hstore; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION hstore IS 'Key-value store for flexible data';


--
-- Name: pg_trgm; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pg_trgm WITH SCHEMA public;


--
-- Name: EXTENSION pg_trgm; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_trgm IS 'Text similarity search using trigrams';


--
-- Name: pgcrypto; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA public;


--
-- Name: EXTENSION pgcrypto; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pgcrypto IS 'Cryptographic functions for hashing and encryption';


--
-- Name: uuid-ossp; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA public;


--
-- Name: EXTENSION "uuid-ossp"; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION "uuid-ossp" IS 'Functions for generating UUIDs';


--
-- Name: account_action; Type: TYPE; Schema: marketplace; Owner: postgres
--

CREATE TYPE marketplace.account_action AS ENUM (
    'none',
    'warning_issued',
    'temporary_suspension',
    'permanent_ban',
    'selling_restricted',
    'buying_restricted'
);



--
-- Name: calculation_basis; Type: TYPE; Schema: marketplace; Owner: postgres
--

CREATE TYPE marketplace.calculation_basis AS ENUM (
    'gross_sale',
    'net_sale',
    'ticket_face'
);



--
-- Name: dispute_resolution; Type: TYPE; Schema: marketplace; Owner: postgres
--

CREATE TYPE marketplace.dispute_resolution AS ENUM (
    'pending',
    'buyer_favored',
    'seller_favored',
    'split_resolution',
    'escalated',
    'withdrawn',
    'expired'
);



--
-- Name: dispute_status; Type: TYPE; Schema: marketplace; Owner: postgres
--

CREATE TYPE marketplace.dispute_status AS ENUM (
    'none',
    'initiated',
    'under_review',
    'escalated',
    'resolved_buyer_favor',
    'resolved_seller_favor',
    'resolved_split'
);



--
-- Name: dispute_type; Type: TYPE; Schema: marketplace; Owner: postgres
--

CREATE TYPE marketplace.dispute_type AS ENUM (
    'non_delivery',
    'fraud',
    'misrepresentation',
    'technical_issue',
    'unauthorized_sale',
    'duplicate_charge',
    'event_issue',
    'other'
);



--
-- Name: escrow_status; Type: TYPE; Schema: marketplace; Owner: postgres
--

CREATE TYPE marketplace.escrow_status AS ENUM (
    'created',
    'funded',
    'held',
    'released',
    'refunded',
    'disputed',
    'expired',
    'cancelled'
);



--
-- Name: escrow_type; Type: TYPE; Schema: marketplace; Owner: postgres
--

CREATE TYPE marketplace.escrow_type AS ENUM (
    'sale',
    'auction',
    'dispute'
);



--
-- Name: hold_reason; Type: TYPE; Schema: marketplace; Owner: postgres
--

CREATE TYPE marketplace.hold_reason AS ENUM (
    'standard_hold',
    'verification_pending',
    'fraud_review',
    'dispute_hold',
    'regulatory_hold',
    'manual_review'
);



--
-- Name: listing_status; Type: TYPE; Schema: marketplace; Owner: postgres
--

CREATE TYPE marketplace.listing_status AS ENUM (
    'active',
    'sold',
    'cancelled',
    'expired',
    'suspended',
    'under_review'
);



--
-- Name: listing_type; Type: TYPE; Schema: marketplace; Owner: postgres
--

CREATE TYPE marketplace.listing_type AS ENUM (
    'fixed',
    'auction',
    'best_offer'
);



--
-- Name: offer_status; Type: TYPE; Schema: marketplace; Owner: postgres
--

CREATE TYPE marketplace.offer_status AS ENUM (
    'pending',
    'accepted',
    'rejected',
    'expired',
    'withdrawn',
    'completed'
);



--
-- Name: offer_type; Type: TYPE; Schema: marketplace; Owner: postgres
--

CREATE TYPE marketplace.offer_type AS ENUM (
    'direct',
    'auction_bid',
    'best_offer'
);



--
-- Name: payment_status; Type: TYPE; Schema: marketplace; Owner: postgres
--

CREATE TYPE marketplace.payment_status AS ENUM (
    'pending',
    'processing',
    'captured',
    'held_in_escrow',
    'partially_released',
    'released',
    'failed',
    'refunded',
    'disputed'
);



--
-- Name: priority_level; Type: TYPE; Schema: marketplace; Owner: postgres
--

CREATE TYPE marketplace.priority_level AS ENUM (
    'low',
    'medium',
    'high',
    'critical'
);



--
-- Name: refund_reason; Type: TYPE; Schema: marketplace; Owner: postgres
--

CREATE TYPE marketplace.refund_reason AS ENUM (
    'buyer_cancellation',
    'seller_cancellation',
    'failed_delivery',
    'fraud_detected',
    'dispute_resolution',
    'event_cancelled',
    'duplicate_purchase',
    'other'
);



--
-- Name: resolution_decision; Type: TYPE; Schema: marketplace; Owner: postgres
--

CREATE TYPE marketplace.resolution_decision AS ENUM (
    'full_refund',
    'partial_refund',
    'no_refund',
    'replacement',
    'credit_issued',
    'split_resolution',
    'pending'
);



--
-- Name: resolution_method; Type: TYPE; Schema: marketplace; Owner: postgres
--

CREATE TYPE marketplace.resolution_method AS ENUM (
    'platform_decision',
    'mediation',
    'arbitration',
    'mutual_agreement',
    'automatic',
    'withdrawn'
);



--
-- Name: royalty_payment_status; Type: TYPE; Schema: marketplace; Owner: postgres
--

CREATE TYPE marketplace.royalty_payment_status AS ENUM (
    'pending',
    'processing',
    'paid',
    'failed',
    'on_hold',
    'cancelled'
);



--
-- Name: royalty_type; Type: TYPE; Schema: marketplace; Owner: postgres
--

CREATE TYPE marketplace.royalty_type AS ENUM (
    'percentage',
    'fixed_amount'
);



--
-- Name: transaction_type; Type: TYPE; Schema: marketplace; Owner: postgres
--

CREATE TYPE marketplace.transaction_type AS ENUM (
    'direct_sale',
    'auction_win',
    'best_offer_accepted'
);



--
-- Name: transfer_status; Type: TYPE; Schema: marketplace; Owner: postgres
--

CREATE TYPE marketplace.transfer_status AS ENUM (
    'pending',
    'initiated',
    'blockchain_pending',
    'blockchain_confirmed',
    'completed',
    'failed',
    'reversed'
);



--
-- Name: verification_level; Type: TYPE; Schema: marketplace; Owner: postgres
--

CREATE TYPE marketplace.verification_level AS ENUM (
    'unverified',
    'basic',
    'standard',
    'premium',
    'trusted'
);



--
-- Name: access_level; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.access_level AS ENUM (
    'public_only',
    'front_of_house',
    'back_of_house',
    'restricted_areas',
    'all_areas',
    'administrative'
);



--
-- Name: activity_type; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.activity_type AS ENUM (
    'setup',
    'sound_check',
    'rehearsal',
    'doors_open',
    'vip_meet_greet',
    'opening_act',
    'main_event',
    'intermission',
    'set_break',
    'encore',
    'autograph_session',
    'after_party',
    'cleanup',
    'breakdown',
    'load_out',
    'other'
);



--
-- Name: age_restriction; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.age_restriction AS ENUM (
    'all_ages',
    '13_plus',
    '16_plus',
    '18_plus',
    '21_plus',
    'family_friendly',
    'seniors_only',
    'children_only'
);



--
-- Name: audit_action; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.audit_action AS ENUM (
    'create',
    'read',
    'update',
    'delete',
    'login',
    'logout',
    'grant',
    'revoke',
    'approve',
    'reject',
    'export',
    'import',
    'backup',
    'restore',
    'configure',
    'archive',
    'purge'
);



--
-- Name: audit_category; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.audit_category AS ENUM (
    'authentication',
    'authorization',
    'data_modification',
    'financial',
    'security',
    'system',
    'privacy',
    'compliance'
);



--
-- Name: audit_severity; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical'
);



--
-- Name: compliance_status; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.compliance_status AS ENUM (
    'valid',
    'expired',
    'pending_renewal',
    'suspended',
    'revoked',
    'under_review',
    'conditionally_approved',
    'denied',
    'not_applicable'
);



--
-- Name: compliance_type; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.compliance_type AS ENUM (
    'business_license',
    'tax_permits',
    'safety_certificates',
    'insurance',
    'health_permits',
    'liquor_license',
    'music_license',
    'zoning_permits',
    'ada_compliance',
    'environmental',
    'employment',
    'security_permits',
    'parking_permits',
    'temporary_permits',
    'vendor_permits',
    'other'
);



--
-- Name: content_rating; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.content_rating AS ENUM (
    'g',
    'pg',
    'pg13',
    'r',
    'nc17',
    'unrated',
    'explicit'
);



--
-- Name: device_type; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.device_type AS ENUM (
    'desktop',
    'mobile',
    'tablet',
    'tv',
    'bot',
    'unknown'
);



--
-- Name: email; Type: DOMAIN; Schema: public; Owner: postgres
--

CREATE DOMAIN public.email AS character varying(255)
	CONSTRAINT email_check CHECK (((VALUE)::text ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'::text));



--
-- Name: DOMAIN email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON DOMAIN public.email IS 'Email address with format validation';


--
-- Name: employment_status; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.employment_status AS ENUM (
    'active',
    'inactive',
    'terminated',
    'pending',
    'on_leave',
    'suspended',
    'probation',
    'contract_ended'
);



--
-- Name: employment_type; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.employment_type AS ENUM (
    'full_time',
    'part_time',
    'contract',
    'volunteer',
    'intern',
    'seasonal',
    'on_call'
);



--
-- Name: event_category; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.event_category AS ENUM (
    'concert',
    'sports',
    'theater',
    'conference',
    'comedy',
    'dance',
    'festival',
    'exhibition',
    'workshop',
    'networking',
    'charity',
    'religious',
    'family',
    'nightlife',
    'food_drink',
    'wellness',
    'cultural',
    'educational',
    'corporate',
    'other'
);



--
-- Name: event_status; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.event_status AS ENUM (
    'DRAFT',
    'PUBLISHED',
    'CANCELLED',
    'COMPLETED'
);



--
-- Name: TYPE event_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TYPE public.event_status IS 'Event lifecycle status';


--
-- Name: integration_status; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.integration_status AS ENUM (
    'active',
    'inactive',
    'error',
    'pending',
    'testing',
    'expired',
    'suspended',
    'deprecated'
);



--
-- Name: integration_type; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.integration_type AS ENUM (
    'pos',
    'payment',
    'crm',
    'analytics',
    'social_media',
    'email_marketing',
    'accounting',
    'inventory',
    'security',
    'communication',
    'ticketing',
    'streaming',
    'loyalty',
    'survey',
    'booking',
    'weather',
    'transport',
    'other'
);



--
-- Name: kyc_status; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.kyc_status AS ENUM (
    'PENDING',
    'VERIFIED',
    'REJECTED',
    'EXPIRED'
);



--
-- Name: TYPE kyc_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TYPE public.kyc_status IS 'Know Your Customer verification status';


--
-- Name: kyc_status_enum; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.kyc_status_enum AS ENUM (
    'pending',
    'verified',
    'rejected',
    'expired'
);



--
-- Name: layout_status; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.layout_status AS ENUM (
    'active',
    'inactive',
    'seasonal',
    'draft',
    'archived',
    'maintenance'
);



--
-- Name: loyalty_transaction_type_enum; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.loyalty_transaction_type_enum AS ENUM (
    'earned',
    'redeemed',
    'expired',
    'adjusted'
);



--
-- Name: notification_category; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.notification_category AS ENUM (
    'transactional',
    'marketing',
    'system',
    'reminder'
);



--
-- Name: notification_channel; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.notification_channel AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);



--
-- Name: notification_frequency_enum; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.notification_frequency_enum AS ENUM (
    'realtime',
    'daily',
    'weekly',
    'never'
);



--
-- Name: order_status; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.order_status AS ENUM (
    'PENDING',
    'CONFIRMED',
    'PROCESSING',
    'COMPLETED',
    'CANCELLED',
    'REFUNDED'
);



--
-- Name: ownership_type; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.ownership_type AS ENUM (
    'owner',
    'lessee',
    'manager',
    'partner'
);



--
-- Name: payment_status; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.payment_status AS ENUM (
    'PENDING',
    'PROCESSING',
    'SUCCEEDED',
    'FAILED',
    'CANCELLED',
    'REFUNDED'
);



--
-- Name: performer_type; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.performer_type AS ENUM (
    'headliner',
    'co_headliner',
    'opening_act',
    'special_guest',
    'dj',
    'mc_host',
    'speaker',
    'comedian',
    'athlete',
    'presenter',
    'moderator',
    'other'
);



--
-- Name: permission_action; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.permission_action AS ENUM (
    'create',
    'read',
    'update',
    'delete',
    'manage',
    'approve',
    'reject',
    'publish',
    'archive',
    'restore',
    'export',
    'import'
);



--
-- Name: permission_category; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.permission_category AS ENUM (
    'user_management',
    'venue_management',
    'event_management',
    'ticket_management',
    'financial',
    'analytics',
    'system',
    'content_management'
);



--
-- Name: permission_scope; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.permission_scope AS ENUM (
    'global',
    'organization',
    'venue',
    'event',
    'own'
);



--
-- Name: positive_numeric; Type: DOMAIN; Schema: public; Owner: postgres
--

CREATE DOMAIN public.positive_numeric AS numeric
	CONSTRAINT positive_numeric_check CHECK ((VALUE > (0)::numeric));



--
-- Name: DOMAIN positive_numeric; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON DOMAIN public.positive_numeric IS 'Positive numeric values only';


--
-- Name: pricing_tier; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.pricing_tier AS ENUM (
    'platinum',
    'gold',
    'silver',
    'bronze',
    'general_admission',
    'student',
    'senior',
    'child',
    'group'
);



--
-- Name: priority_level; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.priority_level AS ENUM (
    'LOW',
    'MEDIUM',
    'HIGH',
    'CRITICAL'
);



--
-- Name: TYPE priority_level; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TYPE public.priority_level IS 'Priority levels for various operations';


--
-- Name: recurrence_pattern; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.recurrence_pattern AS ENUM (
    'daily',
    'weekly',
    'bi_weekly',
    'monthly',
    'quarterly',
    'semi_annually',
    'annually',
    'weekdays',
    'weekends',
    'custom'
);



--
-- Name: role_category; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.role_category AS ENUM (
    'system',
    'venue',
    'event',
    'custom'
);



--
-- Name: role_permission_level; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.role_permission_level AS ENUM (
    'super_admin',
    'admin',
    'manager',
    'staff',
    'customer'
);



--
-- Name: role_status; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.role_status AS ENUM (
    'active',
    'inactive'
);



--
-- Name: schedule_status; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.schedule_status AS ENUM (
    'draft',
    'tentative',
    'confirmed',
    'published',
    'in_progress',
    'completed',
    'cancelled',
    'postponed',
    'rescheduled',
    'on_hold'
);



--
-- Name: schedule_type; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.schedule_type AS ENUM (
    'single',
    'recurring',
    'multi_day',
    'tour',
    'series',
    'workshop_series',
    'seasonal',
    'special_run',
    'tournament',
    'residency'
);



--
-- Name: seat_type; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.seat_type AS ENUM (
    'standard',
    'premium',
    'vip',
    'wheelchair',
    'companion',
    'aisle',
    'obstructed',
    'removable',
    'standing',
    'box',
    'love_seat',
    'table',
    'bar_stool',
    'bench'
);



--
-- Name: section_type; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.section_type AS ENUM (
    'seating',
    'standing',
    'vip',
    'box',
    'balcony',
    'mezzanine',
    'orchestra',
    'gallery',
    'lawn',
    'pit',
    'stage',
    'backstage',
    'concourse',
    'concession',
    'restroom',
    'emergency_exit',
    'wheelchair',
    'companion',
    'obstructed_view'
);



--
-- Name: segment_type_enum; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.segment_type_enum AS ENUM (
    'automatic',
    'manual',
    'behavioral'
);



--
-- Name: session_risk_level; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.session_risk_level AS ENUM (
    'low',
    'medium',
    'high',
    'critical'
);



--
-- Name: session_status; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.session_status AS ENUM (
    'active',
    'expired',
    'revoked',
    'invalidated'
);



--
-- Name: setting_category; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.setting_category AS ENUM (
    'general',
    'ticketing',
    'payments',
    'notifications',
    'security',
    'integrations',
    'policies',
    'pricing',
    'operations',
    'marketing',
    'analytics',
    'compliance'
);



--
-- Name: setting_data_type; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.setting_data_type AS ENUM (
    'string',
    'integer',
    'decimal',
    'boolean',
    'json',
    'date',
    'datetime',
    'time',
    'url',
    'email',
    'phone',
    'encrypted'
);



--
-- Name: setting_scope; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.setting_scope AS ENUM (
    'venue',
    'global',
    'inherited'
);



--
-- Name: staff_role; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.staff_role AS ENUM (
    'owner',
    'general_manager',
    'assistant_manager',
    'event_coordinator',
    'operations_manager',
    'security_supervisor',
    'security_guard',
    'usher_supervisor',
    'usher',
    'box_office_manager',
    'box_office_clerk',
    'maintenance_supervisor',
    'maintenance_staff',
    'cleaning_supervisor',
    'cleaning_staff',
    'bartender',
    'server',
    'technician',
    'contractor',
    'volunteer',
    'intern'
);



--
-- Name: sync_frequency; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.sync_frequency AS ENUM (
    'real_time',
    'every_minute',
    'every_5_minutes',
    'every_15_minutes',
    'hourly',
    'every_4_hours',
    'daily',
    'weekly',
    'monthly',
    'manual'
);



--
-- Name: text; Type: DOMAIN; Schema: public; Owner: postgres
--

CREATE DOMAIN public.text AS character varying(2048)
	CONSTRAINT text_check CHECK (((VALUE)::text ~ '^https?://'::text));



--
-- Name: ticket_status; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.ticket_status AS ENUM (
    'AVAILABLE',
    'RESERVED',
    'SOLD',
    'CANCELLED',
    'EXPIRED',
    'USED'
);



--
-- Name: TYPE ticket_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TYPE public.ticket_status IS 'Ticket lifecycle status';


--
-- Name: transaction_status; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.transaction_status AS ENUM (
    'PENDING',
    'PROCESSING',
    'COMPLETED',
    'FAILED',
    'REFUNDED'
);



--
-- Name: TYPE transaction_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TYPE public.transaction_status IS 'Blockchain transaction status';


--
-- Name: user_account_status; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.user_account_status AS ENUM (
    'active',
    'suspended',
    'pending_verification'
);



--
-- Name: user_status; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.user_status AS ENUM (
    'PENDING',
    'ACTIVE',
    'SUSPENDED',
    'DELETED'
);



--
-- Name: TYPE user_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TYPE public.user_status IS 'User account status';


--
-- Name: venue_status; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.venue_status AS ENUM (
    'active',
    'inactive',
    'pending_approval',
    'suspended',
    'closed',
    'under_construction',
    'maintenance'
);



--
-- Name: venue_type; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.venue_type AS ENUM (
    'concert_hall',
    'stadium',
    'arena',
    'theater',
    'club',
    'outdoor',
    'convention_center',
    'auditorium',
    'amphitheater',
    'pavilion',
    'ballroom',
    'warehouse',
    'rooftop',
    'restaurant',
    'bar',
    'other'
);



--
-- Name: verification_status; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.verification_status AS ENUM (
    'pending',
    'verified',
    'rejected',
    'incomplete',
    'expired'
);



--
-- Name: violation_severity; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.violation_severity AS ENUM (
    'minor',
    'moderate',
    'major',
    'critical'
);



--
-- Name: violation_status; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.violation_status AS ENUM (
    'open',
    'in_progress',
    'resolved',
    'disputed',
    'dismissed'
);



--
-- Name: wallet_type_enum; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.wallet_type_enum AS ENUM (
    'phantom',
    'metamask',
    'other'
);



--
-- Name: webhook_status; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.webhook_status AS ENUM (
    'active',
    'inactive',
    'failed',
    'pending_verification',
    'rate_limited'
);



--
-- Name: calculate_aml_risk_score(); Type: FUNCTION; Schema: compliance; Owner: postgres
--

CREATE FUNCTION compliance.calculate_aml_risk_score() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
   v_risk_score INTEGER := 0;
   v_risk_level VARCHAR(10);
BEGIN
   -- Base score from individual components
   v_risk_score := COALESCE(NEW.country_risk_score, 0) * 0.3 +
                   COALESCE(NEW.velocity_score, 0) * 0.2 +
                   COALESCE(NEW.behavior_change_score, 0) * 0.2 +
                   COALESCE(NEW.network_risk_score, 0) * 0.3;
   
   -- Add penalties for suspicious patterns
   IF NEW.structuring_detected THEN
       v_risk_score := v_risk_score + 20;
   END IF;
   
   IF NEW.rapid_movement THEN
       v_risk_score := v_risk_score + 15;
   END IF;
   
   IF NEW.exceeded_threshold THEN
       v_risk_score := v_risk_score + 10;
   END IF;
   
   IF NEW.high_risk_country THEN
       v_risk_score := v_risk_score + 15;
   END IF;
   
   -- Account age factor (newer accounts are riskier)
   IF NEW.account_age_days IS NOT NULL AND NEW.account_age_days < 30 THEN
       v_risk_score := v_risk_score + 10;
   END IF;
   
   -- Cap at 100
   v_risk_score := LEAST(v_risk_score, 100);
   
   -- Set risk level
   CASE
       WHEN v_risk_score >= 75 THEN v_risk_level := 'critical';
       WHEN v_risk_score >= 50 THEN v_risk_level := 'high';
       WHEN v_risk_score >= 25 THEN v_risk_level := 'medium';
       ELSE v_risk_level := 'low';
   END CASE;
   
   NEW.risk_score := v_risk_score;
   NEW.risk_level := v_risk_level;
   
   -- Auto-escalate critical risks
   IF v_risk_level = 'critical' AND NEW.check_status = 'pending' THEN
       NEW.check_status := 'escalated';
       NEW.enhanced_monitoring := true;
   END IF;
   
   RETURN NEW;
END;
$$;



--
-- Name: calculate_next_check_date(); Type: FUNCTION; Schema: compliance; Owner: postgres
--

CREATE FUNCTION compliance.calculate_next_check_date() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   -- Calculate next check date based on monitoring frequency
   IF NEW.monitoring_frequency IS NOT NULL AND NEW.screening_status = 'clear' THEN
       CASE NEW.monitoring_frequency
           WHEN 'daily' THEN
               NEW.next_check_date := CURRENT_DATE + INTERVAL '1 day';
           WHEN 'weekly' THEN
               NEW.next_check_date := CURRENT_DATE + INTERVAL '1 week';
           WHEN 'monthly' THEN
               NEW.next_check_date := CURRENT_DATE + INTERVAL '1 month';
           WHEN 'quarterly' THEN
               NEW.next_check_date := CURRENT_DATE + INTERVAL '3 months';
       END CASE;
   END IF;
   
   -- Update last checked timestamp
   NEW.last_checked_at := CURRENT_TIMESTAMP;
   
   -- Set auto-clear date for pending reviews
   IF NEW.screening_status = 'potential_match' AND NEW.auto_clear_date IS NULL THEN
       NEW.auto_clear_date := CURRENT_DATE + INTERVAL '30 days';
   END IF;
   
   RETURN NEW;
END;
$$;



--
-- Name: calculate_next_purge_date(); Type: FUNCTION; Schema: compliance; Owner: postgres
--

CREATE FUNCTION compliance.calculate_next_purge_date() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
   v_retention_days INTEGER;
BEGIN
   -- Calculate total retention days
   v_retention_days := COALESCE(NEW.retention_period_days, 0) + 
                      COALESCE(NEW.retention_period_years * 365, 0);
   
   -- Set next purge date if not under legal hold
   IF NEW.is_active AND NOT NEW.legal_hold AND v_retention_days > 0 THEN
       NEW.next_purge_date := CURRENT_TIMESTAMP + (v_retention_days || ' days')::INTERVAL;
   ELSE
       NEW.next_purge_date := NULL;
   END IF;
   
   RETURN NEW;
END;
$$;



--
-- Name: check_kyc_expiry(); Type: FUNCTION; Schema: compliance; Owner: postgres
--

CREATE FUNCTION compliance.check_kyc_expiry() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   -- Auto-expire if past expiry date
   IF NEW.expires_at IS NOT NULL AND NEW.expires_at < CURRENT_TIMESTAMP AND NEW.verification_status = 'approved' THEN
       NEW.verification_status := 'expired';
   END IF;
   
   -- Set deletion date based on retention period
   IF NEW.verified_at IS NOT NULL AND NEW.deletion_scheduled_at IS NULL THEN
       NEW.deletion_scheduled_at := NEW.verified_at + (NEW.retention_period_days || ' days')::INTERVAL;
   END IF;
   
   RETURN NEW;
END;
$$;



--
-- Name: prevent_submitted_report_changes(); Type: FUNCTION; Schema: compliance; Owner: postgres
--

CREATE FUNCTION compliance.prevent_submitted_report_changes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   -- Allow status changes to acknowledged or rejected
   IF OLD.status IN ('submitted', 'acknowledged') AND 
      NEW.status IN ('acknowledged', 'rejected') THEN
       RETURN NEW;
   END IF;
   
   -- Prevent other changes to submitted reports
   IF OLD.status IN ('submitted', 'acknowledged') THEN
       RAISE EXCEPTION 'Cannot modify submitted reports';
   END IF;
   
   -- Lock report when submitted
   IF OLD.status != 'submitted' AND NEW.status = 'submitted' THEN
       NEW.locked_at := CURRENT_TIMESTAMP;
   END IF;
   
   -- Set destruction date based on retention
   IF NEW.submitted_at IS NOT NULL AND NEW.destruction_date IS NULL THEN
       NEW.destruction_date := DATE(NEW.submitted_at) + (NEW.retention_years || ' years')::INTERVAL;
   END IF;
   
   -- Add modification to audit trail
   NEW.modifications := NEW.modifications || jsonb_build_array(
       jsonb_build_object(
           'timestamp', CURRENT_TIMESTAMP,
           'user_id', current_setting('app.current_user_id', true),
           'old_status', OLD.status,
           'new_status', NEW.status
       )
   );
   
   RETURN NEW;
END;
$$;



--
-- Name: update_aml_checks_updated_at(); Type: FUNCTION; Schema: compliance; Owner: postgres
--

CREATE FUNCTION compliance.update_aml_checks_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   NEW.updated_at = CURRENT_TIMESTAMP;
   RETURN NEW;
END;
$$;



--
-- Name: update_compliance_reports_updated_at(); Type: FUNCTION; Schema: compliance; Owner: postgres
--

CREATE FUNCTION compliance.update_compliance_reports_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   NEW.updated_at = CURRENT_TIMESTAMP;
   RETURN NEW;
END;
$$;



--
-- Name: update_data_retention_updated_at(); Type: FUNCTION; Schema: compliance; Owner: postgres
--

CREATE FUNCTION compliance.update_data_retention_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   NEW.updated_at = CURRENT_TIMESTAMP;
   RETURN NEW;
END;
$$;



--
-- Name: update_kyc_records_updated_at(); Type: FUNCTION; Schema: compliance; Owner: postgres
--

CREATE FUNCTION compliance.update_kyc_records_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   NEW.updated_at = CURRENT_TIMESTAMP;
   RETURN NEW;
END;
$$;



--
-- Name: update_sanctions_screening_updated_at(); Type: FUNCTION; Schema: compliance; Owner: postgres
--

CREATE FUNCTION compliance.update_sanctions_screening_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   NEW.updated_at = CURRENT_TIMESTAMP;
   RETURN NEW;
END;
$$;



--
-- Name: add_sync_error(character varying, character varying, text, jsonb); Type: FUNCTION; Schema: integrations; Owner: postgres
--

CREATE FUNCTION integrations.add_sync_error(p_sync_id character varying, p_error_code character varying, p_error_message text, p_error_data jsonb DEFAULT '{}'::jsonb) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
   UPDATE sync_logs
   SET 
       errors_count = errors_count + 1,
       error_details = error_details || jsonb_build_array(
           jsonb_build_object(
               'timestamp', CURRENT_TIMESTAMP,
               'code', p_error_code,
               'message', p_error_message,
               'data', p_error_data
           )
       ),
       first_error_at = COALESCE(first_error_at, CURRENT_TIMESTAMP)
   WHERE sync_id = p_sync_id;
END;
$$;



--
-- Name: calculate_sync_duration(); Type: FUNCTION; Schema: integrations; Owner: postgres
--

CREATE FUNCTION integrations.calculate_sync_duration() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   IF NEW.completed_at IS NOT NULL AND NEW.started_at IS NOT NULL THEN
       NEW.duration_seconds := EXTRACT(EPOCH FROM (NEW.completed_at - NEW.started_at))::INTEGER;
       
       -- Calculate records per second if applicable
       IF NEW.duration_seconds > 0 AND NEW.records_processed > 0 THEN
           NEW.records_per_second := ROUND(NEW.records_processed::DECIMAL / NEW.duration_seconds, 2);
       END IF;
   END IF;
   
   RETURN NEW;
END;
$$;



--
-- Name: check_needs_sync(); Type: FUNCTION; Schema: integrations; Owner: postgres
--

CREATE FUNCTION integrations.check_needs_sync() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   -- If internal or external updated timestamps change, set needs_sync
   IF (OLD.internal_updated_at IS DISTINCT FROM NEW.internal_updated_at OR
       OLD.external_updated_at IS DISTINCT FROM NEW.external_updated_at) THEN
       NEW.needs_sync := true;
   END IF;
   
   -- If version conflict detected, set needs_sync
   IF NEW.version_conflict = true THEN
       NEW.needs_sync := true;
   END IF;
   
   RETURN NEW;
END;
$$;



--
-- Name: decrypt_credential(bytea, uuid); Type: FUNCTION; Schema: integrations; Owner: postgres
--

CREATE FUNCTION integrations.decrypt_credential(p_ciphertext bytea, p_key_id uuid) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
   v_key TEXT;
BEGIN
   -- In production, retrieve key from secure key management system
   -- This is a placeholder implementation
   v_key := 'temporary_encryption_key_' || p_key_id::TEXT;
   RETURN pgp_sym_decrypt(p_ciphertext, v_key);
END;
$$;



--
-- Name: encrypt_credential(text, uuid); Type: FUNCTION; Schema: integrations; Owner: postgres
--

CREATE FUNCTION integrations.encrypt_credential(p_plaintext text, p_key_id uuid) RETURNS bytea
    LANGUAGE plpgsql
    AS $$
DECLARE
   v_key TEXT;
BEGIN
   -- In production, retrieve key from secure key management system
   -- This is a placeholder implementation
   v_key := 'temporary_encryption_key_' || p_key_id::TEXT;
   RETURN pgp_sym_encrypt(p_plaintext, v_key);
END;
$$;



--
-- Name: find_external_reference(character varying, uuid, character varying); Type: FUNCTION; Schema: integrations; Owner: postgres
--

CREATE FUNCTION integrations.find_external_reference(p_internal_type character varying, p_internal_id uuid, p_external_system character varying) RETURNS TABLE(external_id character varying, external_type character varying, sync_status character varying, last_synced_at timestamp with time zone)
    LANGUAGE plpgsql
    AS $$
BEGIN
   RETURN QUERY
   SELECT 
       er.external_entity_id,
       er.external_entity_type,
       er.sync_status,
       er.last_synced_at
   FROM external_references er
   WHERE er.internal_entity_type = p_internal_type
     AND er.internal_entity_id = p_internal_id
     AND er.external_system = p_external_system;
END;
$$;



--
-- Name: update_api_credentials_updated_at(); Type: FUNCTION; Schema: integrations; Owner: postgres
--

CREATE FUNCTION integrations.update_api_credentials_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   NEW.updated_at = CURRENT_TIMESTAMP;
   NEW.modified_by = current_setting('app.current_user_id', true)::UUID;
   RETURN NEW;
END;
$$;



--
-- Name: update_external_references_updated_at(); Type: FUNCTION; Schema: integrations; Owner: postgres
--

CREATE FUNCTION integrations.update_external_references_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   NEW.updated_at = CURRENT_TIMESTAMP;
   RETURN NEW;
END;
$$;



--
-- Name: update_integration_mappings_updated_at(); Type: FUNCTION; Schema: integrations; Owner: postgres
--

CREATE FUNCTION integrations.update_integration_mappings_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   NEW.updated_at = CURRENT_TIMESTAMP;
   RETURN NEW;
END;
$$;



--
-- Name: update_sync_logs_updated_at(); Type: FUNCTION; Schema: integrations; Owner: postgres
--

CREATE FUNCTION integrations.update_sync_logs_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   NEW.updated_at = CURRENT_TIMESTAMP;
   RETURN NEW;
END;
$$;



--
-- Name: update_webhook_endpoints_updated_at(); Type: FUNCTION; Schema: integrations; Owner: postgres
--

CREATE FUNCTION integrations.update_webhook_endpoints_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   NEW.updated_at = CURRENT_TIMESTAMP;
   RETURN NEW;
END;
$$;



--
-- Name: update_webhook_metrics(uuid, boolean, integer); Type: FUNCTION; Schema: integrations; Owner: postgres
--

CREATE FUNCTION integrations.update_webhook_metrics(p_endpoint_id uuid, p_success boolean, p_response_time_ms integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
   v_current_avg INTEGER;
   v_total_calls BIGINT;
BEGIN
   UPDATE webhook_endpoints
   SET 
       total_calls = total_calls + 1,
       successful_calls = CASE WHEN p_success THEN successful_calls + 1 ELSE successful_calls END,
       last_success_at = CASE WHEN p_success THEN CURRENT_TIMESTAMP ELSE last_success_at END,
       last_failure_at = CASE WHEN NOT p_success THEN CURRENT_TIMESTAMP ELSE last_failure_at END,
       consecutive_failures = CASE 
           WHEN p_success THEN 0 
           ELSE consecutive_failures + 1 
       END,
       average_response_time_ms = CASE 
           WHEN p_success AND p_response_time_ms IS NOT NULL THEN
               ((average_response_time_ms * successful_calls) + p_response_time_ms) / (successful_calls + 1)
           ELSE average_response_time_ms
       END,
       current_minute_calls = current_minute_calls + 1
   WHERE id = p_endpoint_id;
END;
$$;



--
-- Name: validate_field_mapping(uuid, jsonb); Type: FUNCTION; Schema: integrations; Owner: postgres
--

CREATE FUNCTION integrations.validate_field_mapping(p_mapping_id uuid, p_test_data jsonb) RETURNS TABLE(is_valid boolean, errors jsonb, warnings jsonb, transformed_data jsonb)
    LANGUAGE plpgsql
    AS $$
DECLARE
   v_mapping RECORD;
   v_errors JSONB := '[]'::JSONB;
   v_warnings JSONB := '[]'::JSONB;
   v_result JSONB := '{}'::JSONB;
BEGIN
   -- Get mapping configuration
   SELECT * INTO v_mapping FROM integration_mappings WHERE id = p_mapping_id;
   
   -- Basic validation logic (placeholder for actual implementation)
   IF v_mapping.id IS NULL THEN
       v_errors := v_errors || '["Mapping not found"]'::JSONB;
       RETURN QUERY SELECT false, v_errors, v_warnings, NULL::JSONB;
       RETURN;
   END IF;
   
   -- Check required fields
   IF v_mapping.required_fields IS NOT NULL THEN
       -- Add validation logic here
       v_result := p_test_data; -- Placeholder
   END IF;
   
   -- Update test results
   UPDATE integration_mappings 
   SET last_tested_at = CURRENT_TIMESTAMP,
       test_results = jsonb_build_object(
           'timestamp', CURRENT_TIMESTAMP,
           'errors', v_errors,
           'warnings', v_warnings,
           'sample_output', v_result
       )
   WHERE id = p_mapping_id;
   
   RETURN QUERY SELECT 
       jsonb_array_length(v_errors) = 0,
       v_errors,
       v_warnings,
       v_result;
END;
$$;



--
-- Name: webhook_circuit_breaker(); Type: FUNCTION; Schema: integrations; Owner: postgres
--

CREATE FUNCTION integrations.webhook_circuit_breaker() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   -- Open circuit if failure threshold reached
   IF NEW.consecutive_failures >= NEW.failure_threshold AND NOT NEW.is_paused THEN
       NEW.is_paused := true;
       NEW.paused_until := CURRENT_TIMESTAMP + (NEW.retry_delay_seconds * NEW.failure_threshold || ' seconds')::INTERVAL;
   END IF;
   
   -- Close circuit if success threshold reached while paused
   IF NEW.consecutive_failures = 0 AND OLD.consecutive_failures >= NEW.success_threshold AND NEW.is_paused THEN
       NEW.is_paused := false;
       NEW.paused_until := NULL;
   END IF;
   
   -- Auto-resume if pause period expired
   IF NEW.is_paused AND NEW.paused_until IS NOT NULL AND NEW.paused_until < CURRENT_TIMESTAMP THEN
       NEW.is_paused := false;
       NEW.paused_until := NULL;
       NEW.consecutive_failures := 0;
   END IF;
   
   RETURN NEW;
END;
$$;



--
-- Name: accept_offer(uuid, text); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.accept_offer(p_offer_id uuid, p_seller_response text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_listing_id UUID;
    v_offer_type marketplace.offer_type;
BEGIN
    -- Get offer details
    SELECT listing_id, offer_type INTO v_listing_id, v_offer_type
    FROM marketplace.offers
    WHERE id = p_offer_id AND status = 'pending';
    
    IF NOT FOUND THEN
        RETURN FALSE;
    END IF;
    
    -- Begin transaction
    BEGIN
        -- Update the accepted offer
        UPDATE marketplace.offers
        SET 
            status = 'accepted',
            accepted_at = CURRENT_TIMESTAMP,
            payment_due_at = CURRENT_TIMESTAMP + INTERVAL '24 hours',
            transfer_completion_deadline = CURRENT_TIMESTAMP + INTERVAL '72 hours',
            seller_response = p_seller_response
        WHERE id = p_offer_id;
        
        -- Reject all other pending offers for this listing
        UPDATE marketplace.offers
        SET 
            status = 'rejected',
            platform_notes = jsonb_set(
                COALESCE(platform_notes, '{}'::jsonb),
                '{auto_rejected}',
                'true'::jsonb
            )
        WHERE listing_id = v_listing_id 
            AND id != p_offer_id 
            AND status = 'pending';
        
        -- Update listing status to sold
        UPDATE marketplace.listings
        SET status = 'sold'
        WHERE id = v_listing_id;
        
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
            RETURN FALSE;
    END;
END;
$$;



--
-- Name: FUNCTION accept_offer(p_offer_id uuid, p_seller_response text); Type: COMMENT; Schema: marketplace; Owner: postgres
--

COMMENT ON FUNCTION marketplace.accept_offer(p_offer_id uuid, p_seller_response text) IS 'Accept an offer and handle all related status updates';


--
-- Name: auto_expire_listings(); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.auto_expire_listings() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- For auctions, check auction end time
    IF NEW.listing_type = 'auction' AND NEW.auction_end_time <= CURRENT_TIMESTAMP AND OLD.status = 'active' THEN
        NEW.status = 'expired';
    END IF;
    
    -- For all listings, check expires_at
    IF NEW.expires_at IS NOT NULL AND NEW.expires_at <= CURRENT_TIMESTAMP AND OLD.status = 'active' THEN
        NEW.status = 'expired';
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: auto_expire_offers(); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.auto_expire_offers() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Check if offer should be expired
    IF NEW.expires_at <= CURRENT_TIMESTAMP AND OLD.status = 'pending' THEN
        NEW.status = 'expired';
        NEW.expired_at = CURRENT_TIMESTAMP;
    END IF;
    
    -- Check if payment is overdue for accepted offers
    IF NEW.payment_due_at IS NOT NULL 
       AND NEW.payment_due_at <= CURRENT_TIMESTAMP 
       AND OLD.status = 'accepted' 
       AND NEW.payment_authorized = false THEN
        NEW.status = 'expired';
        NEW.expired_at = CURRENT_TIMESTAMP;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: calculate_release_date(); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.calculate_release_date() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_hold_period INTERVAL;
BEGIN
    -- Only calculate for new escrows
    IF TG_OP = 'INSERT' THEN
        -- Determine hold period based on type and risk
        v_hold_period := CASE
            WHEN NEW.escrow_type = 'auction' THEN INTERVAL '72 hours'
            WHEN NEW.risk_assessment_score > 70 THEN INTERVAL '7 days'
            WHEN NEW.escrow_type = 'sale' THEN INTERVAL '48 hours'
            ELSE INTERVAL '48 hours'
        END;
        
        -- Set automatic release date if not manually specified
        IF NEW.automatic_release_date IS NULL THEN
            NEW.automatic_release_date = CURRENT_TIMESTAMP + v_hold_period;
        END IF;
        
        -- Set held_until date
        NEW.held_until = NEW.automatic_release_date;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: calculate_royalty_amount(); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.calculate_royalty_amount() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_base_amount DECIMAL(10, 2);
BEGIN
    -- Determine base amount based on calculation basis
    CASE NEW.calculation_basis
        WHEN 'gross_sale' THEN
            v_base_amount := NEW.transaction_amount;
        WHEN 'net_sale' THEN
            -- This would need to fetch net amount from transaction
            v_base_amount := NEW.transaction_amount * 0.9; -- Example: 90% of gross
        WHEN 'ticket_face' THEN
            -- This would need to fetch original ticket price
            v_base_amount := NEW.transaction_amount * 0.8; -- Example placeholder
    END CASE;
    
    -- Calculate royalty based on type
    IF NEW.royalty_type = 'percentage' THEN
        NEW.royalty_amount := ROUND(v_base_amount * NEW.royalty_percentage, 2);
    ELSIF NEW.royalty_type = 'fixed_amount' THEN
        NEW.royalty_amount := NEW.fixed_royalty_amount;
    END IF;
    
    -- Apply tax withholding if required
    IF NEW.tax_withholding_required THEN
        NEW.tax_withholding_amount := ROUND(NEW.royalty_amount * 0.24, 2); -- 24% backup withholding
    END IF;
    
    -- Store calculation details
    NEW.calculation_details := jsonb_build_object(
        'base_amount', v_base_amount,
        'calculation_basis', NEW.calculation_basis,
        'royalty_type', NEW.royalty_type,
        'applied_rate', COALESCE(NEW.royalty_percentage, 0),
        'fixed_amount', COALESCE(NEW.fixed_royalty_amount, 0)
    );
    
    RETURN NEW;
END;
$$;



--
-- Name: calculate_transaction_fees(); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.calculate_transaction_fees() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_platform_fee_rate DECIMAL(5, 4) := 0.0500; -- 5% platform fee
    v_processing_fee_rate DECIMAL(5, 4) := 0.0290; -- 2.9% payment processing
    v_venue_royalty_rate DECIMAL(5, 4) := 0.0250; -- 2.5% venue royalty
BEGIN
    -- Calculate platform fee (5% of sale price)
    NEW.platform_fee := ROUND(NEW.sale_price * v_platform_fee_rate, 2);
    NEW.platform_commission_amount := NEW.platform_fee;
    
    -- Calculate payment processing fee (2.9% + $0.30)
    NEW.payment_processing_fee := ROUND(NEW.sale_price * v_processing_fee_rate + 0.30, 2);
    
    -- Calculate venue royalty (2.5% of sale price)
    NEW.venue_royalty := ROUND(NEW.sale_price * v_venue_royalty_rate, 2);
    NEW.venue_commission_amount := NEW.venue_royalty;
    
    -- Tax calculation would be done by external service
    -- This is a placeholder
    IF NEW.tax_applicable THEN
        NEW.tax_amount := ROUND(NEW.sale_price * 0.0875, 2); -- Example: 8.75% tax
    END IF;
    
    RETURN NEW;
END;
$_$;



--
-- Name: create_royalty_settlement(uuid, date, date); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.create_royalty_settlement(p_venue_id uuid, p_start_date date, p_end_date date) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_settlement_id UUID;
    v_total_royalties DECIMAL(15, 2);
    v_total_transactions INTEGER;
BEGIN
    -- Calculate totals for the period
    SELECT 
        SUM(royalty_amount - COALESCE(tax_withholding_amount, 0)),
        COUNT(*)
    INTO v_total_royalties, v_total_transactions
    FROM marketplace.royalties
    WHERE venue_id = p_venue_id
        AND earned_at::DATE BETWEEN p_start_date AND p_end_date
        AND payment_status = 'pending'
        AND settlement_id IS NULL;
    
    -- Create settlement if there are royalties to pay
    IF v_total_transactions > 0 THEN
        INSERT INTO marketplace.royalty_settlements (
            venue_id,
            settlement_period_start,
            settlement_period_end,
            total_royalties,
            total_transactions
        ) VALUES (
            p_venue_id,
            p_start_date,
            p_end_date,
            v_total_royalties,
            v_total_transactions
        ) RETURNING id INTO v_settlement_id;
        
        -- Link royalties to settlement
        UPDATE marketplace.royalties
        SET 
            settlement_id = v_settlement_id,
            settlement_batch_id = 'BATCH-' || TO_CHAR(CURRENT_DATE, 'YYYYMMDD') || '-' || p_venue_id::TEXT
        WHERE venue_id = p_venue_id
            AND earned_at::DATE BETWEEN p_start_date AND p_end_date
            AND payment_status = 'pending'
            AND settlement_id IS NULL;
        
        RETURN v_settlement_id;
    ELSE
        RETURN NULL;
    END IF;
END;
$$;



--
-- Name: FUNCTION create_royalty_settlement(p_venue_id uuid, p_start_date date, p_end_date date); Type: COMMENT; Schema: marketplace; Owner: postgres
--

COMMENT ON FUNCTION marketplace.create_royalty_settlement(p_venue_id uuid, p_start_date date, p_end_date date) IS 'Create settlement batch for venue royalty payout';


--
-- Name: escalate_priority(); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.escalate_priority() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Auto-escalate priority based on conditions
    IF NEW.dispute_type = 'fraud' AND OLD.priority_level NOT IN ('high', 'critical') THEN
        NEW.priority_level = 'high';
    END IF;
    
    -- Escalate if response deadline missed
    IF NEW.response_deadline < CURRENT_TIMESTAMP AND OLD.priority_level = 'low' THEN
        NEW.priority_level = 'medium';
    ELSIF NEW.response_deadline < CURRENT_TIMESTAMP AND OLD.priority_level = 'medium' THEN
        NEW.priority_level = 'high';
    END IF;
    
    -- Escalate high-value disputes
    IF NEW.dispute_amount > 1000 AND OLD.priority_level = 'low' THEN
        NEW.priority_level = 'medium';
    ELSIF NEW.dispute_amount > 5000 AND OLD.priority_level != 'critical' THEN
        NEW.priority_level = 'high';
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: file_dispute(uuid, uuid, marketplace.dispute_type, text, text, jsonb); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.file_dispute(p_transaction_id uuid, p_complainant_id uuid, p_dispute_type marketplace.dispute_type, p_reason text, p_description text DEFAULT NULL::text, p_evidence jsonb DEFAULT '{}'::jsonb) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_dispute_id UUID;
    v_transaction RECORD;
BEGIN
    -- Get transaction details
    SELECT * INTO v_transaction
    FROM marketplace.marketplace_transactions
    WHERE id = p_transaction_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Transaction not found';
    END IF;
    
    -- Determine respondent (opposite party)
    DECLARE
        v_respondent_id UUID;
    BEGIN
        IF p_complainant_id = v_transaction.buyer_user_id THEN
            v_respondent_id := v_transaction.seller_user_id;
        ELSIF p_complainant_id = v_transaction.seller_user_id THEN
            v_respondent_id := v_transaction.buyer_user_id;
        ELSE
            RAISE EXCEPTION 'Complainant must be buyer or seller of the transaction';
        END IF;
        
        -- Create dispute
        INSERT INTO marketplace.dispute_resolution (
            marketplace_transaction_id,
            complainant_user_id,
            respondent_user_id,
            dispute_type,
            dispute_amount,
            dispute_reason,
            detailed_description,
            evidence_submitted,
            response_deadline,
            evidence_submission_deadline,
            priority_level
        ) VALUES (
            p_transaction_id,
            p_complainant_id,
            v_respondent_id,
            p_dispute_type,
            v_transaction.sale_price,
            p_reason,
            p_description,
            p_evidence,
            CURRENT_TIMESTAMP + INTERVAL '72 hours',
            CURRENT_TIMESTAMP + INTERVAL '7 days',
            CASE 
                WHEN p_dispute_type = 'fraud' THEN 'high'::marketplace.priority_level
                WHEN v_transaction.sale_price > 1000 THEN 'medium'::marketplace.priority_level
                ELSE 'low'::marketplace.priority_level
            END
        ) RETURNING id INTO v_dispute_id;
        
        -- Update transaction status
        UPDATE marketplace.marketplace_transactions
        SET payment_status = 'disputed'
        WHERE id = p_transaction_id;
        
        RETURN v_dispute_id;
    END;
END;
$$;



--
-- Name: FUNCTION file_dispute(p_transaction_id uuid, p_complainant_id uuid, p_dispute_type marketplace.dispute_type, p_reason text, p_description text, p_evidence jsonb); Type: COMMENT; Schema: marketplace; Owner: postgres
--

COMMENT ON FUNCTION marketplace.file_dispute(p_transaction_id uuid, p_complainant_id uuid, p_dispute_type marketplace.dispute_type, p_reason text, p_description text, p_evidence jsonb) IS 'File a new dispute for a transaction';


--
-- Name: generate_1099_data(uuid, integer); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.generate_1099_data(p_venue_id uuid, p_tax_year integer) RETURNS TABLE(venue_id uuid, tax_year integer, total_royalties_paid numeric, total_tax_withheld numeric, payment_count integer, tin_provided boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        r.venue_id,
        r.tax_year,
        SUM(r.royalty_amount) as total_royalties_paid,
        SUM(r.tax_withholding_amount) as total_tax_withheld,
        COUNT(*)::INTEGER as payment_count,
        EXISTS(
            SELECT 1 FROM venues v 
            WHERE v.id = r.venue_id 
            AND v.tax_id IS NOT NULL
        ) as tin_provided
    FROM marketplace.royalties r
    WHERE r.venue_id = p_venue_id
        AND r.tax_year = p_tax_year
        AND r.payment_status = 'paid'
    GROUP BY r.venue_id, r.tax_year;
END;
$$;



--
-- Name: FUNCTION generate_1099_data(p_venue_id uuid, p_tax_year integer); Type: COMMENT; Schema: marketplace; Owner: postgres
--

COMMENT ON FUNCTION marketplace.generate_1099_data(p_venue_id uuid, p_tax_year integer) IS 'Generate tax form data for venue royalties';


--
-- Name: generate_case_number(); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.generate_case_number() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_year TEXT;
    v_sequence INTEGER;
BEGIN
    -- Generate case number format: DIS-YYYY-NNNNNN
    v_year := TO_CHAR(CURRENT_DATE, 'YYYY');
    
    SELECT COUNT(*) + 1 INTO v_sequence
    FROM marketplace.dispute_resolution
    WHERE EXTRACT(YEAR FROM filed_at) = EXTRACT(YEAR FROM CURRENT_DATE);
    
    NEW.case_number := 'DIS-' || v_year || '-' || LPAD(v_sequence::TEXT, 6, '0');
    
    RETURN NEW;
END;
$$;



--
-- Name: get_dispute_metrics(date, date); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.get_dispute_metrics(p_start_date date DEFAULT (CURRENT_DATE - '30 days'::interval), p_end_date date DEFAULT CURRENT_DATE) RETURNS TABLE(total_disputes bigint, resolution_rate numeric, avg_resolution_time interval, buyer_win_rate numeric, total_disputed_amount numeric, total_refunded_amount numeric, appeal_rate numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*)::BIGINT as total_disputes,
        (COUNT(*) FILTER (WHERE status IN ('resolved', 'closed'))::DECIMAL / 
            NULLIF(COUNT(*), 0) * 100) as resolution_rate,
        AVG(resolution_time) FILTER (WHERE resolution_time IS NOT NULL) as avg_resolution_time,
        (COUNT(*) FILTER (WHERE resolution_decision IN ('full_refund', 'partial_refund'))::DECIMAL / 
            NULLIF(COUNT(*) FILTER (WHERE status = 'resolved'), 0) * 100) as buyer_win_rate,
        SUM(dispute_amount) as total_disputed_amount,
        SUM(awarded_amount) FILTER (WHERE resolution_decision IN ('full_refund', 'partial_refund')) as total_refunded_amount,
        (COUNT(*) FILTER (WHERE status = 'appealed')::DECIMAL / 
            NULLIF(COUNT(*) FILTER (WHERE appeal_allowed = true), 0) * 100) as appeal_rate
    FROM marketplace.dispute_resolution
    WHERE filed_at::DATE BETWEEN p_start_date AND p_end_date;
END;
$$;



--
-- Name: FUNCTION get_dispute_metrics(p_start_date date, p_end_date date); Type: COMMENT; Schema: marketplace; Owner: postgres
--

COMMENT ON FUNCTION marketplace.get_dispute_metrics(p_start_date date, p_end_date date) IS 'Calculate dispute resolution metrics';


--
-- Name: get_escrow_metrics(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.get_escrow_metrics(p_start_date timestamp with time zone DEFAULT (CURRENT_TIMESTAMP - '30 days'::interval), p_end_date timestamp with time zone DEFAULT CURRENT_TIMESTAMP) RETURNS TABLE(total_escrows bigint, total_amount numeric, avg_hold_time interval, release_rate numeric, dispute_rate numeric, avg_resolution_time interval, fraud_detection_rate numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*)::BIGINT as total_escrows,
        SUM(escrow_amount) as total_amount,
        AVG(released_at - funded_at) FILTER (WHERE status = 'released') as avg_hold_time,
        (COUNT(*) FILTER (WHERE status = 'released')::DECIMAL / NULLIF(COUNT(*), 0) * 100) as release_rate,
        (COUNT(*) FILTER (WHERE dispute_initiated = true)::DECIMAL / NULLIF(COUNT(*), 0) * 100) as dispute_rate,
        AVG(resolved_at - disputed_at) FILTER (WHERE resolution IS NOT NULL) as avg_resolution_time,
        (COUNT(*) FILTER (WHERE fraud_hold = true)::DECIMAL / NULLIF(COUNT(*), 0) * 100) as fraud_detection_rate
    FROM marketplace.escrow
    WHERE created_at BETWEEN p_start_date AND p_end_date;
END;
$$;



--
-- Name: FUNCTION get_escrow_metrics(p_start_date timestamp with time zone, p_end_date timestamp with time zone); Type: COMMENT; Schema: marketplace; Owner: postgres
--

COMMENT ON FUNCTION marketplace.get_escrow_metrics(p_start_date timestamp with time zone, p_end_date timestamp with time zone) IS 'Calculate escrow system performance metrics';


--
-- Name: get_transaction_metrics(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.get_transaction_metrics(p_start_date timestamp with time zone, p_end_date timestamp with time zone) RETURNS TABLE(total_transactions bigint, total_volume numeric, avg_sale_price numeric, total_platform_fees numeric, total_venue_royalties numeric, dispute_rate numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*)::BIGINT as total_transactions,
        SUM(sale_price) as total_volume,
        AVG(sale_price) as avg_sale_price,
        SUM(platform_fee) as total_platform_fees,
        SUM(venue_royalty) as total_venue_royalties,
        (COUNT(*) FILTER (WHERE escrow_dispute = true)::DECIMAL / COUNT(*)::DECIMAL * 100) as dispute_rate
    FROM marketplace.marketplace_transactions
    WHERE completed_at BETWEEN p_start_date AND p_end_date;
END;
$$;



--
-- Name: FUNCTION get_transaction_metrics(p_start_date timestamp with time zone, p_end_date timestamp with time zone); Type: COMMENT; Schema: marketplace; Owner: postgres
--

COMMENT ON FUNCTION marketplace.get_transaction_metrics(p_start_date timestamp with time zone, p_end_date timestamp with time zone) IS 'Calculate marketplace metrics for a date range';


--
-- Name: get_venue_royalty_summary(uuid, date, date); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.get_venue_royalty_summary(p_venue_id uuid, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date) RETURNS TABLE(total_earned numeric, total_paid numeric, total_pending numeric, total_transactions integer, average_royalty numeric, effective_rate numeric, last_payment_date date)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        SUM(royalty_amount) FILTER (WHERE payment_status NOT IN ('cancelled')) as total_earned,
        SUM(royalty_amount - COALESCE(tax_withholding_amount, 0)) FILTER (WHERE payment_status = 'paid') as total_paid,
        SUM(royalty_amount - COALESCE(tax_withholding_amount, 0)) FILTER (WHERE payment_status = 'pending') as total_pending,
        COUNT(*)::INTEGER as total_transactions,
        AVG(royalty_amount) as average_royalty,
        AVG(effective_royalty_rate) as effective_rate,
        MAX(actual_payment_date) as last_payment_date
    FROM marketplace.royalties
    WHERE venue_id = p_venue_id
        AND (p_start_date IS NULL OR earned_at::DATE >= p_start_date)
        AND (p_end_date IS NULL OR earned_at::DATE <= p_end_date);
END;
$$;



--
-- Name: FUNCTION get_venue_royalty_summary(p_venue_id uuid, p_start_date date, p_end_date date); Type: COMMENT; Schema: marketplace; Owner: postgres
--

COMMENT ON FUNCTION marketplace.get_venue_royalty_summary(p_venue_id uuid, p_start_date date, p_end_date date) IS 'Get royalty summary statistics for a venue';


--
-- Name: initiate_escrow_dispute(uuid, text, jsonb, uuid); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.initiate_escrow_dispute(p_escrow_id uuid, p_dispute_reason text, p_dispute_evidence jsonb DEFAULT '{}'::jsonb, p_initiated_by uuid DEFAULT NULL::uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE marketplace.escrow
    SET 
        dispute_initiated = true,
        dispute_reason = p_dispute_reason,
        dispute_evidence = p_dispute_evidence || jsonb_build_object(
            'initiated_by', p_initiated_by,
            'initiated_at', CURRENT_TIMESTAMP
        ),
        resolution = 'pending'
    WHERE id = p_escrow_id
        AND status IN ('funded', 'held')
        AND dispute_initiated = false;
    
    RETURN FOUND;
END;
$$;



--
-- Name: FUNCTION initiate_escrow_dispute(p_escrow_id uuid, p_dispute_reason text, p_dispute_evidence jsonb, p_initiated_by uuid); Type: COMMENT; Schema: marketplace; Owner: postgres
--

COMMENT ON FUNCTION marketplace.initiate_escrow_dispute(p_escrow_id uuid, p_dispute_reason text, p_dispute_evidence jsonb, p_initiated_by uuid) IS 'Start dispute process for an escrow';


--
-- Name: manage_transaction_state(); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.manage_transaction_state() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Update payment timestamp
    IF NEW.payment_status IN ('captured', 'held_in_escrow') AND OLD.payment_status NOT IN ('captured', 'held_in_escrow') THEN
        NEW.paid_at := CURRENT_TIMESTAMP;
    END IF;
    
    -- Update transfer timestamp
    IF NEW.transfer_completed = true AND OLD.transfer_completed = false THEN
        NEW.transferred_at := CURRENT_TIMESTAMP;
        NEW.transfer_status := 'completed';
    END IF;
    
    -- Update completion timestamp
    IF NEW.transfer_completed = true AND NEW.escrow_released = true AND OLD.completed_at IS NULL THEN
        NEW.completed_at := CURRENT_TIMESTAMP;
    END IF;
    
    -- Update dispute timestamp
    IF NEW.escrow_dispute = true AND OLD.escrow_dispute = false THEN
        NEW.disputed_at := CURRENT_TIMESTAMP;
        NEW.payment_status := 'disputed';
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: release_escrow(uuid, text); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.release_escrow(p_transaction_id uuid, p_release_notes text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_can_release BOOLEAN;
BEGIN
    -- Check if escrow can be released
    SELECT 
        payment_status = 'held_in_escrow' 
        AND transfer_completed = true 
        AND escrow_dispute = false
    INTO v_can_release
    FROM marketplace.marketplace_transactions
    WHERE id = p_transaction_id;
    
    IF v_can_release THEN
        UPDATE marketplace.marketplace_transactions
        SET 
            escrow_released = true,
            payment_status = 'released',
            platform_notes = jsonb_set(
                COALESCE(platform_notes, '{}'::jsonb),
                '{escrow_release_notes}',
                to_jsonb(p_release_notes)
            )
        WHERE id = p_transaction_id;
        
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
END;
$$;



--
-- Name: FUNCTION release_escrow(p_transaction_id uuid, p_release_notes text); Type: COMMENT; Schema: marketplace; Owner: postgres
--

COMMENT ON FUNCTION marketplace.release_escrow(p_transaction_id uuid, p_release_notes text) IS 'Release escrowed funds to seller after successful transfer';


--
-- Name: release_escrow_funds(uuid, text, uuid); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.release_escrow_funds(p_escrow_id uuid, p_release_type text DEFAULT 'automatic'::text, p_authorized_by uuid DEFAULT NULL::uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_can_release BOOLEAN;
    v_escrow_record RECORD;
BEGIN
    -- Get escrow details
    SELECT * INTO v_escrow_record
    FROM marketplace.escrow
    WHERE id = p_escrow_id
    FOR UPDATE;
    
    IF NOT FOUND THEN
        RETURN FALSE;
    END IF;
    
    -- Check release conditions
    v_can_release := CASE
        WHEN v_escrow_record.status != 'held' THEN FALSE
        WHEN v_escrow_record.fraud_hold = true THEN FALSE
        WHEN v_escrow_record.dispute_initiated = true THEN FALSE
        WHEN p_release_type = 'automatic' AND v_escrow_record.automatic_release_date <= CURRENT_TIMESTAMP THEN TRUE
        WHEN p_release_type = 'manual' AND p_authorized_by IS NOT NULL THEN TRUE
        WHEN p_release_type = 'confirmed' AND v_escrow_record.seller_confirmation = true AND v_escrow_record.buyer_confirmation = true THEN TRUE
        ELSE FALSE
    END;
    
    IF v_can_release THEN
        UPDATE marketplace.escrow
        SET 
            status = 'released',
            manual_release_authorized = (p_release_type = 'manual'),
            release_authorized_by = p_authorized_by,
            automatic_triggers = automatic_triggers || jsonb_build_object(
                'release_type', p_release_type,
                'release_time', CURRENT_TIMESTAMP
            )
        WHERE id = p_escrow_id;
        
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
END;
$$;



--
-- Name: FUNCTION release_escrow_funds(p_escrow_id uuid, p_release_type text, p_authorized_by uuid); Type: COMMENT; Schema: marketplace; Owner: postgres
--

COMMENT ON FUNCTION marketplace.release_escrow_funds(p_escrow_id uuid, p_release_type text, p_authorized_by uuid) IS 'Release escrowed funds with validation';


--
-- Name: resolve_dispute(uuid, marketplace.resolution_decision, numeric, text, jsonb); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.resolve_dispute(p_dispute_id uuid, p_decision marketplace.resolution_decision, p_awarded_amount numeric DEFAULT NULL::numeric, p_rationale text DEFAULT NULL::text, p_account_actions jsonb DEFAULT '{}'::jsonb) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE marketplace.dispute_resolution
    SET 
        status = 'resolved',
        resolution_decision = p_decision,
        awarded_amount = COALESCE(p_awarded_amount, 
            CASE 
                WHEN p_decision = 'full_refund' THEN dispute_amount
                WHEN p_decision = 'no_refund' THEN 0
                ELSE p_awarded_amount
            END
        ),
        decision_rationale = p_rationale,
        account_actions = p_account_actions,
        resolution_method = CASE 
            WHEN mediation_required THEN 'mediation'
            WHEN arbitration_required THEN 'arbitration'
            ELSE 'platform_decision'
        END
    WHERE id = p_dispute_id
        AND status IN ('under_review', 'in_mediation', 'in_arbitration');
    
    RETURN FOUND;
END;
$$;



--
-- Name: FUNCTION resolve_dispute(p_dispute_id uuid, p_decision marketplace.resolution_decision, p_awarded_amount numeric, p_rationale text, p_account_actions jsonb); Type: COMMENT; Schema: marketplace; Owner: postgres
--

COMMENT ON FUNCTION marketplace.resolve_dispute(p_dispute_id uuid, p_decision marketplace.resolution_decision, p_awarded_amount numeric, p_rationale text, p_account_actions jsonb) IS 'Resolve a dispute with a decision';


--
-- Name: update_auction_rankings(); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.update_auction_rankings() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Only process auction bids
    IF NEW.offer_type = 'auction_bid' THEN
        -- Update rankings for all bids on this listing
        WITH ranked_offers AS (
            SELECT 
                id,
                ROW_NUMBER() OVER (ORDER BY offer_amount DESC, created_at ASC) as new_ranking
            FROM marketplace.offers
            WHERE listing_id = NEW.listing_id
                AND offer_type = 'auction_bid'
                AND status = 'pending'
        )
        UPDATE marketplace.offers o
        SET 
            offer_ranking = ro.new_ranking,
            current_high_offer = (
                SELECT MAX(offer_amount) 
                FROM marketplace.offers 
                WHERE listing_id = NEW.listing_id 
                    AND offer_type = 'auction_bid' 
                    AND status = 'pending'
            )
        FROM ranked_offers ro
        WHERE o.id = ro.id;
        
        -- Update the listing's current high bid
        UPDATE marketplace.listings
        SET current_high_bid = (
            SELECT MAX(offer_amount) 
            FROM marketplace.offers 
            WHERE listing_id = NEW.listing_id 
                AND offer_type = 'auction_bid' 
                AND status = 'pending'
        )
        WHERE id = NEW.listing_id;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: update_communication_log(); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.update_communication_log() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_dispute_id UUID;
BEGIN
    v_dispute_id := NEW.dispute_id;
    
    -- Update dispute communication metrics
    UPDATE marketplace.dispute_resolution
    SET 
        messages_count = messages_count + 1,
        last_response_at = NEW.created_at,
        communication_log = communication_log || jsonb_build_object(
            'message_id', NEW.id,
            'sender_id', NEW.sender_user_id,
            'timestamp', NEW.created_at,
            'type', NEW.message_type
        ),
        complainant_last_response = CASE 
            WHEN NEW.sender_user_id = complainant_user_id THEN NEW.created_at
            ELSE complainant_last_response
        END,
        respondent_last_response = CASE 
            WHEN NEW.sender_user_id = respondent_user_id THEN NEW.created_at
            ELSE respondent_last_response
        END
    WHERE id = v_dispute_id;
    
    RETURN NEW;
END;
$$;



--
-- Name: update_dispute_history(); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.update_dispute_history() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    
    -- Track status changes
    IF OLD.status IS DISTINCT FROM NEW.status THEN
        NEW.status_history = NEW.status_history || jsonb_build_object(
            'timestamp', CURRENT_TIMESTAMP,
            'from_status', OLD.status,
            'to_status', NEW.status,
            'changed_by', current_user,
            'notes', CASE 
                WHEN NEW.status = 'resolved' THEN NEW.decision_rationale
                WHEN NEW.status = 'appealed' THEN NEW.appeal_reason
                ELSE NULL
            END
        );
        NEW.previous_status = OLD.status;
        
        -- Update relevant timestamps
        CASE NEW.status
            WHEN 'under_review' THEN
                IF NEW.assigned_at IS NULL THEN
                    NEW.assigned_at = CURRENT_TIMESTAMP;
                END IF;
            WHEN 'resolved' THEN
                NEW.resolved_at = CURRENT_TIMESTAMP;
                -- Set appeal deadline (typically 7 days)
                IF NEW.appeal_allowed THEN
                    NEW.appeal_deadline = CURRENT_TIMESTAMP + INTERVAL '7 days';
                END IF;
            WHEN 'closed' THEN
                NEW.closed_at = CURRENT_TIMESTAMP;
            WHEN 'appealed' THEN
                NEW.appealed_at = CURRENT_TIMESTAMP;
                NEW.escalation_count = NEW.escalation_count + 1;
            ELSE
                -- No special handling
        END CASE;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: update_escrow_audit(); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.update_escrow_audit() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    
    -- Add status change to history
    IF OLD.status IS DISTINCT FROM NEW.status THEN
        NEW.status_history = NEW.status_history || jsonb_build_object(
            'timestamp', CURRENT_TIMESTAMP,
            'from_status', OLD.status,
            'to_status', NEW.status,
            'reason', COALESCE(
                CASE 
                    WHEN NEW.dispute_initiated THEN 'dispute_initiated'
                    WHEN NEW.fraud_hold THEN 'fraud_hold'
                    WHEN NEW.manual_release_authorized THEN 'manual_release'
                    ELSE 'status_change'
                END,
                'status_change'
            )
        );
        NEW.previous_status = OLD.status;
    END IF;
    
    -- Add to audit log
    NEW.audit_log = NEW.audit_log || jsonb_build_object(
        'timestamp', CURRENT_TIMESTAMP,
        'action', TG_OP,
        'changed_fields', (
            SELECT jsonb_object_agg(key, value)
            FROM jsonb_each(to_jsonb(NEW))
            WHERE to_jsonb(NEW) -> key IS DISTINCT FROM to_jsonb(OLD) -> key
        )
    );
    
    RETURN NEW;
END;
$$;



--
-- Name: update_listing_timestamp(); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.update_listing_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: update_offer_timestamp(); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.update_offer_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: update_royalty_timestamp(); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.update_royalty_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    
    -- Update audit trail
    NEW.audit_trail = NEW.audit_trail || jsonb_build_object(
        'timestamp', CURRENT_TIMESTAMP,
        'action', TG_OP,
        'old_status', OLD.payment_status,
        'new_status', NEW.payment_status
    );
    
    RETURN NEW;
END;
$$;



--
-- Name: update_transaction_timestamp(); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.update_transaction_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: validate_escrow_transition(); Type: FUNCTION; Schema: marketplace; Owner: postgres
--

CREATE FUNCTION marketplace.validate_escrow_transition() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Validate status transitions
    IF OLD.status = 'released' AND NEW.status != 'released' THEN
        RAISE EXCEPTION 'Cannot change status from released';
    END IF;
    
    IF OLD.status = 'refunded' AND NEW.status != 'refunded' THEN
        RAISE EXCEPTION 'Cannot change status from refunded';
    END IF;
    
    -- Validate dispute initiation
    IF NEW.dispute_initiated = true AND OLD.dispute_initiated = false THEN
        IF NEW.status NOT IN ('funded', 'held') THEN
            RAISE EXCEPTION 'Can only initiate dispute for funded or held escrows';
        END IF;
        NEW.status = 'disputed';
        NEW.disputed_at = CURRENT_TIMESTAMP;
    END IF;
    
    -- Update timestamps based on status changes
    CASE NEW.status
        WHEN 'funded' THEN
            IF OLD.status != 'funded' THEN
                NEW.funded_at = CURRENT_TIMESTAMP;
            END IF;
        WHEN 'released' THEN
            IF OLD.status != 'released' THEN
                NEW.released_at = CURRENT_TIMESTAMP;
            END IF;
        WHEN 'refunded' THEN
            IF OLD.status != 'refunded' THEN
                NEW.refunded_at = CURRENT_TIMESTAMP;
            END IF;
        ELSE
            -- No special handling
    END CASE;
    
    RETURN NEW;
END;
$$;



--
-- Name: add_provider_event(character varying, character varying, jsonb); Type: FUNCTION; Schema: notifications; Owner: postgres
--

CREATE FUNCTION notifications.add_provider_event(p_message_id character varying, p_event_type character varying, p_event_data jsonb) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE delivery_tracking
    SET provider_events = provider_events || jsonb_build_array(
        jsonb_build_object(
            'type', p_event_type,
            'timestamp', CURRENT_TIMESTAMP,
            'data', p_event_data
        )
    ),
    webhook_received_at = CURRENT_TIMESTAMP,
    webhook_data = p_event_data
    WHERE message_id = p_message_id;
END;
$$;



--
-- Name: calculate_campaign_metrics(uuid); Type: FUNCTION; Schema: notifications; Owner: postgres
--

CREATE FUNCTION notifications.calculate_campaign_metrics(campaign_id uuid) RETURNS TABLE(open_rate numeric, click_rate numeric, conversion_rate numeric, roi numeric, cost_per_conversion numeric)
    LANGUAGE plpgsql
    AS $$
DECLARE
    campaign_record RECORD;
BEGIN
    SELECT * INTO campaign_record FROM campaigns WHERE id = campaign_id;
    
    RETURN QUERY
    SELECT 
        CASE WHEN campaign_record.sends_count > 0 
            THEN ROUND((campaign_record.opens_count::DECIMAL / campaign_record.sends_count) * 100, 2)
            ELSE 0 
        END AS open_rate,
        CASE WHEN campaign_record.opens_count > 0 
            THEN ROUND((campaign_record.clicks_count::DECIMAL / campaign_record.opens_count) * 100, 2)
            ELSE 0 
        END AS click_rate,
        CASE WHEN campaign_record.sends_count > 0 
            THEN ROUND((campaign_record.conversions_count::DECIMAL / campaign_record.sends_count) * 100, 2)
            ELSE 0 
        END AS conversion_rate,
        CASE WHEN campaign_record.spent_amount > 0 
            THEN ROUND((campaign_record.revenue_generated - campaign_record.spent_amount) / campaign_record.spent_amount * 100, 2)
            ELSE 0 
        END AS roi,
        CASE WHEN campaign_record.conversions_count > 0 
            THEN ROUND(campaign_record.spent_amount / campaign_record.conversions_count, 2)
            ELSE 0 
        END AS cost_per_conversion;
END;
$$;



--
-- Name: generate_unsubscribe_token(); Type: FUNCTION; Schema: notifications; Owner: postgres
--

CREATE FUNCTION notifications.generate_unsubscribe_token() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    token VARCHAR;
BEGIN
    -- Generate a URL-safe random token
    token := encode(gen_random_bytes(32), 'base64');
    -- Replace URL-unsafe characters
    token := replace(token, '+', '-');
    token := replace(token, '/', '_');
    token := replace(token, '=', '');
    RETURN token;
END;
$$;



--
-- Name: set_unsubscribe_token(); Type: FUNCTION; Schema: notifications; Owner: postgres
--

CREATE FUNCTION notifications.set_unsubscribe_token() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.unsubscribe_token IS NULL THEN
        NEW.unsubscribe_token := generate_unsubscribe_token();
    END IF;
    RETURN NEW;
END;
$$;



--
-- Name: update_campaign_audience_count(); Type: FUNCTION; Schema: notifications; Owner: postgres
--

CREATE FUNCTION notifications.update_campaign_audience_count() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    total_count INTEGER;
BEGIN
    -- This is a placeholder - actual implementation would calculate from segments
    -- For now, just ensure the count is non-negative
    IF NEW.audience_count < 0 THEN
        NEW.audience_count = 0;
    END IF;
    
    -- Update excluded count if suppression lists change
    IF NEW.suppression_list_ids != OLD.suppression_list_ids THEN
        -- Placeholder: actual implementation would calculate from suppression lists
        NEW.excluded_count = COALESCE(array_length(NEW.suppression_list_ids, 1), 0) * 100;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: update_campaigns_updated_at(); Type: FUNCTION; Schema: notifications; Owner: postgres
--

CREATE FUNCTION notifications.update_campaigns_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: update_delivery_tracking_updated_at(); Type: FUNCTION; Schema: notifications; Owner: postgres
--

CREATE FUNCTION notifications.update_delivery_tracking_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: update_notification_preferences_updated_at(); Type: FUNCTION; Schema: notifications; Owner: postgres
--

CREATE FUNCTION notifications.update_notification_preferences_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: update_updated_at_column(); Type: FUNCTION; Schema: notifications; Owner: postgres
--

CREATE FUNCTION notifications.update_updated_at_column() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: add_event_performer(uuid, character varying, public.performer_type, integer, numeric, interval, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_event_performer(p_event_id uuid, p_performer_name character varying, p_performer_type public.performer_type, p_performance_order integer DEFAULT NULL::integer, p_performance_fee numeric DEFAULT NULL::numeric, p_set_duration interval DEFAULT NULL::interval, p_created_by_user_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_performer_id UUID;
    next_order INTEGER;
BEGIN
    -- Calculate next performance order if not provided
    IF p_performance_order IS NULL THEN
        SELECT COALESCE(MAX(performance_order), 0) + 1 INTO next_order
        FROM event_performers
        WHERE event_id = p_event_id;
    ELSE
        next_order = p_performance_order;
    END IF;
    
    INSERT INTO event_performers (
        event_id, performer_name, performer_type, performance_order,
        performance_fee, set_duration, created_by_user_id
    )
    VALUES (
        p_event_id, p_performer_name, p_performer_type, next_order,
        p_performance_fee, p_set_duration, p_created_by_user_id
    )
    RETURNING id INTO new_performer_id;
    
    RETURN new_performer_id;
END;
$$;



--
-- Name: add_layout_section(uuid, character varying, character varying, public.section_type, integer, public.pricing_tier, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_layout_section(p_layout_id uuid, p_section_name character varying, p_section_code character varying, p_section_type public.section_type, p_capacity integer, p_pricing_tier public.pricing_tier DEFAULT 'general_admission'::public.pricing_tier, p_wheelchair_seats integer DEFAULT 0, p_companion_seats integer DEFAULT 0) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_section_id UUID;
    v_venue_id UUID;
BEGIN
    -- Get venue ID from layout
    SELECT venue_id INTO v_venue_id FROM venue_layouts WHERE id = p_layout_id;
    
    INSERT INTO layout_sections (
        layout_id, venue_id, section_name, section_code, section_type,
        section_capacity, pricing_tier, wheelchair_seats, companion_seats
    )
    VALUES (
        p_layout_id, v_venue_id, p_section_name, p_section_code, p_section_type,
        p_capacity, p_pricing_tier, p_wheelchair_seats, p_companion_seats
    )
    RETURNING id INTO new_section_id;
    
    RETURN new_section_id;
END;
$$;



--
-- Name: add_schedule_activity(uuid, character varying, public.activity_type, timestamp with time zone, interval, integer, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_schedule_activity(p_schedule_id uuid, p_activity_name character varying, p_activity_type public.activity_type, p_start_time timestamp with time zone, p_duration interval DEFAULT NULL::interval, p_activity_order integer DEFAULT NULL::integer, p_created_by_user_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_activity_id UUID;
    next_order INTEGER;
BEGIN
    -- Calculate next activity order if not provided
    IF p_activity_order IS NULL THEN
        SELECT COALESCE(MAX(activity_order), 0) + 1 INTO next_order
        FROM schedule_activities
        WHERE schedule_id = p_schedule_id;
    ELSE
        next_order = p_activity_order;
    END IF;
    
    INSERT INTO schedule_activities (
        schedule_id, activity_name, activity_type, scheduled_start_time,
        duration, activity_order, created_by_user_id
    )
    VALUES (
        p_schedule_id, p_activity_name, p_activity_type, p_start_time,
        p_duration, next_order, p_created_by_user_id
    )
    RETURNING id INTO new_activity_id;
    
    RETURN new_activity_id;
END;
$$;



--
-- Name: add_schedule_exception(uuid, date, character varying, text, character varying, timestamp with time zone, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_schedule_exception(p_schedule_id uuid, p_exception_date date, p_exception_type character varying, p_exception_reason text DEFAULT NULL::text, p_action_type character varying DEFAULT 'cancel'::character varying, p_replacement_datetime timestamp with time zone DEFAULT NULL::timestamp with time zone, p_created_by_user_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_exception_id UUID;
BEGIN
    INSERT INTO schedule_exceptions (
        schedule_id, exception_date, exception_type, exception_reason,
        action_type, replacement_datetime, created_by_user_id
    )
    VALUES (
        p_schedule_id, p_exception_date, p_exception_type, p_exception_reason,
        p_action_type, p_replacement_datetime, p_created_by_user_id
    )
    RETURNING id INTO new_exception_id;
    
    RETURN new_exception_id;
END;
$$;



--
-- Name: add_section_seats(uuid, integer, integer, character varying, integer, integer, public.seat_type); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_section_seats(p_section_id uuid, p_rows integer, p_seats_per_row integer, p_row_prefix character varying DEFAULT ''::character varying, p_start_row integer DEFAULT 1, p_start_seat integer DEFAULT 1, p_seat_type public.seat_type DEFAULT 'standard'::public.seat_type) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_layout_id UUID;
    v_venue_id UUID;
    seats_added INTEGER := 0;
    current_row INTEGER;
    current_seat INTEGER;
    row_identifier VARCHAR(20);
    seat_number VARCHAR(20);
BEGIN
    -- Get layout and venue IDs
    SELECT layout_id, venue_id INTO v_layout_id, v_venue_id
    FROM layout_sections
    WHERE id = p_section_id;
    
    -- Add seats for each row
    FOR current_row IN p_start_row..(p_start_row + p_rows - 1) LOOP
        row_identifier = p_row_prefix || current_row::TEXT;
        
        FOR current_seat IN p_start_seat..(p_start_seat + p_seats_per_row - 1) LOOP
            seat_number = current_seat::TEXT;
            
            INSERT INTO layout_seats (
                section_id, layout_id, venue_id, seat_number, row_identifier, seat_type
            )
            VALUES (
                p_section_id, v_layout_id, v_venue_id, seat_number, row_identifier, p_seat_type
            );
            
            seats_added := seats_added + 1;
        END LOOP;
    END LOOP;
    
    RETURN seats_added;
END;
$$;



--
-- Name: add_venue_staff(uuid, uuid, public.staff_role, public.employment_type, character varying, date, numeric, public.access_level, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_venue_staff(p_venue_id uuid, p_user_id uuid, p_staff_role public.staff_role, p_employment_type public.employment_type DEFAULT 'part_time'::public.employment_type, p_job_title character varying DEFAULT NULL::character varying, p_hire_date date DEFAULT CURRENT_DATE, p_hourly_rate numeric DEFAULT NULL::numeric, p_access_level public.access_level DEFAULT 'public_only'::public.access_level, p_created_by_user_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_staff_id UUID;
BEGIN
    INSERT INTO venue_staff (
        venue_id, user_id, staff_role, employment_type, job_title,
        hire_date, hourly_rate, access_level, created_by_user_id
    )
    VALUES (
        p_venue_id, p_user_id, p_staff_role, p_employment_type, p_job_title,
        p_hire_date, p_hourly_rate, p_access_level, p_created_by_user_id
    )
    RETURNING id INTO new_staff_id;
    
    RETURN new_staff_id;
END;
$$;



--
-- Name: anonymize_email(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.anonymize_email(email_address text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
   parts TEXT[];
   username TEXT;
   domain TEXT;
BEGIN
   parts := string_to_array(email_address, '@');
   IF array_length(parts, 1) != 2 THEN
       RETURN 'invalid@example.com';
   END IF;
   
   username := parts[1];
   domain := parts[2];
   
   IF length(username) <= 2 THEN
       username := repeat('*', length(username));
   ELSE
       username := substr(username, 1, 1) || repeat('*', length(username) - 2) || substr(username, length(username), 1);
   END IF;
   
   RETURN username || '@' || domain;
END;
$$;



--
-- Name: FUNCTION anonymize_email(email_address text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.anonymize_email(email_address text) IS 'Anonymize email address for privacy';


--
-- Name: apply_dynamic_pricing_rule(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.apply_dynamic_pricing_rule(p_rule_id uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_rule RECORD;
    v_condition_met BOOLEAN := false;
    v_new_price DECIMAL(10,2);
    v_tier_id UUID;
BEGIN
    SELECT * INTO v_rule
    FROM event_pricing_dynamic_rules
    WHERE id = p_rule_id AND is_active = true;
    
    IF NOT FOUND THEN
        RETURN false;
    END IF;
    
    -- Check cooldown period
    IF v_rule.last_applied IS NOT NULL AND 
       v_rule.last_applied + v_rule.cooldown_period > CURRENT_TIMESTAMP THEN
        RETURN false;
    END IF;
    
    -- Evaluate trigger condition (simplified - would need more complex logic)
    -- This is a placeholder for condition evaluation
    v_condition_met := true; -- Would implement actual condition checking
    
    IF v_condition_met THEN
        -- Apply pricing adjustment to applicable tiers
        FOR v_tier_id IN SELECT unnest(v_rule.applies_to_tiers) LOOP
            -- Calculate new price based on adjustment type
            SELECT 
                CASE v_rule.price_adjustment_type
                    WHEN 'PERCENTAGE' THEN base_price * (1 + v_rule.adjustment_value / 100)
                    WHEN 'FIXED_AMOUNT' THEN base_price + v_rule.adjustment_value
                    WHEN 'MULTIPLIER' THEN base_price * v_rule.adjustment_value
                    WHEN 'SET_PRICE' THEN v_rule.adjustment_value
                    ELSE base_price
                END INTO v_new_price
            FROM event_pricing_tiers
            WHERE id = v_tier_id;
            
            -- Apply min/max constraints
            IF v_rule.min_adjustment IS NOT NULL THEN
                v_new_price := GREATEST(v_new_price, v_rule.min_adjustment);
            END IF;
            
            IF v_rule.max_adjustment IS NOT NULL THEN
                v_new_price := LEAST(v_new_price, v_rule.max_adjustment);
            END IF;
            
            -- Update tier price and log change
            UPDATE event_pricing_tiers 
            SET base_price = v_new_price, updated_at = CURRENT_TIMESTAMP
            WHERE id = v_tier_id;
            
            -- Log pricing history
            INSERT INTO event_pricing_history (
                event_pricing_id, tier_id, change_type, old_price, new_price,
                reason, triggered_by
            ) VALUES (
                v_rule.event_pricing_id, v_tier_id, 'DYNAMIC_ADJUSTMENT',
                (SELECT base_price FROM event_pricing_tiers WHERE id = v_tier_id),
                v_new_price, 'Dynamic pricing rule applied', v_rule.rule_name
            );
        END LOOP;
        
        -- Update rule last applied timestamp
        UPDATE event_pricing_dynamic_rules
        SET last_applied = CURRENT_TIMESTAMP
        WHERE id = p_rule_id;
        
        RETURN true;
    END IF;
    
    RETURN false;
END;
$$;



--
-- Name: apply_metadata_template(uuid, uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.apply_metadata_template(p_event_id uuid, p_template_id uuid, p_user_id uuid DEFAULT NULL::uuid, p_override_existing boolean DEFAULT false) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_template RECORD;
    v_metadata_item JSONB;
    v_applied_count INTEGER := 0;
    v_existing_count INTEGER;
BEGIN
    -- Get template
    SELECT * INTO v_template
    FROM event_metadata_templates
    WHERE id = p_template_id AND is_active = true;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Template not found or inactive';
    END IF;
    
    -- Apply each metadata item from template
    FOR v_metadata_item IN SELECT * FROM jsonb_array_elements(v_template.template_data)
    LOOP
        -- Check if metadata already exists
        SELECT COUNT(*) INTO v_existing_count
        FROM event_metadata
        WHERE event_id = p_event_id
          AND metadata_type = (v_metadata_item->>'metadata_type')
          AND metadata_key = (v_metadata_item->>'metadata_key')
          AND is_current_version = true;
        
        -- Apply if doesn't exist or override is allowed
        IF v_existing_count = 0 OR p_override_existing THEN
            PERFORM set_event_metadata(
                p_event_id,
                v_metadata_item->>'metadata_type',
                v_metadata_item->>'metadata_key',
                v_metadata_item->>'metadata_value',
                CASE WHEN v_metadata_item ? 'metadata_json' THEN v_metadata_item->'metadata_json' ELSE NULL END,
                p_user_id
            );
            v_applied_count := v_applied_count + 1;
        END IF;
    END LOOP;
    
    -- Update template usage count
    UPDATE event_metadata_templates
    SET usage_count = usage_count + 1
    WHERE id = p_template_id;
    
    RETURN v_applied_count;
END;
$$;



--
-- Name: archive_audit_logs(timestamp with time zone, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.archive_audit_logs(p_archive_before_date timestamp with time zone DEFAULT (now() - '1 year'::interval), p_batch_size integer DEFAULT 1000) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    archived_count INTEGER := 0;
    batch_count INTEGER;
BEGIN
    LOOP
        -- Archive records in batches
        UPDATE audit_logs
        SET is_archived = TRUE,
            archived_at = NOW(),
            archive_location = 'cold_storage'
        WHERE id IN (
            SELECT id FROM audit_logs
            WHERE created_at < p_archive_before_date
            AND is_archived = FALSE
            ORDER BY created_at
            LIMIT p_batch_size
        );
        
        GET DIAGNOSTICS batch_count = ROW_COUNT;
        archived_count := archived_count + batch_count;
        
        -- Exit if no more records to archive
        EXIT WHEN batch_count = 0;
        
        -- Commit batch and pause to avoid long locks
        COMMIT;
    END LOOP;
    
    RETURN archived_count;
END;
$$;



--
-- Name: assign_user_role(uuid, uuid, uuid, uuid, uuid, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.assign_user_role(p_user_id uuid, p_role_id uuid, p_assigned_by_user_id uuid DEFAULT NULL::uuid, p_venue_id uuid DEFAULT NULL::uuid, p_event_id uuid DEFAULT NULL::uuid, p_expires_at timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    assignment_id UUID;
BEGIN
    -- Check if role assignment already exists and is active
    IF EXISTS (
        SELECT 1 FROM user_roles 
        WHERE user_id = p_user_id AND role_id = p_role_id 
        AND venue_id IS NOT DISTINCT FROM p_venue_id 
        AND event_id IS NOT DISTINCT FROM p_event_id
        AND is_active = true
        AND (expires_at IS NULL OR expires_at > NOW())
    ) THEN
        RAISE EXCEPTION 'User already has this role assignment';
    END IF;
    
    INSERT INTO user_roles (
        user_id, role_id, assigned_by_user_id, venue_id, event_id, expires_at
    )
    VALUES (
        p_user_id, p_role_id, p_assigned_by_user_id, p_venue_id, p_event_id, p_expires_at
    )
    RETURNING id INTO assignment_id;
    
    RETURN assignment_id;
END;
$$;



--
-- Name: audit_trigger_simple(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.audit_trigger_simple() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP = 'DELETE' THEN
        INSERT INTO audit_logs (table_name, record_id, action, old_data)
        VALUES (TG_TABLE_NAME, OLD.id, TG_OP, to_jsonb(OLD));
        RETURN OLD;
    ELSE
        INSERT INTO audit_logs (table_name, record_id, action, new_data, old_data)
        VALUES (TG_TABLE_NAME, NEW.id, TG_OP, to_jsonb(NEW), 
                CASE WHEN TG_OP = 'UPDATE' THEN to_jsonb(OLD) ELSE NULL END);
        RETURN NEW;
    END IF;
END;
$$;



--
-- Name: bulk_create_tickets(uuid, uuid, integer, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.bulk_create_tickets(p_event_id uuid, p_ticket_type_id uuid, p_quantity integer, p_created_by uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_batch_id UUID;
    v_ticket_id UUID;
    v_i INTEGER;
    v_ticket_number VARCHAR(50);
    v_barcode VARCHAR(100);
    v_ticket_type RECORD;
BEGIN
    -- Get ticket type details
    SELECT * INTO v_ticket_type FROM ticket_types WHERE id = p_ticket_type_id;
    
    -- Create batch operation record
    INSERT INTO ticket_batch_operations (
        operation_type, event_id, ticket_type_id, operation_parameters,
        total_tickets, initiated_by
    ) VALUES (
        'BULK_CREATE', p_event_id, p_ticket_type_id,
        jsonb_build_object('quantity', p_quantity, 'auto_assign_seats', false),
        p_quantity, p_created_by
    ) RETURNING id INTO v_batch_id;
    
    -- Update batch status
    UPDATE ticket_batch_operations
    SET status = 'PROCESSING', started_at = CURRENT_TIMESTAMP
    WHERE id = v_batch_id;
    
    -- Create tickets in loop
    FOR v_i IN 1..p_quantity LOOP
        BEGIN
            v_ticket_number := generate_ticket_number(p_event_id, p_ticket_type_id);
            v_barcode := generate_barcode(uuid_generate_v1());
            
            INSERT INTO tickets (
                event_id, ticket_type_id, owner_user_id, purchaser_user_id,
                ticket_number, barcode, purchase_price, total_paid,
                status, created_by
            ) VALUES (
                p_event_id, p_ticket_type_id, p_created_by, p_created_by,
                v_ticket_number, v_barcode, v_ticket_type.base_price, v_ticket_type.total_price,
                'AVAILABLE', p_created_by
            ) RETURNING id INTO v_ticket_id;
            
            -- Update batch progress
            UPDATE ticket_batch_operations
            SET 
                processed_tickets = processed_tickets + 1,
                successful_tickets = successful_tickets + 1,
                progress_percentage = ((processed_tickets + 1.0) / total_tickets) * 100,
                ticket_ids = array_append(ticket_ids, v_ticket_id)
            WHERE id = v_batch_id;
            
        EXCEPTION WHEN OTHERS THEN
            -- Update failed count
            UPDATE ticket_batch_operations
            SET 
                processed_tickets = processed_tickets + 1,
                failed_tickets = failed_tickets + 1,
                progress_percentage = ((processed_tickets + 1.0) / total_tickets) * 100,
                error_messages = array_append(error_messages, SQLERRM)
            WHERE id = v_batch_id;
        END;
    END LOOP;
    
    -- Complete batch operation
    UPDATE ticket_batch_operations
    SET status = 'COMPLETED', completed_at = CURRENT_TIMESTAMP
    WHERE id = v_batch_id;
    
    RETURN v_batch_id;
END;
$$;



--
-- Name: calculate_age(date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_age(birth_date date) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
   RETURN EXTRACT(YEAR FROM age(CURRENT_DATE, birth_date));
END;
$$;



--
-- Name: FUNCTION calculate_age(birth_date date); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.calculate_age(birth_date date) IS 'Calculate age in years from birth date';


--
-- Name: calculate_audit_checksum(jsonb); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_audit_checksum(record_data jsonb) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
    RETURN encode(digest(record_data::text, 'sha256'), 'hex');
END;
$$;



--
-- Name: calculate_category_popularity(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_category_popularity(p_category_id uuid) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_score DECIMAL(8,4) := 0;
    v_recent_events INTEGER;
    v_recent_sales INTEGER;
    v_search_volume INTEGER;
    v_social_mentions INTEGER;
BEGIN
    -- Get recent activity (last 30 days)
    SELECT 
        COUNT(DISTINCT ecm.event_id),
        COALESCE(SUM(t.quantity), 0),
        COALESCE(SUM(eca.search_impressions), 0)
    INTO v_recent_events, v_recent_sales, v_search_volume
    FROM event_category_mappings ecm
    LEFT JOIN events e ON ecm.event_id = e.id
    LEFT JOIN tickets t ON e.id = t.event_id AND t.created_at >= CURRENT_DATE - INTERVAL '30 days'
    LEFT JOIN event_category_analytics eca ON ecm.category_id = eca.category_id AND eca.analytics_date >= CURRENT_DATE - INTERVAL '30 days'
    WHERE ecm.category_id = p_category_id;
    
    -- Calculate weighted score
    v_score := (v_recent_events * 0.3) + (v_recent_sales * 0.4) + (v_search_volume * 0.0001) + (COALESCE(v_social_mentions, 0) * 0.2);
    
    -- Normalize score (0-100 scale)
    v_score := LEAST(100, v_score);
    
    RETURN v_score;
END;
$$;



--
-- Name: calculate_dynamic_price(uuid, numeric); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_dynamic_price(p_ticket_id uuid, p_base_price numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_days_until_event INTEGER;
  v_demand_factor NUMERIC;
  v_similar_sales_avg NUMERIC;
  v_suggested_price NUMERIC;
BEGIN
  -- Calculate days until event
  SELECT EXTRACT(DAY FROM e.start_date - CURRENT_TIMESTAMP)
  INTO v_days_until_event
  FROM public.tickets t
  JOIN public.events e ON t.event_id = e.id
  WHERE t.id = p_ticket_id;

  -- Calculate demand factor based on recent sales
  SELECT AVG(sale_price / original_price)
  INTO v_demand_factor
  FROM public.marketplace_transactions mt
  JOIN public.tickets t ON mt.ticket_id = t.id
  WHERE t.event_id = (SELECT event_id FROM public.tickets WHERE id = p_ticket_id)
  AND mt.status = 'COMPLETED'
  AND mt.created_at >= CURRENT_TIMESTAMP - INTERVAL '7 days';

  -- Get average of similar recent sales
  SELECT AVG(sale_price)
  INTO v_similar_sales_avg
  FROM public.marketplace_transactions mt
  JOIN public.tickets t ON mt.ticket_id = t.id
  WHERE t.ticket_type_id = (SELECT ticket_type_id FROM public.tickets WHERE id = p_ticket_id)
  AND mt.status = 'COMPLETED'
  AND mt.created_at >= CURRENT_TIMESTAMP - INTERVAL '30 days';

  -- Calculate suggested price
  v_suggested_price := p_base_price;

  -- Adjust for time until event
  IF v_days_until_event <= 7 THEN
      v_suggested_price := v_suggested_price * 1.2;
  ELSIF v_days_until_event <= 30 THEN
      v_suggested_price := v_suggested_price * 1.1;
  END IF;

  -- Adjust for demand
  IF v_demand_factor IS NOT NULL THEN
      v_suggested_price := v_suggested_price * v_demand_factor;
  END IF;

  -- Consider recent sales
  IF v_similar_sales_avg IS NOT NULL THEN
      v_suggested_price := (v_suggested_price + v_similar_sales_avg) / 2;
  END IF;

  RETURN ROUND(v_suggested_price, 2);
END;
$$;



--
-- Name: calculate_fees(numeric, uuid, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_fees(ticket_price numeric, venue_id uuid, is_primary_sale boolean DEFAULT true) RETURNS TABLE(platform_fee numeric, venue_fee numeric, payment_processor_fee numeric, total_fees numeric, net_to_venue numeric)
    LANGUAGE plpgsql STABLE PARALLEL SAFE
    AS $_$
DECLARE
    v_platform_fee_rate NUMERIC;
    v_venue_fee_rate NUMERIC;
    v_payment_fee_rate NUMERIC := 0.029; -- 2.9% + $0.30
    v_payment_fee_fixed NUMERIC := 0.30;
BEGIN
    -- Validate inputs
    IF ticket_price <= 0 THEN
        RAISE EXCEPTION 'Ticket price must be positive';
    END IF;
    
    -- Get fee rates (would normally come from venue_settings)
    IF is_primary_sale THEN
        v_platform_fee_rate := 0.10; -- 10% for primary
        v_venue_fee_rate := 0.00;
    ELSE
        v_platform_fee_rate := 0.05; -- 5% for secondary
        v_venue_fee_rate := 0.10; -- 10% royalty to venue
    END IF;
    
    -- Calculate fees
    platform_fee := ROUND(ticket_price * v_platform_fee_rate, 2);
    venue_fee := ROUND(ticket_price * v_venue_fee_rate, 2);
    payment_processor_fee := ROUND(ticket_price * v_payment_fee_rate + v_payment_fee_fixed, 2);
    total_fees := platform_fee + venue_fee + payment_processor_fee;
    net_to_venue := ticket_price - total_fees;
    
    RETURN NEXT;
END;
$_$;



--
-- Name: FUNCTION calculate_fees(ticket_price numeric, venue_id uuid, is_primary_sale boolean); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.calculate_fees(ticket_price numeric, venue_id uuid, is_primary_sale boolean) IS 'Calculates all fees for a ticket transaction';


--
-- Name: calculate_invoice_totals(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_invoice_totals() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_subtotal DECIMAL(12, 2) := 0;
    v_tax_total DECIMAL(10, 2) := 0;
    v_line_item JSONB;
BEGIN
    -- Calculate totals from line items
    FOR v_line_item IN SELECT * FROM jsonb_array_elements(NEW.line_items)
    LOOP
        v_subtotal := v_subtotal + COALESCE((v_line_item->>'total')::DECIMAL, 0);
        v_tax_total := v_tax_total + COALESCE((v_line_item->>'tax_amount')::DECIMAL, 0);
    END LOOP;
    
    -- Update invoice totals if in draft status
    IF NEW.status = 'draft' THEN
        NEW.subtotal = v_subtotal;
        NEW.tax_amount = v_tax_total;
        NEW.total_amount = NEW.subtotal - NEW.discount_amount + NEW.tax_amount + NEW.shipping_amount;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: calculate_next_billing_period(timestamp with time zone, character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_next_billing_period(p_current_end timestamp with time zone, p_billing_cycle character varying, p_billing_interval integer DEFAULT NULL::integer) RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_next_end TIMESTAMP WITH TIME ZONE;
BEGIN
    CASE p_billing_cycle
        WHEN 'weekly' THEN
            v_next_end := p_current_end + INTERVAL '1 week';
        WHEN 'biweekly' THEN
            v_next_end := p_current_end + INTERVAL '2 weeks';
        WHEN 'monthly' THEN
            v_next_end := p_current_end + INTERVAL '1 month';
        WHEN 'quarterly' THEN
            v_next_end := p_current_end + INTERVAL '3 months';
        WHEN 'semiannual' THEN
            v_next_end := p_current_end + INTERVAL '6 months';
        WHEN 'annual' THEN
            v_next_end := p_current_end + INTERVAL '1 year';
        WHEN 'biennial' THEN
            v_next_end := p_current_end + INTERVAL '2 years';
        WHEN 'custom' THEN
            v_next_end := p_current_end + (p_billing_interval || ' days')::INTERVAL;
        ELSE
            v_next_end := p_current_end + INTERVAL '1 month';
    END CASE;
    
    RETURN v_next_end;
END;
$$;



--
-- Name: calculate_report_metrics(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_report_metrics() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Calculate average transaction value
    IF NEW.total_transactions > 0 AND NEW.gross_revenue IS NOT NULL THEN
        NEW.average_transaction_value = NEW.gross_revenue / NEW.total_transactions;
    END IF;
    
    -- Calculate net revenue
    IF NEW.gross_revenue IS NOT NULL THEN
        NEW.net_revenue = NEW.gross_revenue - 
                         COALESCE(NEW.platform_fees, 0) - 
                         COALESCE(NEW.processing_fees, 0) - 
                         COALESCE(NEW.refunds, 0) - 
                         COALESCE(NEW.chargebacks, 0);
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: calculate_royalties(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_royalties() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_venue_id UUID;
  v_royalty_percentage NUMERIC(5, 2);
  v_royalty_amount NUMERIC(10, 2);
BEGIN
  -- Only calculate for completed sales
  IF NEW.status = 'COMPLETED' AND OLD.status != 'COMPLETED' THEN
      -- Get venue and royalty percentage
      SELECT v.id, COALESCE(v.resale_royalty_percentage, 2.5)
      INTO v_venue_id, v_royalty_percentage
      FROM public.tickets t
      JOIN public.events e ON t.event_id = e.id
      JOIN public.venues v ON e.venue_id = v.id
      WHERE t.id = NEW.ticket_id;

      -- Calculate royalty amount
      v_royalty_amount := ROUND(NEW.sale_price * (v_royalty_percentage / 100.0), 2);

      -- Create royalty record
      INSERT INTO public.royalties (
          marketplace_transaction_id, venue_id, recipient_id,
          royalty_percentage, sale_amount, royalty_amount
      )
      SELECT 
          NEW.id, v_venue_id, v.owner_id,
          v_royalty_percentage, NEW.sale_price, v_royalty_amount
      FROM public.venues v
      WHERE v.id = v_venue_id;
  END IF;
  
  RETURN NEW;
END;
$$;



--
-- Name: calculate_royalties(numeric, numeric, uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_royalties(sale_price numeric, original_price numeric, venue_id uuid, artist_id uuid DEFAULT NULL::uuid) RETURNS TABLE(venue_royalty numeric, artist_royalty numeric, platform_royalty numeric, total_royalties numeric, seller_proceeds numeric)
    LANGUAGE plpgsql STABLE PARALLEL SAFE
    AS $$
DECLARE
    v_venue_royalty_rate NUMERIC := 0.10; -- 10% to venue
    v_artist_royalty_rate NUMERIC := 0.05; -- 5% to artist if applicable
    v_platform_royalty_rate NUMERIC := 0.025; -- 2.5% to platform
    v_price_increase NUMERIC;
BEGIN
    -- Validate inputs
    IF sale_price <= 0 OR original_price <= 0 THEN
        RAISE EXCEPTION 'Prices must be positive';
    END IF;
    
    -- Calculate price increase for dynamic royalties
    v_price_increase := GREATEST(0, sale_price - original_price);
    
    -- Base royalties on sale price
    venue_royalty := ROUND(sale_price * v_venue_royalty_rate, 2);
    
    -- Artist royalty only if artist_id provided
    IF artist_id IS NOT NULL THEN
        artist_royalty := ROUND(sale_price * v_artist_royalty_rate, 2);
    ELSE
        artist_royalty := 0;
    END IF;
    
    -- Platform gets extra on price increases
    platform_royalty := ROUND(sale_price * v_platform_royalty_rate + v_price_increase * 0.10, 2);
    
    total_royalties := venue_royalty + artist_royalty + platform_royalty;
    seller_proceeds := sale_price - total_royalties;
    
    RETURN NEXT;
END;
$$;



--
-- Name: FUNCTION calculate_royalties(sale_price numeric, original_price numeric, venue_id uuid, artist_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.calculate_royalties(sale_price numeric, original_price numeric, venue_id uuid, artist_id uuid) IS 'Calculates royalty distribution for secondary market sales';


--
-- Name: calculate_schedule_hours(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_schedule_hours() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    
    -- Calculate hours worked if actual times are provided
    IF NEW.actual_start_time IS NOT NULL AND NEW.actual_end_time IS NOT NULL THEN
        NEW.hours_worked = EXTRACT(EPOCH FROM (NEW.actual_end_time - NEW.actual_start_time)) / 3600.0;
        
        -- Calculate overtime (over 8 hours per day)
        IF NEW.hours_worked > 8 THEN
            NEW.overtime_hours = NEW.hours_worked - 8;
        ELSE
            NEW.overtime_hours = 0;
        END IF;
        
        -- Update staff totals
        UPDATE venue_staff 
        SET total_hours_worked = total_hours_worked + NEW.hours_worked,
            total_shifts_completed = total_shifts_completed + 1,
            last_shift_date = NEW.schedule_date
        WHERE id = NEW.venue_staff_id;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: calculate_session_duration(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_session_duration() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    
    -- Calculate duration from start and end times
    IF NEW.start_time IS NOT NULL AND NEW.end_time IS NOT NULL THEN
        NEW.duration = NEW.end_time - NEW.start_time;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: calculate_ticket_price(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_ticket_price(pricing_id uuid) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
   pricing RECORD;
   total NUMERIC;
BEGIN
   SELECT * INTO pricing FROM public.event_pricing WHERE id = pricing_id;
   
   IF pricing.is_dynamic AND pricing.current_price IS NOT NULL THEN
       total := pricing.current_price;
   ELSE
       total := pricing.base_price;
   END IF;
   
   total := total + COALESCE(pricing.service_fee, 0) + COALESCE(pricing.facility_fee, 0);
   total := total * (1 + COALESCE(pricing.tax_rate, 0));
   
   RETURN ROUND(total, 2);
END;
$$;



--
-- Name: calculate_ticket_price(uuid, integer, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_ticket_price(p_ticket_type_id uuid, p_quantity integer DEFAULT 1, p_promo_code character varying DEFAULT NULL::character varying) RETURNS TABLE(base_price numeric, fees numeric, taxes numeric, discount numeric, total_price numeric, price_breakdown jsonb)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_ticket_type RECORD;
    v_base_total DECIMAL(10,2);
    v_fees DECIMAL(10,2) := 0;
    v_taxes DECIMAL(10,2) := 0;
    v_discount DECIMAL(10,2) := 0;
    v_breakdown JSONB := '{}'::JSONB;
BEGIN
    -- Get ticket type
    SELECT * INTO v_ticket_type
    FROM ticket_types
    WHERE id = p_ticket_type_id;
    
    IF NOT FOUND THEN
        RETURN;
    END IF;
    
    v_base_total := v_ticket_type.base_price * p_quantity;
    
    -- Calculate fees
    v_fees := (COALESCE(v_ticket_type.service_fee, 0) + 
               COALESCE(v_ticket_type.processing_fee, 0) + 
               COALESCE(v_ticket_type.facility_fee, 0)) * p_quantity;
    
    -- Calculate taxes
    v_taxes := v_base_total * COALESCE(v_ticket_type.tax_rate, 0);
    
    -- Apply group pricing if applicable
    IF v_ticket_type.group_pricing IS NOT NULL AND p_quantity > 1 THEN
        -- Group pricing logic would go here
        -- This is a simplified version
        IF p_quantity >= 10 THEN
            v_discount := v_base_total * 0.1; -- 10% group discount
        END IF;
    END IF;
    
    -- Apply promo code if provided
    IF p_promo_code IS NOT NULL THEN
        -- Promo code logic would integrate with event_pricing_promo_codes table
        -- For now, just a placeholder
        NULL;
    END IF;
    
    -- Build breakdown
    v_breakdown := jsonb_build_object(
        'base_price_per_ticket', v_ticket_type.base_price,
        'quantity', p_quantity,
        'base_total', v_base_total,
        'service_fee', v_ticket_type.service_fee * p_quantity,
        'processing_fee', v_ticket_type.processing_fee * p_quantity,
        'facility_fee', v_ticket_type.facility_fee * p_quantity,
        'tax_rate', v_ticket_type.tax_rate,
        'group_discount', v_discount,
        'promo_discount', 0
    );
    
    RETURN QUERY SELECT 
        v_base_total,
        v_fees,
        v_taxes,
        v_discount,
        v_base_total + v_fees + v_taxes - v_discount,
        v_breakdown;
END;
$$;



--
-- Name: calculate_transaction_fees(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_transaction_fees() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Calculate platform fee (2.5%)
    NEW.platform_fee := ROUND(NEW.amount * 0.025, 2);
    
    -- Calculate total with fees
    NEW.total_amount := NEW.amount + COALESCE(NEW.platform_fee, 0);
    
    RETURN NEW;
END;
$$;



--
-- Name: calculate_transaction_fees(bigint, character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_transaction_fees(amount bigint, payment_type character varying, provider character varying) RETURNS TABLE(platform_fee bigint, processor_fee bigint, total_fee bigint)
    LANGUAGE plpgsql
    AS $$
DECLARE
   platform_rate NUMERIC;
   processor_rate NUMERIC;
BEGIN
   -- Platform fee rates
   platform_rate := CASE payment_type
       WHEN 'credit_card' THEN 0.015  -- 1.5%
       WHEN 'crypto' THEN 0.01        -- 1%
       ELSE 0.02                      -- 2%
   END;
   
   -- Processor fee rates
   processor_rate := CASE provider
       WHEN 'stripe' THEN 0.029       -- 2.9%
       WHEN 'coinbase' THEN 0.01      -- 1%
       ELSE 0.025                     -- 2.5%
   END;
   
   platform_fee := ROUND(amount * platform_rate);
   processor_fee := ROUND(amount * processor_rate);
   total_fee := platform_fee + processor_fee;
   
   RETURN QUERY SELECT platform_fee, processor_fee, total_fee;
END;
$$;



--
-- Name: calculate_venue_metrics(uuid, date, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_venue_metrics(p_venue_id uuid, p_start_date date DEFAULT (CURRENT_DATE - '30 days'::interval), p_end_date date DEFAULT CURRENT_DATE) RETURNS TABLE(total_events integer, total_tickets_sold integer, total_revenue numeric, avg_ticket_price numeric, capacity_utilization numeric, customer_retention_rate numeric, top_event_category character varying, busiest_day_of_week integer, growth_rate numeric)
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    v_previous_period_revenue NUMERIC;
BEGIN
    -- Main metrics
    SELECT 
        COUNT(DISTINCT e.id),
        COUNT(DISTINCT t.id),
        COALESCE(SUM(tr.amount), 0),
        AVG(tr.amount),
        AVG(CASE WHEN 
      (SELECT COALESCE(SUM(tt.total_supply),0) FROM public.ticket_types tt WHERE tt.event_id = e.id)
 > 0 
            THEN (COUNT(t.id) FILTER (WHERE t.status NOT IN ('CANCELLED', 'REFUNDED'))::NUMERIC / 
      (SELECT COALESCE(SUM(tt.total_supply),0) FROM public.ticket_types tt WHERE tt.event_id = e.id)
) * 100 
            ELSE 0 END),
        0.0, -- Placeholder for retention rate
        MODE() WITHIN GROUP (ORDER BY e.category),
        MODE() WITHIN GROUP (ORDER BY EXTRACT(DOW FROM e.start_date)),
        0.0 -- Placeholder for growth rate
    INTO 
        total_events,
        total_tickets_sold,
        total_revenue,
        avg_ticket_price,
        capacity_utilization,
        customer_retention_rate,
        top_event_category,
        busiest_day_of_week,
        growth_rate
    FROM events e
    LEFT JOIN tickets t ON t.event_id = e.id
    LEFT JOIN ticket_transactions tr ON tr.ticket_id = t.id AND tr.status = 'COMPLETED'
    WHERE e.venue_id = p_venue_id
    AND e.start_date >= p_start_date
    AND e.start_date <= p_end_date
    GROUP BY e.venue_id;
    
    -- Calculate growth rate
    SELECT COALESCE(SUM(tr.amount), 0)
    INTO v_previous_period_revenue
    FROM events e
    JOIN tickets t ON t.event_id = e.id
    JOIN ticket_transactions tr ON tr.ticket_id = t.id AND tr.status = 'COMPLETED'
    WHERE e.venue_id = p_venue_id
    AND e.start_date >= p_start_date - (p_end_date - p_start_date)
    AND e.start_date < p_start_date;
    
    IF v_previous_period_revenue > 0 THEN
        growth_rate := ((total_revenue - v_previous_period_revenue) / v_previous_period_revenue) * 100;
    END IF;
    
    RETURN NEXT;
END;
$$;



--
-- Name: FUNCTION calculate_venue_metrics(p_venue_id uuid, p_start_date date, p_end_date date); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.calculate_venue_metrics(p_venue_id uuid, p_start_date date, p_end_date date) IS 'Calculates comprehensive venue performance metrics';


--
-- Name: can_oversell(uuid, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.can_oversell(p_event_capacity_id uuid, p_quantity integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_current_sold INTEGER;
    v_total_capacity INTEGER;
    v_oversell_limit INTEGER;
    v_oversell_enabled BOOLEAN;
BEGIN
    SELECT sold_capacity, total_capacity, oversell_limit, oversell_enabled
    INTO v_current_sold, v_total_capacity, v_oversell_limit, v_oversell_enabled
    FROM event_capacity
    WHERE id = p_event_capacity_id;
    
    IF NOT v_oversell_enabled THEN
        RETURN (v_current_sold + p_quantity) <= v_total_capacity;
    END IF;
    
    RETURN (v_current_sold + p_quantity) <= (v_total_capacity + v_oversell_limit);
END;
$$;



--
-- Name: check_auto_approval(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_auto_approval() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Auto-approve event cancellations
    IF NEW.refund_reason = 'event_cancelled' THEN
        NEW.auto_approved = TRUE;
        NEW.status = 'approved';
        NEW.approved_at = CURRENT_TIMESTAMP;
        NEW.terms_accepted = TRUE;
        NEW.terms_accepted_at = CURRENT_TIMESTAMP;
    END IF;
    
    -- Auto-approve technical errors
    IF NEW.refund_reason = 'technical_error' THEN
        NEW.auto_approved = TRUE;
        NEW.status = 'approved';
        NEW.approved_at = CURRENT_TIMESTAMP;
        NEW.terms_accepted = TRUE;
        NEW.terms_accepted_at = CURRENT_TIMESTAMP;
    END IF;
    
    -- Set deadline compliance
    IF NEW.refund_deadline IS NOT NULL THEN
        NEW.deadline_compliance = (CURRENT_TIMESTAMP <= NEW.refund_deadline);
    END IF;
    
    -- Require documentation for certain reasons
    IF NEW.refund_reason IN ('medical_emergency', 'fraud') THEN
        NEW.documentation_required = TRUE;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: check_capacity(uuid, uuid, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_capacity(p_event_id uuid, p_ticket_type_id uuid, p_quantity integer DEFAULT 1) RETURNS TABLE(available boolean, current_sold integer, max_capacity integer, available_count integer)
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    v_current_sold INTEGER;
    v_max_capacity INTEGER;
BEGIN
    -- Get current sold count and capacity
    SELECT 
        COUNT(t.id) FILTER (WHERE t.status NOT IN ('CANCELLED', 'REFUNDED')),
        COALESCE(tt.capacity, 
      (SELECT COALESCE(SUM(tt.total_supply),0) FROM public.ticket_types tt WHERE tt.event_id = e.id)
)
    INTO v_current_sold, v_max_capacity
    FROM events e
    LEFT JOIN ticket_types tt ON tt.id = p_ticket_type_id AND tt.event_id = e.id
    LEFT JOIN tickets t ON t.event_id = e.id 
        AND (p_ticket_type_id IS NULL OR t.ticket_type_id = p_ticket_type_id)
    WHERE e.id = p_event_id
    GROUP BY e.id, tt.capacity, 
      (SELECT COALESCE(SUM(tt.total_supply),0) FROM public.ticket_types tt WHERE tt.event_id = e.id)
;
    
    -- Calculate availability
    available_count := GREATEST(0, v_max_capacity - v_current_sold);
    available := available_count >= p_quantity;
    current_sold := v_current_sold;
    max_capacity := v_max_capacity;
    
    RETURN NEXT;
END;
$$;



--
-- Name: FUNCTION check_capacity(p_event_id uuid, p_ticket_type_id uuid, p_quantity integer); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.check_capacity(p_event_id uuid, p_ticket_type_id uuid, p_quantity integer) IS 'Checks if tickets are available for an event';


--
-- Name: check_capacity_thresholds(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_capacity_thresholds(p_event_capacity_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_utilization DECIMAL(5,2);
    v_available INTEGER;
    v_event_id UUID;
BEGIN
    SELECT ec.available_capacity, ec.event_id, get_capacity_utilization(ec.id)
    INTO v_available, v_event_id, v_utilization
    FROM event_capacity ec
    WHERE ec.id = p_event_capacity_id;
    
    -- Critical: Less than 5% capacity remaining
    IF v_utilization >= 95 AND v_available > 0 THEN
        INSERT INTO event_capacity_alerts (event_capacity_id, alert_type, current_value, alert_level, message)
        VALUES (p_event_capacity_id, 'LOW_CAPACITY', v_utilization, 'CRITICAL', 
                'Critical: Only ' || v_available || ' tickets remaining (' || v_utilization || '% sold)');
    END IF;
    
    -- Warning: Less than 10% capacity remaining
    IF v_utilization >= 90 AND v_utilization < 95 THEN
        INSERT INTO event_capacity_alerts (event_capacity_id, alert_type, current_value, alert_level, message)
        VALUES (p_event_capacity_id, 'LOW_CAPACITY', v_utilization, 'WARNING',
                'Warning: Only ' || v_available || ' tickets remaining (' || v_utilization || '% sold)');
    END IF;
    
    -- Oversold situation
    IF v_available < 0 THEN
        INSERT INTO event_capacity_alerts (event_capacity_id, alert_type, current_value, alert_level, message)
        VALUES (p_event_capacity_id, 'OVERSOLD', v_utilization, 'CRITICAL',
                'OVERSOLD: Event is oversold by ' || ABS(v_available) || ' tickets');
    END IF;
END;
$$;



--
-- Name: check_certification_expiry(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_certification_expiry() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    
    -- Check if certification is expiring soon and send alert
    IF NEW.expiry_date IS NOT NULL AND NEW.renewal_reminder_sent = FALSE THEN
        IF NEW.expiry_date <= CURRENT_DATE + INTERVAL '1 day' * NEW.renewal_notice_days THEN
            NEW.renewal_reminder_sent = TRUE;
            
            -- Here you would trigger a notification system
            -- For now, we'll just mark the reminder as sent
        END IF;
    END IF;
    
    -- Mark certification as inactive if expired
    IF NEW.expiry_date IS NOT NULL AND NEW.expiry_date < CURRENT_DATE THEN
        NEW.is_active = FALSE;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: check_event_availability(uuid, uuid, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_event_availability(p_event_id uuid, p_schedule_id uuid DEFAULT NULL::uuid, p_quantity integer DEFAULT 1) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
   available INTEGER;
BEGIN
   SELECT SUM(available_capacity) INTO available
   FROM public.event_capacity
   WHERE event_id = p_event_id
       AND (p_schedule_id IS NULL OR schedule_id = p_schedule_id)
       AND is_active = TRUE;
   
   RETURN COALESCE(available, 0) >= p_quantity;
END;
$$;



--
-- Name: check_fraud_rules(uuid, numeric, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_fraud_rules(p_user_id uuid, p_listing_price numeric, p_ticket_id uuid) RETURNS TABLE(rule_violated boolean, rule_name character varying, severity character varying, action character varying)
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_rule RECORD;
  v_user_age INTEGER;
  v_listings_last_hour INTEGER;
BEGIN
  -- Get user metrics
  SELECT EXTRACT(DAY FROM CURRENT_TIMESTAMP - created_at)
  INTO v_user_age
  FROM public.users WHERE id = p_user_id;

  SELECT COUNT(*)
  INTO v_listings_last_hour
  FROM public.listings
  WHERE seller_id = p_user_id
  AND created_at >= CURRENT_TIMESTAMP - INTERVAL '1 hour';

  -- Check each active rule
  FOR v_rule IN 
      SELECT * FROM public.fraud_prevention_rules
      WHERE is_active = TRUE
  LOOP
      -- Check velocity rules
      IF v_rule.rule_type = 'VELOCITY' AND 
         v_listings_last_hour > (v_rule.conditions->>'max_listings_per_hour')::INTEGER THEN
          RETURN QUERY SELECT TRUE, v_rule.rule_name, v_rule.severity, v_rule.action;
      END IF;

      -- Check user age rules
      IF v_rule.rule_type = 'USER_BEHAVIOR' AND
         v_user_age < (v_rule.conditions->>'min_user_age_days')::INTEGER THEN
          RETURN QUERY SELECT TRUE, v_rule.rule_name, v_rule.severity, v_rule.action;
      END IF;
  END LOOP;

  -- No rules violated
  IF NOT FOUND THEN
      RETURN QUERY SELECT FALSE, NULL::VARCHAR, NULL::VARCHAR, NULL::VARCHAR;
  END IF;
END;
$$;



--
-- Name: check_refund_auto_approval(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_refund_auto_approval() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
BEGIN
    -- Auto-approve if all conditions are met
    IF NEW.status = 'requested' AND NOT NEW.approval_required THEN
        -- Event cancellation auto-approval
        IF NEW.refund_reason = 'event_cancelled' THEN
            NEW.status = 'approved';
            NEW.auto_approved = TRUE;
            NEW.approval_rules_applied = NEW.approval_rules_applied || 
                jsonb_build_array(jsonb_build_object('rule', 'event_cancelled_auto_approval', 'timestamp', CURRENT_TIMESTAMP));
        
        -- Technical error auto-approval
        ELSIF NEW.refund_reason IN ('technical_error', 'payment_error', 'pricing_error') THEN
            NEW.status = 'approved';
            NEW.auto_approved = TRUE;
            NEW.approval_rules_applied = NEW.approval_rules_applied || 
                jsonb_build_array(jsonb_build_object('rule', 'platform_error_auto_approval', 'timestamp', CURRENT_TIMESTAMP));
        
        -- Small amount auto-approval (under $10)
        ELSIF NEW.refund_amount <= 10.00 AND NEW.within_policy_period THEN
            NEW.status = 'approved';
            NEW.auto_approved = TRUE;
            NEW.approval_rules_applied = NEW.approval_rules_applied || 
                jsonb_build_array(jsonb_build_object('rule', 'small_amount_auto_approval', 'timestamp', CURRENT_TIMESTAMP));
        END IF;
    END IF;
    
    RETURN NEW;
END;
$_$;



--
-- Name: check_reservation_expiry(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_reservation_expiry() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Mark expired reservations
    UPDATE reservations
    SET status = 'EXPIRED',
        updated_at = CURRENT_TIMESTAMP
    WHERE status = 'ACTIVE'
    AND expires_at <= CURRENT_TIMESTAMP;
    
    -- Update related orders
    UPDATE orders
    SET status = 'EXPIRED',
        updated_at = CURRENT_TIMESTAMP
    WHERE status = 'RESERVED'
    AND expires_at <= CURRENT_TIMESTAMP;
END;
$$;



--
-- Name: check_schedule_conflicts(uuid, timestamp with time zone, timestamp with time zone, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_schedule_conflicts(p_venue_id uuid, p_start_datetime timestamp with time zone, p_end_datetime timestamp with time zone, p_exclude_schedule_id uuid DEFAULT NULL::uuid) RETURNS TABLE(conflicting_schedule_id uuid, event_name character varying, conflict_start timestamp with time zone, conflict_end timestamp with time zone, overlap_hours numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT es.id, e.event_name,
           GREATEST(p_start_datetime, es.start_datetime) as conflict_start,
           LEAST(p_end_datetime, COALESCE(es.end_datetime, es.start_datetime + INTERVAL '4 hours')) as conflict_end,
           EXTRACT(EPOCH FROM (
               LEAST(p_end_datetime, COALESCE(es.end_datetime, es.start_datetime + INTERVAL '4 hours')) -
               GREATEST(p_start_datetime, es.start_datetime)
           )) / 3600.0 as overlap_hours
    FROM event_schedules es
    JOIN events e ON es.event_id = e.id
    WHERE es.venue_id = p_venue_id
    AND es.schedule_status NOT IN ('cancelled', 'completed')
    AND (p_exclude_schedule_id IS NULL OR es.id != p_exclude_schedule_id)
    AND (
        (es.start_datetime <= p_start_datetime AND COALESCE(es.end_datetime, es.start_datetime + INTERVAL '4 hours') > p_start_datetime) OR
        (es.start_datetime < p_end_datetime AND es.start_datetime >= p_start_datetime)
    )
    ORDER BY es.start_datetime;
END;
$$;



--
-- Name: check_surge_pricing_triggers(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_surge_pricing_triggers(p_event_pricing_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_threshold RECORD;
    v_capacity_util DECIMAL(5,2);
    v_sales_velocity DECIMAL(8,2);
    v_hours_to_event INTEGER;
    v_should_trigger BOOLEAN;
BEGIN
    -- Get current metrics (would need actual implementation)
    v_capacity_util := 75.0; -- Placeholder
    v_sales_velocity := 50.0; -- Placeholder
    v_hours_to_event := 48; -- Placeholder
    
    FOR v_threshold IN 
        SELECT * FROM event_pricing_surge_thresholds
        WHERE event_pricing_id = p_event_pricing_id AND is_active = true
    LOOP
        v_should_trigger := false;
        
        -- Check capacity threshold
        IF v_threshold.capacity_threshold_percentage IS NOT NULL AND 
           v_capacity_util >= v_threshold.capacity_threshold_percentage THEN
            v_should_trigger := true;
        END IF;
        
        -- Check time threshold
        IF v_threshold.time_threshold_hours IS NOT NULL AND 
           v_hours_to_event <= v_threshold.time_threshold_hours THEN
            v_should_trigger := true;
        END IF;
        
        -- Check velocity threshold
        IF v_threshold.velocity_threshold_per_hour IS NOT NULL AND 
           v_sales_velocity >= v_threshold.velocity_threshold_per_hour THEN
            v_should_trigger := true;
        END IF;
        
        -- Apply surge pricing if conditions met
        IF v_should_trigger AND 
           (v_threshold.last_triggered IS NULL OR 
            v_threshold.last_triggered + v_threshold.cooldown_period <= CURRENT_TIMESTAMP) THEN
            
            UPDATE event_pricing_surge_thresholds
            SET last_triggered = CURRENT_TIMESTAMP,
                trigger_count = trigger_count + 1
            WHERE id = v_threshold.id;
            
            -- Log surge pricing activation
            INSERT INTO event_pricing_history (
                event_pricing_id, change_type, new_price, reason, triggered_by
            ) VALUES (
                p_event_pricing_id, 'SURGE_APPLIED', 0, 
                'Surge pricing activated: ' || v_threshold.threshold_name,
                v_threshold.threshold_name
            );
        END IF;
    END LOOP;
END;
$$;



--
-- Name: check_ticket_availability(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_ticket_availability() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_current_supply integer;
  v_max_supply     integer;
BEGIN
  SELECT current_supply, total_supply
    INTO v_current_supply, v_max_supply
  FROM public.ticket_types
  WHERE id = NEW.ticket_type_id;

  IF v_current_supply IS NULL OR v_max_supply IS NULL THEN
    RAISE EXCEPTION 'Unknown ticket_type %', NEW.ticket_type_id;
  END IF;

  IF v_current_supply >= v_max_supply THEN
    RAISE EXCEPTION 'No tickets available for this ticket type';
  END IF;

  RETURN NEW;
END
$$;



--
-- Name: check_ticket_availability(uuid, integer, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_ticket_availability(p_ticket_type_id uuid, p_quantity integer DEFAULT 1, p_customer_id uuid DEFAULT NULL::uuid) RETURNS TABLE(is_available boolean, available_quantity integer, error_message text, restrictions_failed text[])
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_ticket_type RECORD;
    v_customer_purchased INTEGER := 0;
    v_restrictions_failed TEXT[] := ARRAY[]::TEXT[];
    v_restriction RECORD;
    v_current_time TIMESTAMP WITH TIME ZONE := CURRENT_TIMESTAMP;
BEGIN
    -- Get ticket type info
    SELECT * INTO v_ticket_type
    FROM ticket_types
    WHERE id = p_ticket_type_id;
    
    IF NOT FOUND THEN
        RETURN QUERY SELECT false, 0, 'Ticket type not found', ARRAY['TICKET_TYPE_NOT_FOUND'];
        RETURN;
    END IF;
    
    -- Check if ticket type is active
    IF v_ticket_type.status != 'ACTIVE' THEN
        RETURN QUERY SELECT false, v_ticket_type.available_quantity, 'Ticket type not available', ARRAY['STATUS_' || v_ticket_type.status];
        RETURN;
    END IF;
    
    -- Check sale dates
    IF v_ticket_type.sale_start_date IS NOT NULL AND v_current_time < v_ticket_type.sale_start_date THEN
        v_restrictions_failed := array_append(v_restrictions_failed, 'SALE_NOT_STARTED');
    END IF;
    
    IF v_ticket_type.sale_end_date IS NOT NULL AND v_current_time > v_ticket_type.sale_end_date THEN
        v_restrictions_failed := array_append(v_restrictions_failed, 'SALE_ENDED');
    END IF;
    
    -- Check quantity limits
    IF p_quantity < v_ticket_type.min_purchase_quantity THEN
        v_restrictions_failed := array_append(v_restrictions_failed, 'BELOW_MIN_QUANTITY');
    END IF;
    
    IF p_quantity > v_ticket_type.max_purchase_quantity THEN
        v_restrictions_failed := array_append(v_restrictions_failed, 'ABOVE_MAX_QUANTITY');
    END IF;
    
    -- Check available quantity
    IF p_quantity > v_ticket_type.available_quantity THEN
        v_restrictions_failed := array_append(v_restrictions_failed, 'INSUFFICIENT_QUANTITY');
    END IF;
    
    -- Check customer limits if customer provided
    IF p_customer_id IS NOT NULL AND v_ticket_type.max_per_customer IS NOT NULL THEN
        SELECT COALESCE(SUM(quantity), 0) INTO v_customer_purchased
        FROM tickets
        WHERE ticket_type_id = p_ticket_type_id 
          AND customer_id = p_customer_id 
          AND status NOT IN ('CANCELLED', 'REFUNDED');
        
        IF v_customer_purchased + p_quantity > v_ticket_type.max_per_customer THEN
            v_restrictions_failed := array_append(v_restrictions_failed, 'CUSTOMER_LIMIT_EXCEEDED');
        END IF;
    END IF;
    
    -- Check additional restrictions
    FOR v_restriction IN 
        SELECT * FROM ticket_type_restrictions 
        WHERE ticket_type_id = p_ticket_type_id AND is_active = true
    LOOP
        -- This would implement actual restriction checking logic
        -- For now, we'll just log that restrictions exist
        -- In a real implementation, you'd parse restriction_rule JSON and evaluate
        IF v_restriction.restriction_type = 'AGE' THEN
            -- Age restriction checking logic would go here
            NULL;
        END IF;
    END LOOP;
    
    RETURN QUERY SELECT 
        array_length(v_restrictions_failed, 1) = 0 OR v_restrictions_failed IS NULL,
        v_ticket_type.available_quantity,
        CASE 
            WHEN array_length(v_restrictions_failed, 1) > 0 THEN 'Ticket purchase restrictions failed'
            ELSE NULL
        END,
        COALESCE(v_restrictions_failed, ARRAY[]::TEXT[]);
END;
$$;



--
-- Name: cleanup_expired_sessions(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.cleanup_expired_sessions() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    cleanup_count INTEGER := 0;
BEGIN
    -- Mark expired sessions
    UPDATE sessions
    SET session_status = 'expired'
    WHERE session_status = 'active'
    AND expires_at <= NOW();
    
    GET DIAGNOSTICS cleanup_count = ROW_COUNT;
    
    -- Delete old session activities (older than 90 days)
    DELETE FROM session_activities
    WHERE timestamp < NOW() - INTERVAL '90 days';
    
    -- Delete old expired sessions (older than 30 days)
    DELETE FROM sessions
    WHERE session_status IN ('expired', 'revoked')
    AND created_at < NOW() - INTERVAL '30 days';
    
    RETURN cleanup_count;
END;
$$;



--
-- Name: cleanup_old_integration_logs(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.cleanup_old_integration_logs() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Delete logs older than 90 days for performance
    DELETE FROM integration_logs
    WHERE created_at < NOW() - INTERVAL '90 days'
    AND log_level NOT IN ('error', 'fatal'); -- Keep error logs longer
    
    -- Delete error logs older than 1 year
    DELETE FROM integration_logs
    WHERE created_at < NOW() - INTERVAL '1 year'
    AND log_level IN ('error', 'fatal');
    
    RETURN NEW;
END;
$$;



--
-- Name: copy_layout_from_template(uuid, uuid, character varying, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.copy_layout_from_template(p_target_venue_id uuid, p_template_layout_id uuid, p_new_layout_name character varying, p_created_by_user_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_layout_id UUID;
    template_layout RECORD;
    section_record RECORD;
    new_section_id UUID;
    seat_count INTEGER;
BEGIN
    -- Get template layout
    SELECT * INTO template_layout
    FROM venue_layouts
    WHERE id = p_template_layout_id;
    
    -- Create new layout
    INSERT INTO venue_layouts (
        venue_id, layout_name, layout_description, total_capacity,
        seated_capacity, standing_capacity, wheelchair_capacity,
        companion_capacity, vip_capacity, layout_width, layout_height,
        scale_factor, coordinate_system, stage_width, stage_depth,
        stage_height, stage_position, sightline_data, viewing_angles,
        acoustic_zones, pricing_zones, default_pricing_tier,
        created_by_user_id
    )
    VALUES (
        p_target_venue_id, p_new_layout_name, template_layout.layout_description,
        template_layout.total_capacity, template_layout.seated_capacity,
        template_layout.standing_capacity, template_layout.wheelchair_capacity,
        template_layout.companion_capacity, template_layout.vip_capacity,
        template_layout.layout_width, template_layout.layout_height,
        template_layout.scale_factor, template_layout.coordinate_system,
        template_layout.stage_width, template_layout.stage_depth,
        template_layout.stage_height, template_layout.stage_position,
        template_layout.sightline_data, template_layout.viewing_angles,
        template_layout.acoustic_zones, template_layout.pricing_zones,
        template_layout.default_pricing_tier, p_created_by_user_id
    )
    RETURNING id INTO new_layout_id;
    
    -- Copy sections
    FOR section_record IN
        SELECT * FROM layout_sections WHERE layout_id = p_template_layout_id
    LOOP
        SELECT add_layout_section(
            new_layout_id,
            section_record.section_name,
            section_record.section_code,
            section_record.section_type,
            section_record.section_capacity,
            section_record.pricing_tier,
            section_record.wheelchair_seats,
            section_record.companion_seats
        ) INTO new_section_id;
        
        -- Copy seats for this section
        INSERT INTO layout_seats (
            section_id, layout_id, venue_id, seat_number, row_identifier,
            seat_type, is_accessible, is_companion, seat_position,
            pricing_tier, base_price
        )
        SELECT new_section_id, new_layout_id, p_target_venue_id,
               seat_number, row_identifier, seat_type, is_accessible,
               is_companion, seat_position, pricing_tier, base_price
        FROM layout_seats
        WHERE section_id = section_record.id;
    END LOOP;
    
    RETURN new_layout_id;
END;
$$;



--
-- Name: copy_venue_settings_from_template(uuid, uuid, public.setting_category[], uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.copy_venue_settings_from_template(p_target_venue_id uuid, p_template_venue_id uuid, p_categories public.setting_category[] DEFAULT NULL::public.setting_category[], p_created_by_user_id uuid DEFAULT NULL::uuid) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    copied_count INTEGER := 0;
    setting_record RECORD;
BEGIN
    FOR setting_record IN
        SELECT vs.*
        FROM venue_settings vs
        WHERE vs.venue_id = p_template_venue_id
        AND vs.is_active = TRUE
        AND (p_categories IS NULL OR vs.category = ANY(p_categories))
        AND NOT vs.is_readonly  -- Don't copy readonly settings
    LOOP
        INSERT INTO venue_settings (
            venue_id, setting_key, setting_name, setting_description,
            category, subcategory, setting_group, setting_value,
            setting_value_json, data_type, is_required, validation_rules,
            allowed_values, min_value, max_value, default_value,
            display_order, is_visible, created_by_user_id
        )
        VALUES (
            p_target_venue_id, setting_record.setting_key, setting_record.setting_name,
            setting_record.setting_description, setting_record.category,
            setting_record.subcategory, setting_record.setting_group,
            setting_record.setting_value, setting_record.setting_value_json,
            setting_record.data_type, setting_record.is_required,
            setting_record.validation_rules, setting_record.allowed_values,
            setting_record.min_value, setting_record.max_value,
            setting_record.default_value, setting_record.display_order,
            setting_record.is_visible, p_created_by_user_id
        )
        ON CONFLICT (venue_id, setting_key, is_active) DO NOTHING;
        
        copied_count := copied_count + 1;
    END LOOP;
    
    RETURN copied_count;
END;
$$;



--
-- Name: create_capacity_snapshot(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_capacity_snapshot(p_event_capacity_id uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_snapshot_id UUID;
    v_capacity_record RECORD;
    v_utilization DECIMAL(5,2);
BEGIN
    SELECT * INTO v_capacity_record
    FROM event_capacity
    WHERE id = p_event_capacity_id;
    
    v_utilization := get_capacity_utilization(p_event_capacity_id);
    
    INSERT INTO event_capacity_snapshots (
        event_capacity_id, total_capacity, sold_capacity, 
        available_capacity, hold_capacity, reserved_capacity,
        utilization_percentage
    ) VALUES (
        p_event_capacity_id, v_capacity_record.total_capacity,
        v_capacity_record.sold_capacity, v_capacity_record.available_capacity,
        v_capacity_record.hold_capacity, v_capacity_record.reserved_capacity,
        v_utilization
    ) RETURNING id INTO v_snapshot_id;
    
    RETURN v_snapshot_id;
END;
$$;



--
-- Name: create_compliance_reminders(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_compliance_reminders() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    reminder_dates INTEGER[] := ARRAY[90, 60, 30, 14, 7, 1]; -- Days before expiry
    reminder_day INTEGER;
    reminder_date DATE;
BEGIN
    -- Only create reminders for new compliances with expiry dates
    IF TG_OP = 'INSERT' AND NEW.expiry_date IS NOT NULL AND NEW.monitoring_enabled = TRUE THEN
        FOREACH reminder_day IN ARRAY reminder_dates LOOP
            reminder_date := NEW.expiry_date - INTERVAL '1 day' * reminder_day;
            
            -- Only create reminders for future dates
            IF reminder_date >= CURRENT_DATE THEN
                INSERT INTO compliance_reminders (
                    compliance_id, venue_id, reminder_type, reminder_title,
                    reminder_message, reminder_date, days_before_expiry,
                    is_urgent
                )
                VALUES (
                    NEW.id, NEW.venue_id, 'renewal_reminder',
                    NEW.compliance_name || ' - Renewal Reminder',
                    'Your ' || NEW.compliance_name || ' expires on ' || NEW.expiry_date || '. Please begin renewal process.',
                    reminder_date, reminder_day,
                    reminder_day <= 7
                );
            END IF;
        END LOOP;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: create_default_preferences(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_default_preferences() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO customer_preferences (customer_profile_id)
    VALUES (NEW.id)
    ON CONFLICT (customer_profile_id) DO NOTHING;
    RETURN NEW;
END;
$$;



--
-- Name: create_default_venue_settings(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_default_venue_settings() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO public.venue_settings (venue_id)
    VALUES (NEW.id)
    ON CONFLICT (venue_id) DO NOTHING;
    RETURN NEW;
END;
$$;



--
-- Name: create_escrow_hold(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_escrow_hold() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Create escrow for new marketplace transactions
  INSERT INTO public.escrow (
      marketplace_transaction_id, buyer_id, seller_id,
      amount, currency, auto_release_at
  ) VALUES (
      NEW.id, NEW.buyer_id, NEW.seller_id,
      NEW.sale_price, NEW.currency,
      CURRENT_TIMESTAMP + INTERVAL '72 hours'
  );
  
  RETURN NEW;
END;
$$;



--
-- Name: create_event(uuid, character varying, public.event_category, date, time without time zone, text, character varying, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_event(p_venue_id uuid, p_event_name character varying, p_event_category public.event_category, p_event_date date, p_event_time time without time zone DEFAULT NULL::time without time zone, p_short_description text DEFAULT NULL::text, p_organizer_name character varying DEFAULT NULL::character varying, p_created_by_user_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_event_id UUID;
BEGIN
    INSERT INTO events (
        venue_id, event_name, event_category, event_date, event_time,
        short_description, organizer_name, created_by_user_id
    )
    VALUES (
        p_venue_id, p_event_name, p_event_category, p_event_date, p_event_time,
        p_short_description, p_organizer_name, p_created_by_user_id
    )
    RETURNING id INTO new_event_id;
    
    RETURN new_event_id;
END;
$$;



--
-- Name: create_event_metadata(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_event_metadata() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   INSERT INTO public.event_metadata (event_id)
   VALUES (NEW.id)
   ON CONFLICT (event_id) DO NOTHING;
   RETURN NEW;
END;
$$;



--
-- Name: create_event_schedule(uuid, timestamp with time zone, timestamp with time zone, uuid, public.schedule_type, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_event_schedule(p_event_id uuid, p_start_datetime timestamp with time zone, p_end_datetime timestamp with time zone DEFAULT NULL::timestamp with time zone, p_venue_id uuid DEFAULT NULL::uuid, p_schedule_type public.schedule_type DEFAULT 'single'::public.schedule_type, p_created_by_user_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_schedule_id UUID;
BEGIN
    INSERT INTO event_schedules (
        event_id, start_datetime, end_datetime, venue_id,
        schedule_type, created_by_user_id
    )
    VALUES (
        p_event_id, p_start_datetime, p_end_datetime, p_venue_id,
        p_schedule_type, p_created_by_user_id
    )
    RETURNING id INTO new_schedule_id;
    
    RETURN new_schedule_id;
END;
$$;



--
-- Name: create_initial_ownership(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_initial_ownership() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO ticket_ownership_history (
        ticket_id, owner_user_id, ownership_type,
        is_current_owner, price_paid
    ) VALUES (
        NEW.id, NEW.owner_user_id, 'PURCHASE',
        true, NEW.total_paid
    );
    
    RETURN NEW;
END;
$$;



--
-- Name: create_permission(character varying, character varying, text, public.permission_category, character varying, public.permission_action, public.permission_scope, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_permission(p_permission_name character varying, p_display_name character varying, p_description text, p_category public.permission_category, p_resource character varying, p_action public.permission_action, p_scope public.permission_scope DEFAULT 'global'::public.permission_scope, p_created_by_user_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_permission_id UUID;
BEGIN
    INSERT INTO permissions (
        permission_name, display_name, description, category,
        resource, action, scope, created_by_user_id
    )
    VALUES (
        p_permission_name, p_display_name, p_description, p_category,
        p_resource, p_action, p_scope, p_created_by_user_id
    )
    RETURNING id INTO new_permission_id;
    
    RETURN new_permission_id;
END;
$$;



--
-- Name: create_role(character varying, character varying, text, public.role_permission_level, public.role_category, boolean, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_role(p_role_name character varying, p_display_name character varying, p_description text, p_permission_level public.role_permission_level, p_role_category public.role_category DEFAULT 'custom'::public.role_category, p_is_system_role boolean DEFAULT false, p_created_by_user_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_role_id UUID;
BEGIN
    INSERT INTO roles (
        role_name, display_name, description, permission_level, 
        role_category, is_system_role, created_by_user_id
    )
    VALUES (
        p_role_name, p_display_name, p_description, p_permission_level,
        p_role_category, p_is_system_role, p_created_by_user_id
    )
    RETURNING id INTO new_role_id;
    
    RETURN new_role_id;
END;
$$;



--
-- Name: create_session(uuid, inet, text, character varying, boolean, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_session(p_user_id uuid, p_ip_address inet, p_user_agent text DEFAULT NULL::text, p_device_fingerprint character varying DEFAULT NULL::character varying, p_remember_me boolean DEFAULT false, p_login_method character varying DEFAULT 'password'::character varying) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_session_id UUID;
    session_duration INTERVAL;
    concurrent_count INTEGER;
BEGIN
    -- Check concurrent session limit
    SELECT COUNT(*) INTO concurrent_count
    FROM sessions
    WHERE user_id = p_user_id AND session_status = 'active';
    
    -- Set session duration based on remember_me flag
    session_duration = CASE WHEN p_remember_me THEN INTERVAL '30 days' ELSE INTERVAL '8 hours' END;
    
    -- Create new session
    INSERT INTO sessions (
        user_id, session_token, refresh_token, ip_address,
        user_agent, device_fingerprint, remember_me, login_method,
        expires_at, concurrent_sessions_count
    )
    VALUES (
        p_user_id,
        encode(gen_random_bytes(32), 'hex'),
        encode(gen_random_bytes(32), 'hex'),
        p_ip_address,
        p_user_agent,
        p_device_fingerprint,
        p_remember_me,
        p_login_method,
        NOW() + session_duration,
        concurrent_count + 1
    )
    RETURNING id INTO new_session_id;
    
    -- Log session creation activity
    INSERT INTO session_activities (session_id, activity_type, activity_description, ip_address, user_agent)
    VALUES (new_session_id, 'session_created', 'User session created', p_ip_address, p_user_agent);
    
    RETURN new_session_id;
END;
$$;



--
-- Name: create_staff_schedule(uuid, date, time without time zone, time without time zone, character varying, character varying, uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_staff_schedule(p_venue_staff_id uuid, p_schedule_date date, p_start_time time without time zone, p_end_time time without time zone, p_assigned_position character varying DEFAULT NULL::character varying, p_assigned_area character varying DEFAULT NULL::character varying, p_event_id uuid DEFAULT NULL::uuid, p_created_by_user_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    schedule_id UUID;
    v_venue_id UUID;
BEGIN
    -- Get venue ID from staff record
    SELECT venue_id INTO v_venue_id FROM venue_staff WHERE id = p_venue_staff_id;
    
    INSERT INTO staff_schedules (
        venue_staff_id, venue_id, schedule_date, start_time, end_time,
        assigned_position, assigned_area, event_id, created_by_user_id
    )
    VALUES (
        p_venue_staff_id, v_venue_id, p_schedule_date, p_start_time, p_end_time,
        p_assigned_position, p_assigned_area, p_event_id, p_created_by_user_id
    )
    RETURNING id INTO schedule_id;
    
    RETURN schedule_id;
END;
$$;



--
-- Name: create_ticket_metadata(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_ticket_metadata() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   INSERT INTO public.ticket_metadata (ticket_id)
   VALUES (NEW.id)
   ON CONFLICT (ticket_id) DO NOTHING;


   RETURN NEW;


END;


$$;



--
-- Name: create_ticket_reservation(uuid, uuid, uuid, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_ticket_reservation(p_user_id uuid, p_ticket_type_id uuid, p_event_id uuid, p_quantity integer, p_duration_minutes integer DEFAULT 15) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_reservation_id UUID;
    v_available_count INTEGER;
BEGIN
    -- Check availability
    SELECT available INTO v_available_count
    FROM ticket_types
    WHERE id = p_ticket_type_id
    FOR UPDATE;
    
    IF v_available_count < p_quantity THEN
        RAISE EXCEPTION 'Insufficient tickets available';
    END IF;
    
    -- Create reservation
    INSERT INTO reservations (
        user_id,
        ticket_type_id,
        event_id,
        quantity,
        expires_at,
        status
    ) VALUES (
        p_user_id,
        p_ticket_type_id,
        p_event_id,
        p_quantity,
        CURRENT_TIMESTAMP + (p_duration_minutes || ' minutes')::INTERVAL,
        'ACTIVE'
    ) RETURNING id INTO v_reservation_id;
    
    -- Decrease available count
    UPDATE ticket_types
    SET available = available - p_quantity
    WHERE id = p_ticket_type_id;
    
    RETURN v_reservation_id;
END;
$$;



--
-- Name: create_user(character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_user(p_email character varying, p_username character varying, p_password_hash character varying, p_first_name character varying DEFAULT NULL::character varying, p_last_name character varying DEFAULT NULL::character varying, p_phone character varying DEFAULT NULL::character varying) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_user_id UUID;
BEGIN
    INSERT INTO users (email, username, password_hash, first_name, last_name, phone)
    VALUES (p_email, p_username, p_password_hash, p_first_name, p_last_name, p_phone)
    RETURNING id INTO new_user_id;
    
    RETURN new_user_id;
END;
$$;



--
-- Name: create_venue(character varying, public.venue_type, character varying, character varying, character, uuid, integer, character varying, character varying, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_venue(p_venue_name character varying, p_venue_type public.venue_type, p_address_line_1 character varying, p_city character varying, p_country_code character, p_owner_user_id uuid, p_total_capacity integer DEFAULT NULL::integer, p_primary_phone character varying DEFAULT NULL::character varying, p_primary_email character varying DEFAULT NULL::character varying, p_created_by_user_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_venue_id UUID;
BEGIN
    INSERT INTO venues (
        venue_name, venue_type, address_line_1, city, country_code,
        owner_user_id, total_capacity, primary_phone, primary_email,
        created_by_user_id
    )
    VALUES (
        p_venue_name, p_venue_type, p_address_line_1, p_city, p_country_code,
        p_owner_user_id, p_total_capacity, p_primary_phone, p_primary_email,
        p_created_by_user_id
    )
    RETURNING id INTO new_venue_id;
    
    RETURN new_venue_id;
END;
$$;



--
-- Name: create_venue_compliance(uuid, public.compliance_type, character varying, character varying, character varying, date, date, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_venue_compliance(p_venue_id uuid, p_compliance_type public.compliance_type, p_compliance_name character varying, p_issuing_authority character varying, p_permit_number character varying DEFAULT NULL::character varying, p_issue_date date DEFAULT NULL::date, p_expiry_date date DEFAULT NULL::date, p_created_by_user_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_compliance_id UUID;
BEGIN
    INSERT INTO venue_compliance (
        venue_id, compliance_type, compliance_name, issuing_authority,
        permit_number, issue_date, expiry_date, created_by_user_id
    )
    VALUES (
        p_venue_id, p_compliance_type, p_compliance_name, p_issuing_authority,
        p_permit_number, p_issue_date, p_expiry_date, p_created_by_user_id
    )
    RETURNING id INTO new_compliance_id;
    
    RETURN new_compliance_id;
END;
$$;



--
-- Name: create_venue_integration(uuid, character varying, public.integration_type, character varying, jsonb, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_venue_integration(p_venue_id uuid, p_integration_name character varying, p_integration_type public.integration_type, p_provider_name character varying, p_configuration jsonb DEFAULT '{}'::jsonb, p_created_by_user_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_integration_id UUID;
BEGIN
    INSERT INTO venue_integrations (
        venue_id, integration_name, integration_type, provider_name,
        configuration, created_by_user_id
    )
    VALUES (
        p_venue_id, p_integration_name, p_integration_type, p_provider_name,
        p_configuration, p_created_by_user_id
    )
    RETURNING id INTO new_integration_id;
    
    RETURN new_integration_id;
END;
$$;



--
-- Name: create_venue_layout(uuid, character varying, text, boolean, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_venue_layout(p_venue_id uuid, p_layout_name character varying, p_layout_description text DEFAULT NULL::text, p_is_default boolean DEFAULT false, p_created_by_user_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_layout_id UUID;
BEGIN
    INSERT INTO venue_layouts (
        venue_id, layout_name, layout_description, is_default, created_by_user_id
    )
    VALUES (
        p_venue_id, p_layout_name, p_layout_description, p_is_default, p_created_by_user_id
    )
    RETURNING id INTO new_layout_id;
    
    RETURN new_layout_id;
END;
$$;



--
-- Name: customer_lifetime_value(uuid, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.customer_lifetime_value(p_customer_id uuid, p_include_forecast boolean DEFAULT false) RETURNS TABLE(total_spent numeric, transaction_count integer, avg_transaction_value numeric, days_as_customer integer, purchase_frequency numeric, predicted_ltv numeric, customer_segment character varying)
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    v_first_purchase DATE;
    v_last_purchase DATE;
    v_monthly_spend NUMERIC;
BEGIN
    -- Get customer purchase history
    SELECT 
        COALESCE(SUM(tr.amount), 0),
        COUNT(DISTINCT tr.id),
        AVG(tr.amount),
        MIN(t.created_at)::DATE,
        MAX(t.created_at)::DATE
    INTO 
        total_spent,
        transaction_count,
        avg_transaction_value,
        v_first_purchase,
        v_last_purchase
    FROM tickets t
    JOIN ticket_transactions tr ON tr.ticket_id = t.id AND tr.status = 'COMPLETED'
    WHERE t.owner_id = p_customer_id;
    
    -- Calculate days as customer
    days_as_customer := COALESCE(CURRENT_DATE - v_first_purchase, 0);
    
    -- Calculate purchase frequency (purchases per month)
    IF days_as_customer > 0 THEN
        purchase_frequency := (transaction_count::NUMERIC / days_as_customer) * 30;
    ELSE
        purchase_frequency := 0;
    END IF;
    
    -- Predict future LTV (simple model: monthly spend * expected months)
    IF p_include_forecast AND days_as_customer >= 30 THEN
        v_monthly_spend := total_spent / (days_as_customer / 30.0);
        predicted_ltv := total_spent + (v_monthly_spend * 12); -- Next 12 months
    ELSE
        predicted_ltv := total_spent;
    END IF;
    
    -- Determine customer segment
    CASE 
        WHEN total_spent >= 10000 THEN customer_segment := 'VIP';
        WHEN total_spent >= 5000 THEN customer_segment := 'PREMIUM';
        WHEN total_spent >= 1000 THEN customer_segment := 'REGULAR';
        WHEN total_spent >= 100 THEN customer_segment := 'CASUAL';
        ELSE customer_segment := 'NEW';
    END CASE;
    
    RETURN NEXT;
END;
$$;



--
-- Name: FUNCTION customer_lifetime_value(p_customer_id uuid, p_include_forecast boolean); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.customer_lifetime_value(p_customer_id uuid, p_include_forecast boolean) IS 'Calculates customer lifetime value and segmentation';


--
-- Name: decrypt_pii(text, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.decrypt_pii(p_encrypted_data text, p_key_id character varying DEFAULT 'default'::character varying) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_key BYTEA;
    v_decrypted TEXT;
BEGIN
    -- In production, retrieve key from secure key management
    v_key := digest(p_key_id || 'salt_value', 'sha256');
    
    -- Decrypt (placeholder implementation)
    v_decrypted := encode(decode(p_encrypted_data, 'base64'), 'escape');
    
    RETURN v_decrypted;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Decryption failed: %', SQLERRM;
END;
$$;



--
-- Name: FUNCTION decrypt_pii(p_encrypted_data text, p_key_id character varying); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.decrypt_pii(p_encrypted_data text, p_key_id character varying) IS 'Decrypts personally identifiable information';


--
-- Name: decrypt_sensitive_data(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.decrypt_sensitive_data(encrypted_data text) RETURNS text
    LANGUAGE plpgsql
    AS $$
BEGIN
   -- In production, use proper decryption with pgcrypto
   -- This is a placeholder
   RETURN convert_from(decode(encrypted_data, 'base64'), 'UTF8');
END;
$$;



--
-- Name: delete_venue(uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.delete_venue(p_venue_id uuid, p_deleted_by_user_id uuid, p_deletion_reason text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE venues
    SET deleted_at = NOW(),
        deleted_by_user_id = p_deleted_by_user_id,
        deletion_reason = p_deletion_reason,
        venue_status = 'closed'
    WHERE id = p_venue_id
    AND deleted_at IS NULL;
    
    RETURN FOUND;
END;
$$;



--
-- Name: detect_audit_tampering(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.detect_audit_tampering() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    calculated_checksum VARCHAR(64);
    record_data JSONB;
BEGIN
    -- Only check for tampering on updates
    IF TG_OP = 'UPDATE' THEN
        -- Create a JSON representation of the original record for checksum
        record_data = jsonb_build_object(
            'id', OLD.id,
            'user_id', OLD.user_id,
            'category', OLD.category,
            'action', OLD.action,
            'entity_type', OLD.entity_type,
            'entity_id', OLD.entity_id,
            'before_data', OLD.before_data,
            'after_data', OLD.after_data,
            'event_description', OLD.event_description,
            'created_at', OLD.created_at
        );
        
        calculated_checksum = calculate_audit_checksum(record_data);
        
        -- If checksum doesn't match, flag as tampered
        IF OLD.checksum IS NOT NULL AND OLD.checksum != calculated_checksum THEN
            NEW.is_tampered = TRUE;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: detect_schedule_conflicts(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.detect_schedule_conflicts() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    conflict_record RECORD;
    new_conflict_id UUID;
BEGIN
    -- Only check for conflicts if this is a venue-based event
    IF NEW.venue_id IS NOT NULL AND NEW.schedule_status NOT IN ('cancelled', 'completed') THEN
        
        -- Look for overlapping schedules at the same venue
        FOR conflict_record IN
            SELECT id, start_datetime, end_datetime, event_id
            FROM event_schedules
            WHERE id != NEW.id
            AND venue_id = NEW.venue_id
            AND schedule_status NOT IN ('cancelled', 'completed', 'draft')
            AND (
                (start_datetime <= NEW.start_datetime AND COALESCE(end_datetime, start_datetime + INTERVAL '4 hours') > NEW.start_datetime) OR
                (start_datetime < COALESCE(NEW.end_datetime, NEW.start_datetime + INTERVAL '4 hours') AND start_datetime >= NEW.start_datetime)
            )
        LOOP
            -- Create conflict record
            INSERT INTO schedule_conflicts (
                primary_schedule_id, conflicting_schedule_id, conflict_type,
                conflict_description, conflict_start, conflict_end,
                resource_type, resource_id, detected_by_user_id
            )
            VALUES (
                NEW.id, conflict_record.id, 'venue_double_booking',
                'Venue double booking detected between events',
                GREATEST(NEW.start_datetime, conflict_record.start_datetime),
                LEAST(COALESCE(NEW.end_datetime, NEW.start_datetime + INTERVAL '4 hours'), 
                      COALESCE(conflict_record.end_datetime, conflict_record.start_datetime + INTERVAL '4 hours')),
                'venue', NEW.venue_id::text, NEW.updated_by_user_id
            )
            ON CONFLICT DO NOTHING;  -- Avoid duplicate conflict records
        END LOOP;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: detect_suspicious_concurrent_sessions(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.detect_suspicious_concurrent_sessions() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    flagged_count INTEGER := 0;
    session_record RECORD;
BEGIN
    FOR session_record IN
        SELECT user_id, COUNT(*) as concurrent_count
        FROM sessions
        WHERE session_status = 'active'
        AND expires_at > NOW()
        GROUP BY user_id
        HAVING COUNT(*) > 10  -- Flag users with more than 10 concurrent sessions
    LOOP
        -- Flag all sessions for this user as suspicious
        UPDATE sessions
        SET is_suspicious = TRUE,
            risk_level = 'high'
        WHERE user_id = session_record.user_id
        AND session_status = 'active'
        AND is_suspicious = FALSE;
        
        flagged_count := flagged_count + session_record.concurrent_count;
    END LOOP;
    
    RETURN flagged_count;
END;
$$;



--
-- Name: duplicate_event(uuid, date, time without time zone, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.duplicate_event(p_source_event_id uuid, p_new_event_date date, p_new_event_time time without time zone DEFAULT NULL::time without time zone, p_created_by_user_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_event_id UUID;
    source_event RECORD;
    performer_record RECORD;
    session_record RECORD;
BEGIN
    -- Get source event details
    SELECT * INTO source_event FROM events WHERE id = p_source_event_id;
    
    -- Create new event
    INSERT INTO events (
        venue_id, event_name, event_category, event_date, event_time,
        short_description, full_description, event_subcategories, event_tags,
        genre, doors_open_time, show_start_time, estimated_duration,
        age_restriction, content_rating, content_warnings, accessibility_info,
        expected_attendance, max_capacity, venue_layout_id, seating_configuration,
        base_ticket_price, price_range_min, price_range_max,
        organizer_name, organizer_contact_email, organizer_contact_phone,
        promotional_text, marketing_copy, hashtags, social_media_links,
        primary_image_url, poster_image_url, banner_image_url,
        is_outdoor_event, weather_dependent, rain_policy,
        special_requirements, production_notes, catering_requirements,
        technical_requirements, security_requirements,
        cancellation_policy, refund_policy, force_majeure_policy,
        meta_title, meta_description, meta_keywords,
        created_by_user_id
    )
    SELECT 
        venue_id, event_name || ' - ' || p_new_event_date, event_category, 
        p_new_event_date, COALESCE(p_new_event_time, event_time),
        short_description, full_description, event_subcategories, event_tags,
        genre, doors_open_time, show_start_time, estimated_duration,
        age_restriction, content_rating, content_warnings, accessibility_info,
        expected_attendance, max_capacity, venue_layout_id, seating_configuration,
        base_ticket_price, price_range_min, price_range_max,
        organizer_name, organizer_contact_email, organizer_contact_phone,
        promotional_text, marketing_copy, hashtags, social_media_links,
        primary_image_url, poster_image_url, banner_image_url,
        is_outdoor_event, weather_dependent, rain_policy,
        special_requirements, production_notes, catering_requirements,
        technical_requirements, security_requirements,
        cancellation_policy, refund_policy, force_majeure_policy,
        meta_title, meta_description, meta_keywords,
        p_created_by_user_id
    FROM events
    WHERE id = p_source_event_id
    RETURNING id INTO new_event_id;
    
    -- Copy performers
    FOR performer_record IN
        SELECT * FROM event_performers WHERE event_id = p_source_event_id
    LOOP
        INSERT INTO event_performers (
            event_id, performer_name, performer_type, stage_name,
            performer_description, performer_genre, performance_order,
            set_duration, performance_fee, contact_name, contact_email,
            equipment_requirements, backstage_requirements,
            created_by_user_id
        )
        VALUES (
            new_event_id, performer_record.performer_name, performer_record.performer_type,
            performer_record.stage_name, performer_record.performer_description,
            performer_record.performer_genre, performer_record.performance_order,
            performer_record.set_duration, performer_record.performance_fee,
            performer_record.contact_name, performer_record.contact_email,
            performer_record.equipment_requirements, performer_record.backstage_requirements,
            p_created_by_user_id
        );
    END LOOP;
    
    -- Copy sessions (update session date to match new event date)
    FOR session_record IN
        SELECT * FROM event_sessions WHERE event_id = p_source_event_id
    LOOP
        INSERT INTO event_sessions (
            event_id, session_name, session_description, session_type,
            session_track, session_date, start_time, end_time,
            room_name, room_capacity, learning_objectives,
            equipment_needed, special_setup, max_attendees,
            created_by_user_id
        )
        VALUES (
            new_event_id, session_record.session_name, session_record.session_description,
            session_record.session_type, session_record.session_track,
            p_new_event_date, session_record.start_time, session_record.end_time,
            session_record.room_name, session_record.room_capacity,
            session_record.learning_objectives, session_record.equipment_needed,
            session_record.special_setup, session_record.max_attendees,
            p_created_by_user_id
        );
    END LOOP;
    
    RETURN new_event_id;
END;
$$;



--
-- Name: encrypt_pii(text, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.encrypt_pii(p_data text, p_key_id character varying DEFAULT 'default'::character varying) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_key BYTEA;
    v_encrypted BYTEA;
BEGIN
    -- In production, retrieve key from secure key management
    -- This is a placeholder implementation
    v_key := digest(p_key_id || 'salt_value', 'sha256');
    
    -- Encrypt using pgcrypto (requires pgcrypto extension)
    -- For demo, we'll use base64 encoding
    v_encrypted := encode(p_data::BYTEA, 'base64')::BYTEA;
    
    RETURN encode(v_encrypted, 'base64');
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Encryption failed: %', SQLERRM;
END;
$$;



--
-- Name: FUNCTION encrypt_pii(p_data text, p_key_id character varying); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.encrypt_pii(p_data text, p_key_id character varying) IS 'Encrypts personally identifiable information';


--
-- Name: encrypt_sensitive_data(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.encrypt_sensitive_data(data text) RETURNS text
    LANGUAGE plpgsql
    AS $$
BEGIN
   -- In production, use proper encryption with pgcrypto
   -- This is a placeholder
   RETURN encode(data::bytea, 'base64');
END;
$$;



--
-- Name: ensure_one_default_payment_method(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ensure_one_default_payment_method() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   IF NEW.is_default = TRUE THEN
       UPDATE public.payment_methods
       SET is_default = FALSE
       WHERE user_id = NEW.user_id 
           AND id != NEW.id
           AND is_default = TRUE;
   END IF;
   RETURN NEW;
END;
$$;



--
-- Name: ensure_one_primary_wallet(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ensure_one_primary_wallet() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   -- If setting a wallet as primary
   IF NEW.is_primary = TRUE THEN
       -- Remove primary flag from other wallets for same user/blockchain
       UPDATE wallet_addresses
       SET is_primary = FALSE
       WHERE user_id = NEW.user_id 
           AND blockchain = NEW.blockchain
           AND id != NEW.id
           AND is_primary = TRUE;
   END IF;
   RETURN NEW;
END;
$$;



--
-- Name: flag_suspicious_session(uuid, text, public.session_risk_level, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.flag_suspicious_session(p_session_id uuid, p_reason text, p_severity public.session_risk_level DEFAULT 'medium'::public.session_risk_level, p_detection_method character varying DEFAULT 'automated'::character varying) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    suspicious_id UUID;
    session_user_id UUID;
BEGIN
    -- Get user ID from session
    SELECT user_id INTO session_user_id FROM sessions WHERE id = p_session_id;
    
    -- Update session risk level
    UPDATE sessions
    SET is_suspicious = TRUE,
        risk_level = p_severity
    WHERE id = p_session_id;
    
    -- Insert suspicious session record
    INSERT INTO suspicious_sessions (
        session_id, user_id, detection_reason, severity, detection_method
    )
    VALUES (
        p_session_id, session_user_id, p_reason, p_severity, p_detection_method
    )
    RETURNING id INTO suspicious_id;
    
    -- Log suspicious activity
    INSERT INTO session_activities (
        session_id, activity_type, activity_description, is_suspicious
    )
    VALUES (
        p_session_id, 'suspicious_flagged', p_reason, TRUE
    );
    
    RETURN suspicious_id;
END;
$$;



--
-- Name: format_currency(numeric, character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.format_currency(p_amount numeric, p_currency_code character varying DEFAULT 'USD'::character varying, p_locale character varying DEFAULT 'en_US'::character varying) RETURNS text
    LANGUAGE plpgsql IMMUTABLE PARALLEL SAFE
    AS $_$
DECLARE
    v_symbol TEXT;
    v_formatted TEXT;
BEGIN
    -- Get currency symbol
    CASE p_currency_code
        WHEN 'USD' THEN v_symbol := '$';
        WHEN 'EUR' THEN v_symbol := '';
        WHEN 'GBP' THEN v_symbol := '';
        WHEN 'JPY' THEN v_symbol := '';
        ELSE v_symbol := p_currency_code || ' ';
    END CASE;
    
    -- Format based on locale
    CASE p_locale
        WHEN 'en_US' THEN
            v_formatted := v_symbol || TO_CHAR(p_amount, 'FM999,999,999.00');
        WHEN 'en_GB' THEN
            v_formatted := v_symbol || TO_CHAR(p_amount, 'FM999,999,999.00');
        WHEN 'de_DE' THEN
            v_formatted := TO_CHAR(p_amount, 'FM999G999G999D00') || ' ' || v_symbol;
        WHEN 'fr_FR' THEN
            v_formatted := TO_CHAR(p_amount, 'FM999G999G999D00') || ' ' || v_symbol;
        ELSE
            v_formatted := v_symbol || TO_CHAR(p_amount, 'FM999,999,999.00');
    END CASE;
    
    RETURN v_formatted;
END;
$_$;



--
-- Name: FUNCTION format_currency(p_amount numeric, p_currency_code character varying, p_locale character varying); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.format_currency(p_amount numeric, p_currency_code character varying, p_locale character varying) IS 'Formats numeric amount as currency string';


--
-- Name: fuzzy_match_customer(text, numeric); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.fuzzy_match_customer(p_search_term text, p_threshold numeric DEFAULT 0.3) RETURNS TABLE(customer_id uuid, email character varying, full_name text, phone character varying, similarity_score numeric)
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    -- Requires pg_trgm extension for similarity function
    RETURN QUERY
    SELECT 
        u.id,
        u.email,
        u.first_name || ' ' || u.last_name AS full_name,
        u.phone,
        GREATEST(
            similarity(LOWER(u.email), LOWER(p_search_term)),
            similarity(LOWER(u.first_name || ' ' || u.last_name), LOWER(p_search_term)),
            CASE 
                WHEN u.phone IS NOT NULL 
                THEN similarity(u.phone, p_search_term)
                ELSE 0 
            END
        ) AS score
    FROM users u
    WHERE u.role = 'CUSTOMER'
    AND (
        similarity(LOWER(u.email), LOWER(p_search_term)) >= p_threshold OR
        similarity(LOWER(u.first_name || ' ' || u.last_name), LOWER(p_search_term)) >= p_threshold OR
        (u.phone IS NOT NULL AND similarity(u.phone, p_search_term) >= p_threshold)
    )
    ORDER BY score DESC
    LIMIT 50;
END;
$$;



--
-- Name: FUNCTION fuzzy_match_customer(p_search_term text, p_threshold numeric); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.fuzzy_match_customer(p_search_term text, p_threshold numeric) IS 'Performs fuzzy search for customers by email, name, or phone';


--
-- Name: generate_barcode(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_barcode(p_ticket_id uuid) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_timestamp BIGINT;
    v_hash VARCHAR(32);
    v_barcode VARCHAR(100);
BEGIN
    v_timestamp := EXTRACT(EPOCH FROM CURRENT_TIMESTAMP)::BIGINT;
    v_hash := MD5(p_ticket_id::TEXT || v_timestamp::TEXT);
    v_barcode := 'TT' || UPPER(LEFT(v_hash, 12)) || LPAD((v_timestamp % 999999)::TEXT, 6, '0');
    
    RETURN v_barcode;
END;
$$;



--
-- Name: generate_compliance_report(uuid, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_compliance_report(p_venue_id uuid, p_report_date date DEFAULT CURRENT_DATE) RETURNS TABLE(compliance_type public.compliance_type, compliance_name character varying, status public.compliance_status, expiry_date date, days_to_expiry integer, violations_count bigint, last_inspection_date date, next_action_required text)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        vc.compliance_type,
        vc.compliance_name,
        vc.compliance_status,
        vc.expiry_date,
        CASE WHEN vc.expiry_date IS NOT NULL 
             THEN (vc.expiry_date - p_report_date)::INTEGER 
             ELSE NULL END as days_to_expiry,
        COALESCE(viol.violation_count, 0) as violations_count,
        insp.last_inspection_date,
        CASE 
            WHEN vc.compliance_status = 'expired' THEN 'Immediate renewal required'
            WHEN vc.expiry_date <= p_report_date + INTERVAL '30 days' THEN 'Renewal process should begin'
            WHEN COALESCE(viol.violation_count, 0) > 0 THEN 'Address open violations'
            ELSE 'No immediate action required'
        END as next_action_required
    FROM venue_compliance vc
    LEFT JOIN (
        SELECT compliance_id, COUNT(*) as violation_count
        FROM compliance_violations
        WHERE venue_id = p_venue_id AND violation_status = 'open'
        GROUP BY compliance_id
    ) viol ON vc.id = viol.compliance_id
    LEFT JOIN (
        SELECT compliance_id, MAX(inspection_date) as last_inspection_date
        FROM compliance_inspections
        WHERE venue_id = p_venue_id
        GROUP BY compliance_id
    ) insp ON vc.id = insp.compliance_id
    WHERE vc.venue_id = p_venue_id
    AND vc.is_current_version = TRUE
    ORDER BY 
        CASE vc.compliance_status 
            WHEN 'expired' THEN 1
            WHEN 'suspended' THEN 2
            WHEN 'pending_renewal' THEN 3
            ELSE 4
        END,
        vc.expiry_date NULLS LAST;
END;
$$;



--
-- Name: generate_compliance_report(timestamp with time zone, timestamp with time zone, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_compliance_report(p_start_date timestamp with time zone, p_end_date timestamp with time zone, p_compliance_type character varying DEFAULT 'all'::character varying) RETURNS TABLE(report_period text, total_events bigint, gdpr_events bigint, pci_events bigint, hipaa_events bigint, critical_events bigint, anomalous_events bigint, user_data_access_events bigint, financial_events bigint, security_events bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        p_start_date::date || ' to ' || p_end_date::date as report_period,
        COUNT(*) as total_events,
        COUNT(*) FILTER (WHERE is_gdpr_relevant = TRUE) as gdpr_events,
        COUNT(*) FILTER (WHERE is_pci_relevant = TRUE) as pci_events,
        COUNT(*) FILTER (WHERE is_hipaa_relevant = TRUE) as hipaa_events,
        COUNT(*) FILTER (WHERE severity = 'critical') as critical_events,
        COUNT(*) FILTER (WHERE is_anomalous = TRUE) as anomalous_events,
        COUNT(*) FILTER (WHERE category = 'privacy' OR action = 'read' AND entity_type = 'user') as user_data_access_events,
        COUNT(*) FILTER (WHERE category = 'financial') as financial_events,
        COUNT(*) FILTER (WHERE category = 'security') as security_events
    FROM audit_logs
    WHERE created_at BETWEEN p_start_date AND p_end_date
    AND is_archived = FALSE
    AND CASE 
        WHEN p_compliance_type = 'gdpr' THEN is_gdpr_relevant = TRUE
        WHEN p_compliance_type = 'pci' THEN is_pci_relevant = TRUE
        WHEN p_compliance_type = 'hipaa' THEN is_hipaa_relevant = TRUE
        ELSE TRUE
    END;
END;
$$;



--
-- Name: generate_daily_audit_summary(date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_daily_audit_summary(p_summary_date date DEFAULT CURRENT_DATE) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    summary_id UUID;
BEGIN
    INSERT INTO audit_log_summaries (
        summary_date, summary_type,
        authentication_events, authorization_events, data_modification_events,
        financial_events, security_events, system_events, privacy_events, compliance_events,
        info_events, warning_events, error_events, critical_events,
        total_events, unique_users, unique_ip_addresses, anomalous_events, high_risk_events,
        gdpr_relevant_events, pci_relevant_events, hipaa_relevant_events
    )
    SELECT 
        p_summary_date, 'daily',
        COUNT(*) FILTER (WHERE category = 'authentication'),
        COUNT(*) FILTER (WHERE category = 'authorization'),
        COUNT(*) FILTER (WHERE category = 'data_modification'),
        COUNT(*) FILTER (WHERE category = 'financial'),
        COUNT(*) FILTER (WHERE category = 'security'),
        COUNT(*) FILTER (WHERE category = 'system'),
        COUNT(*) FILTER (WHERE category = 'privacy'),
        COUNT(*) FILTER (WHERE category = 'compliance'),
        COUNT(*) FILTER (WHERE severity = 'info'),
        COUNT(*) FILTER (WHERE severity = 'warning'),
        COUNT(*) FILTER (WHERE severity = 'error'),
        COUNT(*) FILTER (WHERE severity = 'critical'),
        COUNT(*),
        COUNT(DISTINCT user_id),
        COUNT(DISTINCT ip_address),
        COUNT(*) FILTER (WHERE is_anomalous = TRUE),
        COUNT(*) FILTER (WHERE risk_score >= 70),
        COUNT(*) FILTER (WHERE is_gdpr_relevant = TRUE),
        COUNT(*) FILTER (WHERE is_pci_relevant = TRUE),
        COUNT(*) FILTER (WHERE is_hipaa_relevant = TRUE)
    FROM audit_logs
    WHERE DATE(created_at) = p_summary_date
    ON CONFLICT (summary_date, summary_type) 
    DO UPDATE SET
        authentication_events = EXCLUDED.authentication_events,
        authorization_events = EXCLUDED.authorization_events,
        data_modification_events = EXCLUDED.data_modification_events,
        financial_events = EXCLUDED.financial_events,
        security_events = EXCLUDED.security_events,
        system_events = EXCLUDED.system_events,
        privacy_events = EXCLUDED.privacy_events,
        compliance_events = EXCLUDED.compliance_events,
        info_events = EXCLUDED.info_events,
        warning_events = EXCLUDED.warning_events,
        error_events = EXCLUDED.error_events,
        critical_events = EXCLUDED.critical_events,
        total_events = EXCLUDED.total_events,
        unique_users = EXCLUDED.unique_users,
        unique_ip_addresses = EXCLUDED.unique_ip_addresses,
        anomalous_events = EXCLUDED.anomalous_events,
        high_risk_events = EXCLUDED.high_risk_events,
        gdpr_relevant_events = EXCLUDED.gdpr_relevant_events,
        pci_relevant_events = EXCLUDED.pci_relevant_events,
        hipaa_relevant_events = EXCLUDED.hipaa_relevant_events
    RETURNING id INTO summary_id;
    
    RETURN summary_id;
END;
$$;



--
-- Name: generate_event_slug(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_event_slug() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   IF NEW.slug IS NULL OR NEW.slug = '' THEN
       NEW.slug := LOWER(REGEXP_REPLACE(NEW.name, '[^a-zA-Z0-9]+', '-', 'g'));
       -- Add venue slug prefix
       NEW.slug := (SELECT slug FROM public.venues WHERE id = NEW.venue_id) || '-' || NEW.slug;
       -- Ensure uniqueness
       WHILE EXISTS (SELECT 1 FROM public.events WHERE slug = NEW.slug AND id != NEW.id) LOOP
           NEW.slug := NEW.slug || '-' || SUBSTR(MD5(RANDOM()::TEXT), 1, 4);
       END LOOP;
   END IF;
   RETURN NEW;
END;
$$;



--
-- Name: generate_invoice_number(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_invoice_number() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_year VARCHAR(4);
    v_month VARCHAR(2);
    v_sequence INTEGER;
    v_prefix VARCHAR(10);
BEGIN
    -- Get current year and month
    v_year := TO_CHAR(CURRENT_DATE, 'YYYY');
    v_month := TO_CHAR(CURRENT_DATE, 'MM');
    
    -- Determine prefix based on invoice type
    CASE NEW.invoice_type
        WHEN 'subscription' THEN v_prefix := 'SUB';
        WHEN 'settlement' THEN v_prefix := 'SET';
        WHEN 'credit_note' THEN v_prefix := 'CN';
        ELSE v_prefix := 'INV';
    END CASE;
    
    -- Get next sequence number for this year-month
    SELECT COALESCE(MAX(CAST(SUBSTRING(invoice_number FROM '[0-9]+$') AS INTEGER)), 0) + 1
    INTO v_sequence
    FROM invoices
    WHERE invoice_number LIKE v_prefix || '-' || v_year || v_month || '-%';
    
    -- Generate invoice number: PREFIX-YYYYMM-SEQUENCE
    NEW.invoice_number := v_prefix || '-' || v_year || v_month || '-' || LPAD(v_sequence::TEXT, 5, '0');
    
    RETURN NEW;
END;
$_$;



--
-- Name: generate_loyalty_account_number(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_loyalty_account_number() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_prefix VARCHAR(3) := 'TKT';
    v_random VARCHAR(8);
    v_account_number VARCHAR(20);
    v_exists BOOLEAN := true;
BEGIN
    -- Generate unique account number if not provided
    IF NEW.account_number IS NULL THEN
        WHILE v_exists LOOP
            -- Generate random 8-digit number
            v_random := LPAD(FLOOR(RANDOM() * 100000000)::TEXT, 8, '0');
            v_account_number := v_prefix || v_random;
            
            -- Check if it exists
            SELECT EXISTS(SELECT 1 FROM loyalty_accounts WHERE account_number = v_account_number) INTO v_exists;
        END LOOP;
        
        NEW.account_number := v_account_number;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: generate_qr_code_data(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_qr_code_data() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
   qr_data JSONB;


BEGIN
   -- Create QR code data
   qr_data := jsonb_build_object(
       'ticket_id', NEW.id,
       'ticket_code', NEW.ticket_code,
       'event_id', NEW.event_id,
       'owner_id', NEW.owner_id,
       'valid', NEW.is_valid
   );


   
   -- Encrypt the data (in production, use proper encryption)
   NEW.qr_code_data := encode(qr_data::text::bytea, 'base64');


   NEW.qr_code_generated_at := CURRENT_TIMESTAMP;


   
   RETURN NEW;


END;


$$;



--
-- Name: generate_random_code(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_random_code(length integer DEFAULT 6) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
   chars TEXT := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
   result TEXT := '';
   i INTEGER;
BEGIN
   FOR i IN 1..length LOOP
       result := result || substr(chars, floor(random() * length(chars) + 1)::INTEGER, 1);
   END LOOP;
   RETURN result;
END;
$$;



--
-- Name: FUNCTION generate_random_code(length integer); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.generate_random_code(length integer) IS 'Generate random alphanumeric code';


--
-- Name: generate_recurring_schedule_instances(uuid, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_recurring_schedule_instances(p_schedule_id uuid, p_max_instances integer DEFAULT 52) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    schedule_record RECORD;
    instance_count INTEGER := 0;
    current_datetime TIMESTAMPTZ;
    end_datetime TIMESTAMPTZ;
    instance_number INTEGER := 1;
    new_schedule_id UUID;
BEGIN
    -- Get the master schedule details
    SELECT * INTO schedule_record
    FROM event_schedules
    WHERE id = p_schedule_id
    AND is_recurring = TRUE;
    
    IF NOT FOUND THEN
        RETURN 0;
    END IF;
    
    current_datetime := schedule_record.start_datetime;
    
    -- Generate instances based on recurrence pattern
    WHILE instance_number <= COALESCE(schedule_record.recurrence_count, p_max_instances)
        AND (schedule_record.recurrence_until IS NULL OR current_datetime <= schedule_record.recurrence_until)
    LOOP
        -- Skip the first instance (it's the master schedule)
        IF instance_number > 1 THEN
            -- Calculate end datetime for this instance
            end_datetime := CASE 
                WHEN schedule_record.end_datetime IS NOT NULL THEN
                    current_datetime + (schedule_record.end_datetime - schedule_record.start_datetime)
                ELSE NULL
            END;
            
            -- Create schedule instance
            INSERT INTO event_schedules (
                event_id, start_datetime, end_datetime, venue_id,
                schedule_type, schedule_status, is_public, venue_layout_id,
                total_capacity, base_price_override, pricing_multiplier,
                weather_dependent, rain_contingency, special_requirements,
                original_schedule_id, created_by_user_id
            )
            VALUES (
                schedule_record.event_id, current_datetime, end_datetime, schedule_record.venue_id,
                'single', 'tentative', schedule_record.is_public, schedule_record.venue_layout_id,
                schedule_record.total_capacity, schedule_record.base_price_override, schedule_record.pricing_multiplier,
                schedule_record.weather_dependent, schedule_record.rain_contingency, schedule_record.special_requirements,
                p_schedule_id, schedule_record.created_by_user_id
            )
            RETURNING id INTO new_schedule_id;
            
            instance_count := instance_count + 1;
        END IF;
        
        -- Calculate next occurrence
        current_datetime := CASE schedule_record.recurrence_pattern
            WHEN 'daily' THEN current_datetime + INTERVAL '1 day' * schedule_record.recurrence_interval
            WHEN 'weekly' THEN current_datetime + INTERVAL '1 week' * schedule_record.recurrence_interval
            WHEN 'bi_weekly' THEN current_datetime + INTERVAL '2 weeks'
            WHEN 'monthly' THEN current_datetime + INTERVAL '1 month' * schedule_record.recurrence_interval
            WHEN 'quarterly' THEN current_datetime + INTERVAL '3 months' * schedule_record.recurrence_interval
            WHEN 'annually' THEN current_datetime + INTERVAL '1 year' * schedule_record.recurrence_interval
            ELSE current_datetime + INTERVAL '1 week'  -- Default fallback
        END;
        
        instance_number := instance_number + 1;
    END LOOP;
    
    RETURN instance_count;
END;
$$;



--
-- Name: generate_report_code(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_report_code() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_prefix VARCHAR(10);
    v_date_part VARCHAR(8);
    v_sequence INTEGER;
BEGIN
    -- Determine prefix based on report type and category
    v_prefix := CASE 
        WHEN NEW.report_category = 'revenue' THEN 'REV'
        WHEN NEW.report_category = 'transactions' THEN 'TXN'
        WHEN NEW.report_category = 'settlements' THEN 'SET'
        WHEN NEW.report_category = 'taxes' THEN 'TAX'
        ELSE 'FIN'
    END;
    
    -- Add report type to prefix
    v_prefix := v_prefix || '-' || UPPER(SUBSTRING(NEW.report_type, 1, 3));
    
    -- Generate date part
    v_date_part := TO_CHAR(CURRENT_DATE, 'YYYYMMDD');
    
    -- Get sequence number
    SELECT COALESCE(MAX(CAST(SUBSTRING(report_code FROM '[0-9]+$') AS INTEGER)), 0) + 1
    INTO v_sequence
    FROM financial_reports
    WHERE report_code LIKE v_prefix || '-' || v_date_part || '-%';
    
    -- Generate report code
    NEW.report_code := v_prefix || '-' || v_date_part || '-' || LPAD(v_sequence::TEXT, 4, '0');
    
    RETURN NEW;
END;
$_$;



--
-- Name: generate_seat_code(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_seat_code() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    section_code VARCHAR(20);
BEGIN
    -- Update timestamp
    NEW.updated_at = NOW();
    
    -- Generate seat code if not provided
    IF NEW.seat_code IS NULL THEN
        SELECT ls.section_code INTO section_code
        FROM layout_sections ls
        WHERE ls.id = NEW.section_id;
        
        NEW.seat_code = section_code || '-' || NEW.row_identifier || '-' || NEW.seat_number;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: generate_seo_slug(uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_seo_slug(p_event_id uuid, p_base_text text DEFAULT NULL::text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_event_name TEXT;
    v_slug TEXT;
    v_counter INTEGER := 0;
    v_final_slug TEXT;
BEGIN
    -- Get event name if base text not provided
    IF p_base_text IS NULL THEN
        SELECT event_name INTO v_event_name
        FROM events
        WHERE id = p_event_id;
        
        v_slug := v_event_name;
    ELSE
        v_slug := p_base_text;
    END IF;
    
    -- Clean and format slug
    v_slug := LOWER(v_slug);
    v_slug := REGEXP_REPLACE(v_slug, '[^a-z0-9\s-]', '', 'g');
    v_slug := REGEXP_REPLACE(v_slug, '\s+', '-', 'g');
    v_slug := REGEXP_REPLACE(v_slug, '-+', '-', 'g');
    v_slug := TRIM(BOTH '-' FROM v_slug);
    
    -- Ensure uniqueness
    v_final_slug := v_slug;
    WHILE EXISTS (
        SELECT 1 FROM event_seo_metadata
        WHERE canonical_url LIKE '%' || v_final_slug || '%'
          AND event_id != p_event_id
    ) LOOP
        v_counter := v_counter + 1;
        v_final_slug := v_slug || '-' || v_counter;
    END LOOP;
    
    RETURN v_final_slug;
END;
$$;



--
-- Name: generate_settlement_number(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_settlement_number() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    venue_code VARCHAR(6);
    period_code VARCHAR(8);
    sequence_num INTEGER;
BEGIN
    -- Get venue code (first 6 chars of venue_id)
    venue_code := UPPER(SUBSTR(NEW.venue_id::TEXT, 1, 6));
    
    -- Generate period code based on settlement type
    CASE NEW.settlement_type
        WHEN 'daily' THEN 
            period_code := TO_CHAR(NEW.period_start_date, 'YYYYMMDD');
        WHEN 'weekly' THEN 
            period_code := 'W' || TO_CHAR(NEW.period_start_date, 'YYYYWW');
        WHEN 'monthly' THEN 
            period_code := 'M' || TO_CHAR(NEW.period_start_date, 'YYYYMM');
        ELSE 
            period_code := 'C' || TO_CHAR(NEW.period_start_date, 'YYMMDD');
    END CASE;
    
    -- Get sequence number for this venue and period
    SELECT COUNT(*) + 1 INTO sequence_num
    FROM settlements
    WHERE venue_id = NEW.venue_id
    AND period_start_date = NEW.period_start_date;
    
    -- Generate settlement number
    NEW.settlement_number := 'SET-' || venue_code || '-' || period_code || '-' || LPAD(sequence_num::TEXT, 3, '0');
    
    RETURN NEW;
END;
$$;



--
-- Name: generate_ticket_code(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_ticket_code(p_event_id uuid, p_ticket_id uuid) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_event_code VARCHAR(4);
    v_random_code VARCHAR(8);
    v_check_digit INTEGER;
    v_final_code VARCHAR(20);
    v_attempts INTEGER := 0;
BEGIN
    -- Extract first 4 chars of event ID
    v_event_code := UPPER(SUBSTRING(p_event_id::TEXT, 1, 4));
    
    LOOP
        -- Generate random alphanumeric code
        v_random_code := UPPER(SUBSTRING(MD5(random()::TEXT || clock_timestamp()::TEXT), 1, 8));
        
        -- Calculate check digit (simple modulo 97)
        v_check_digit := MOD(
            (ASCII(SUBSTRING(v_random_code, 1, 1)) + 
             ASCII(SUBSTRING(v_random_code, 8, 1))), 
            97
        );
        
        -- Combine parts
        v_final_code := v_event_code || '-' || v_random_code || '-' || LPAD(v_check_digit::TEXT, 2, '0');
        
        -- Check uniqueness (would check against tickets table)
        -- For now, assume unique after 1 attempt
        EXIT;
        
        v_attempts := v_attempts + 1;
        IF v_attempts > 10 THEN
            RAISE EXCEPTION 'Could not generate unique ticket code';
        END IF;
    END LOOP;
    
    RETURN v_final_code;
END;
$$;



--
-- Name: FUNCTION generate_ticket_code(p_event_id uuid, p_ticket_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.generate_ticket_code(p_event_id uuid, p_ticket_id uuid) IS 'Generates unique ticket code with check digit';


--
-- Name: generate_ticket_identifiers(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_ticket_identifiers() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.ticket_number IS NULL THEN
        NEW.ticket_number := generate_ticket_number(NEW.event_id, NEW.ticket_type_id);
    END IF;
    
    IF NEW.barcode IS NULL THEN
        NEW.barcode := generate_barcode(NEW.id);
    END IF;
    
    IF NEW.ticket_hash IS NULL THEN
        NEW.ticket_hash := ENCODE(SHA256((NEW.id || NEW.ticket_number || NEW.barcode)::BYTEA), 'hex');
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: generate_ticket_notification(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_ticket_notification() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Notify on new listing
    IF TG_TABLE_NAME = 'listings' AND TG_OP = 'INSERT' THEN
        INSERT INTO notification_queue (type, recipient_id, data)
        SELECT 'new_listing', user_id, jsonb_build_object(
            'listing_id', NEW.id,
            'ticket_id', NEW.ticket_id,
            'price', NEW.price
        )
        FROM tickets t
        JOIN events e ON t.event_id = e.id
        WHERE NEW.id IN (SELECT transaction_id FROM ticket_transactions tt WHERE tt.ticket_id = t.id);
    END IF;
    
    RETURN NULL;
END;
$$;



--
-- Name: generate_ticket_number(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_ticket_number() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
   event_code VARCHAR(4);


   sequence_num INTEGER;


BEGIN
   -- Get event code (first 4 chars of event slug)
   SELECT UPPER(SUBSTR(slug, 1, 4)) INTO event_code
   FROM public.events WHERE id = NEW.event_id;


   
   -- Get next sequence number for this event
   SELECT COUNT(*) + 1 INTO sequence_num
   FROM public.tickets WHERE event_id = NEW.event_id;


   
   -- Generate ticket number: EVNT-000001
   NEW.ticket_number := event_code || '-' || LPAD(sequence_num::TEXT, 6, '0');


   
   RETURN NEW;


END;


$$;



--
-- Name: generate_ticket_number(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_ticket_number(p_event_id uuid, p_ticket_type_id uuid) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_event_code VARCHAR(10);
    v_type_code VARCHAR(5);
    v_sequence INTEGER;
    v_ticket_number VARCHAR(50);
BEGIN
    -- Get event code (first 3 chars of event name + last 4 of UUID)
    SELECT UPPER(LEFT(REGEXP_REPLACE(event_name, '[^A-Za-z0-9]', '', 'g'), 3)) || 
           RIGHT(REPLACE(id::TEXT, '-', ''), 4) INTO v_event_code
    FROM events WHERE id = p_event_id;
    
    -- Get ticket type code (first 2 chars of type name + priority)
    SELECT UPPER(LEFT(REGEXP_REPLACE(type_name, '[^A-Za-z0-9]', '', 'g'), 2)) || 
           LPAD(tier_priority::TEXT, 1, '0') INTO v_type_code
    FROM ticket_types WHERE id = p_ticket_type_id;
    
    -- Get next sequence number for this event/type combination
    SELECT COALESCE(MAX(CAST(RIGHT(ticket_number, 6) AS INTEGER)), 0) + 1 INTO v_sequence
    FROM tickets 
    WHERE event_id = p_event_id AND ticket_type_id = p_ticket_type_id
    AND ticket_number ~ '^[A-Z0-9]+-[A-Z0-9]+-[0-9]+$';
    
    v_ticket_number := v_event_code || '-' || v_type_code || '-' || LPAD(v_sequence::TEXT, 6, '0');
    
    RETURN v_ticket_number;
END;
$_$;



--
-- Name: generate_transaction_reference(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_transaction_reference() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    prefix VARCHAR(3);
    date_part VARCHAR(6);
    random_part VARCHAR(6);
BEGIN
    -- Generate prefix based on transaction type
    CASE NEW.transaction_type
        WHEN 'payment' THEN prefix := 'PAY';
        WHEN 'refund' THEN prefix := 'REF';
        WHEN 'payout' THEN prefix := 'OUT';
        WHEN 'fee' THEN prefix := 'FEE';
        ELSE prefix := 'TXN';
    END CASE;
    
    -- Generate date part (YYMMDD)
    date_part := TO_CHAR(CURRENT_DATE, 'YYMMDD');
    
    -- Generate random part
    random_part := UPPER(SUBSTR(MD5(RANDOM()::TEXT), 1, 6));
    
    -- Combine parts
    NEW.reference_number := prefix || '-' || date_part || '-' || random_part;
    
    -- Set accounting period
    NEW.accounting_period := TO_CHAR(NEW.created_at, 'YYYY-MM');
    
    RETURN NEW;
END;
$$;



--
-- Name: generate_user_referral_code(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_user_referral_code() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   IF NEW.referral_code IS NULL THEN
       NEW.referral_code := UPPER(generate_random_code(8));
   END IF;
   RETURN NEW;
END;
$$;



--
-- Name: generate_venue_slug(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_venue_slug() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.slug IS NULL OR NEW.slug = '' THEN
        NEW.slug := LOWER(REGEXP_REPLACE(NEW.name, '[^a-zA-Z0-9]+', '-', 'g'));
        WHILE EXISTS (SELECT 1 FROM public.venues WHERE slug = NEW.slug AND id != NEW.id) LOOP
            NEW.slug := NEW.slug || '-' || SUBSTR(MD5(RANDOM()::TEXT), 1, 4);
        END LOOP;
    END IF;
    RETURN NEW;
END;
$$;



--
-- Name: get_active_users_count(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_active_users_count() RETURNS integer
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN (SELECT COUNT(*) FROM users WHERE account_status = 'active' AND deleted_at IS NULL);
END;
$$;



--
-- Name: get_available_seats(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_available_seats(p_section_id uuid, p_event_id uuid DEFAULT NULL::uuid) RETURNS TABLE(seat_id uuid, seat_code character varying, row_identifier character varying, seat_number character varying, seat_type public.seat_type, pricing_tier public.pricing_tier, base_price numeric, is_accessible boolean, is_companion boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT ls.id, ls.seat_code, ls.row_identifier, ls.seat_number,
           ls.seat_type, ls.pricing_tier, ls.base_price,
           ls.is_accessible, ls.is_companion
    FROM layout_seats ls
    WHERE ls.section_id = p_section_id
    AND ls.is_active = TRUE
    AND ls.is_saleable = TRUE
    AND ls.is_blocked = FALSE
    -- Add event-specific availability check here when ticket sales are implemented
    ORDER BY ls.row_identifier, ls.seat_number;
END;
$$;



--
-- Name: get_capacity_utilization(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_capacity_utilization(p_event_capacity_id uuid) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_sold INTEGER;
    v_total INTEGER;
BEGIN
    SELECT sold_capacity, total_capacity
    INTO v_sold, v_total
    FROM event_capacity
    WHERE id = p_event_capacity_id;
    
    IF v_total = 0 THEN
        RETURN 0;
    END IF;
    
    RETURN ROUND((v_sold::DECIMAL / v_total::DECIMAL) * 100, 2);
END;
$$;



--
-- Name: get_category_path(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_category_path(p_category_id uuid) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_path TEXT := '';
    v_current_id UUID := p_category_id;
    v_category_name VARCHAR(100);
    v_parent_id UUID;
BEGIN
    WHILE v_current_id IS NOT NULL LOOP
        SELECT category_name, parent_category_id
        INTO v_category_name, v_parent_id
        FROM event_categories
        WHERE id = v_current_id;
        
        IF v_path = '' THEN
            v_path := v_category_name;
        ELSE
            v_path := v_category_name || ' > ' || v_path;
        END IF;
        
        v_current_id := v_parent_id;
    END LOOP;
    
    RETURN v_path;
END;
$$;



--
-- Name: get_compliance_status_summary(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_compliance_status_summary(p_venue_id uuid) RETURNS TABLE(compliance_type public.compliance_type, total_items bigint, valid_items bigint, expired_items bigint, expiring_soon bigint, pending_renewal bigint, violations_count bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        vc.compliance_type,
        COUNT(*) as total_items,
        COUNT(*) FILTER (WHERE vc.compliance_status = 'valid') as valid_items,
        COUNT(*) FILTER (WHERE vc.compliance_status = 'expired') as expired_items,
        COUNT(*) FILTER (WHERE vc.expiry_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '30 days') as expiring_soon,
        COUNT(*) FILTER (WHERE vc.compliance_status = 'pending_renewal') as pending_renewal,
        COALESCE(cv.violation_count, 0) as violations_count
    FROM venue_compliance vc
    LEFT JOIN (
        SELECT compliance_id, COUNT(*) as violation_count
        FROM compliance_violations
        WHERE venue_id = p_venue_id AND violation_status = 'open'
        GROUP BY compliance_id
    ) cv ON vc.id = cv.compliance_id
    WHERE vc.venue_id = p_venue_id
    AND vc.is_current_version = TRUE
    GROUP BY vc.compliance_type, cv.violation_count
    ORDER BY vc.compliance_type;
END;
$$;



--
-- Name: get_entity_audit_trail(character varying, character varying, timestamp with time zone, timestamp with time zone, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_entity_audit_trail(p_entity_type character varying, p_entity_id character varying, p_start_date timestamp with time zone DEFAULT (now() - '30 days'::interval), p_end_date timestamp with time zone DEFAULT now(), p_limit integer DEFAULT 100) RETURNS TABLE(id uuid, created_at timestamp with time zone, user_id uuid, action public.audit_action, event_description text, before_data jsonb, after_data jsonb, changed_fields text[])
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT al.id, al.created_at, al.user_id, al.action, al.event_description,
           al.before_data, al.after_data, al.changed_fields
    FROM audit_logs al
    WHERE al.entity_type = p_entity_type
    AND al.entity_id = p_entity_id
    AND al.created_at BETWEEN p_start_date AND p_end_date
    AND al.is_archived = FALSE
    ORDER BY al.created_at DESC
    LIMIT p_limit;
END;
$$;



--
-- Name: get_event_details(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_event_details(p_event_id uuid) RETURNS TABLE(event_id uuid, event_name character varying, event_category public.event_category, event_date date, event_time time without time zone, venue_id uuid, full_description text, event_status public.event_status, age_restriction public.age_restriction, price_range_min numeric, price_range_max numeric, performers jsonb, sessions jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT e.id, e.event_name, e.event_category, e.event_date, e.event_time,
           e.venue_id, e.full_description, e.event_status, e.age_restriction,
           e.price_range_min, e.price_range_max,
           COALESCE(
               (SELECT jsonb_agg(
                   jsonb_build_object(
                       'performer_name', ep.performer_name,
                       'performer_type', ep.performer_type,
                       'performance_order', ep.performance_order,
                       'headliner', ep.headliner,
                       'set_duration', ep.set_duration
                   ) ORDER BY ep.performance_order
               ) FROM event_performers ep WHERE ep.event_id = e.id),
               '[]'::jsonb
           ) as performers,
           COALESCE(
               (SELECT jsonb_agg(
                   jsonb_build_object(
                       'session_name', es.session_name,
                       'session_date', es.session_date,
                       'start_time', es.start_time,
                       'end_time', es.end_time,
                       'room_name', es.room_name
                   ) ORDER BY es.session_date, es.start_time
               ) FROM event_sessions es WHERE es.event_id = e.id),
               '[]'::jsonb
           ) as sessions
    FROM events e
    WHERE e.id = p_event_id
    AND e.deleted_at IS NULL;
END;
$$;



--
-- Name: get_event_metadata(uuid, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_event_metadata(p_event_id uuid, p_metadata_type character varying DEFAULT NULL::character varying) RETURNS TABLE(metadata_key character varying, metadata_value text, metadata_json jsonb, data_type character varying, is_public boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        em.metadata_key,
        em.metadata_value,
        em.metadata_json,
        em.data_type,
        em.is_public
    FROM event_metadata em
    WHERE em.event_id = p_event_id
      AND em.is_current_version = true
      AND (p_metadata_type IS NULL OR em.metadata_type = p_metadata_type)
      AND (em.expires_at IS NULL OR em.expires_at > CURRENT_TIMESTAMP)
    ORDER BY em.metadata_type, em.display_order, em.metadata_key;
END;
$$;



--
-- Name: get_event_statistics(uuid, date, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_event_statistics(p_venue_id uuid DEFAULT NULL::uuid, p_start_date date DEFAULT (CURRENT_DATE - '30 days'::interval), p_end_date date DEFAULT CURRENT_DATE) RETURNS TABLE(total_events bigint, completed_events bigint, cancelled_events bigint, total_attendance bigint, total_revenue numeric, average_rating numeric, events_by_category jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*) as total_events,
        COUNT(*) FILTER (WHERE event_status = 'completed') as completed_events,
        COUNT(*) FILTER (WHERE event_status = 'cancelled') as cancelled_events,
        COALESCE(SUM(attendance_count), 0) as total_attendance,
        COALESCE(SUM(gross_revenue), 0) as total_revenue,
        AVG(average_rating) as average_rating,
        (SELECT jsonb_object_agg(event_category, cnt) 
         FROM (SELECT event_category, COUNT(*) as cnt 
               FROM events 
               WHERE deleted_at IS NULL 
               AND (p_venue_id IS NULL OR venue_id = p_venue_id)
               AND event_date BETWEEN p_start_date AND p_end_date
               GROUP BY event_category) t) as events_by_category
    FROM events
    WHERE deleted_at IS NULL
    AND (p_venue_id IS NULL OR venue_id = p_venue_id)
    AND event_date BETWEEN p_start_date AND p_end_date;
END;
$$;



--
-- Name: get_expiring_certifications(uuid, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_expiring_certifications(p_venue_id uuid DEFAULT NULL::uuid, p_days_ahead integer DEFAULT 30) RETURNS TABLE(staff_name character varying, certification_name character varying, expiry_date date, days_until_expiry integer, is_verified boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT CONCAT(u.first_name, ' ', u.last_name) as staff_name,
           sc.certification_name, sc.expiry_date,
           (sc.expiry_date - CURRENT_DATE)::INTEGER as days_until_expiry,
           sc.is_verified
    FROM staff_certifications sc
    JOIN venue_staff vs ON sc.venue_staff_id = vs.id
    JOIN users u ON vs.user_id = u.id
    WHERE (p_venue_id IS NULL OR vs.venue_id = p_venue_id)
    AND sc.expiry_date IS NOT NULL
    AND sc.expiry_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '1 day' * p_days_ahead
    AND sc.is_active = TRUE
    ORDER BY sc.expiry_date, staff_name;
END;
$$;



--
-- Name: get_expiring_compliance(uuid, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_expiring_compliance(p_venue_id uuid DEFAULT NULL::uuid, p_days_ahead integer DEFAULT 30) RETURNS TABLE(compliance_id uuid, venue_id uuid, compliance_name character varying, compliance_type public.compliance_type, expiry_date date, days_until_expiry integer, issuing_authority character varying, renewal_required boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT vc.id, vc.venue_id, vc.compliance_name, vc.compliance_type,
           vc.expiry_date, (vc.expiry_date - CURRENT_DATE)::INTEGER,
           vc.issuing_authority, vc.renewal_required
    FROM venue_compliance vc
    WHERE (p_venue_id IS NULL OR vc.venue_id = p_venue_id)
    AND vc.expiry_date IS NOT NULL
    AND vc.expiry_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '1 day' * p_days_ahead
    AND vc.is_current_version = TRUE
    AND vc.compliance_status IN ('valid', 'pending_renewal')
    ORDER BY vc.expiry_date, vc.compliance_name;
END;
$$;



--
-- Name: get_integration_credentials(uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_integration_credentials(p_integration_id uuid, p_encryption_key text DEFAULT 'venue_integration_key'::text) RETURNS TABLE(api_key text, client_id text, client_secret text, access_token text, refresh_token text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        CASE WHEN api_key_encrypted IS NOT NULL THEN pgp_sym_decrypt(api_key_encrypted, p_encryption_key) ELSE NULL END,
        CASE WHEN client_id_encrypted IS NOT NULL THEN pgp_sym_decrypt(client_id_encrypted, p_encryption_key) ELSE NULL END,
        CASE WHEN client_secret_encrypted IS NOT NULL THEN pgp_sym_decrypt(client_secret_encrypted, p_encryption_key) ELSE NULL END,
        CASE WHEN access_token_encrypted IS NOT NULL THEN pgp_sym_decrypt(access_token_encrypted, p_encryption_key) ELSE NULL END,
        CASE WHEN refresh_token_encrypted IS NOT NULL THEN pgp_sym_decrypt(refresh_token_encrypted, p_encryption_key) ELSE NULL END
    FROM venue_integrations
    WHERE id = p_integration_id;
END;
$$;



--
-- Name: get_integration_status_summary(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_integration_status_summary(p_venue_id uuid) RETURNS TABLE(integration_type public.integration_type, total_integrations bigint, active_integrations bigint, error_integrations bigint, last_sync_status text, health_summary jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        vi.integration_type,
        COUNT(*) as total_integrations,
        COUNT(*) FILTER (WHERE vi.integration_status = 'active') as active_integrations,
        COUNT(*) FILTER (WHERE vi.integration_status = 'error') as error_integrations,
        CASE 
            WHEN COUNT(*) FILTER (WHERE vi.last_sync_at > NOW() - INTERVAL '1 hour') = COUNT(*) THEN 'recent'
            WHEN COUNT(*) FILTER (WHERE vi.last_sync_at > NOW() - INTERVAL '24 hours') > 0 THEN 'partial'
            ELSE 'stale'
        END as last_sync_status,
        jsonb_build_object(
            'healthy', COUNT(*) FILTER (WHERE vi.health_status = 'healthy'),
            'degraded', COUNT(*) FILTER (WHERE vi.health_status = 'degraded'),
            'unhealthy', COUNT(*) FILTER (WHERE vi.health_status = 'unhealthy')
        ) as health_summary
    FROM venue_integrations vi
    WHERE vi.venue_id = p_venue_id
    GROUP BY vi.integration_type
    ORDER BY vi.integration_type;
END;
$$;



--
-- Name: get_layout_summary(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_layout_summary(p_layout_id uuid) RETURNS TABLE(layout_name character varying, layout_status public.layout_status, total_capacity integer, seated_capacity integer, standing_capacity integer, wheelchair_capacity integer, section_count bigint, pricing_zones jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT vl.layout_name, vl.layout_status, vl.total_capacity,
           vl.seated_capacity, vl.standing_capacity, vl.wheelchair_capacity,
           COUNT(ls.id) as section_count,
           vl.pricing_zones
    FROM venue_layouts vl
    LEFT JOIN layout_sections ls ON vl.id = ls.layout_id AND ls.is_active = TRUE
    WHERE vl.id = p_layout_id
    GROUP BY vl.id, vl.layout_name, vl.layout_status, vl.total_capacity,
             vl.seated_capacity, vl.standing_capacity, vl.wheelchair_capacity,
             vl.pricing_zones;
END;
$$;



--
-- Name: get_metadata_analytics(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_metadata_analytics(p_event_id uuid DEFAULT NULL::uuid) RETURNS TABLE(metadata_type character varying, total_count bigint, public_count bigint, searchable_count bigint, avg_value_length numeric, most_common_keys text[])
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        em.metadata_type,
        COUNT(*)::BIGINT as total_count,
        COUNT(*) FILTER (WHERE em.is_public = true)::BIGINT as public_count,
        COUNT(*) FILTER (WHERE em.is_searchable = true)::BIGINT as searchable_count,
        AVG(LENGTH(em.metadata_value))::NUMERIC as avg_value_length,
        ARRAY_AGG(em.metadata_key ORDER BY COUNT(*) DESC)::TEXT[] as most_common_keys
    FROM event_metadata em
    WHERE em.is_current_version = true
      AND (p_event_id IS NULL OR em.event_id = p_event_id)
    GROUP BY em.metadata_type
    ORDER BY total_count DESC;
END;
$$;



--
-- Name: get_open_violations(uuid, public.violation_severity); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_open_violations(p_venue_id uuid, p_severity public.violation_severity DEFAULT NULL::public.violation_severity) RETURNS TABLE(violation_id uuid, violation_title character varying, severity public.violation_severity, violation_date date, remediation_deadline date, days_overdue integer, fine_amount numeric, issuing_authority character varying)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT cv.id, cv.violation_title, cv.severity, cv.violation_date,
           cv.remediation_deadline,
           CASE 
               WHEN cv.remediation_deadline IS NOT NULL AND cv.remediation_deadline < CURRENT_DATE 
               THEN (CURRENT_DATE - cv.remediation_deadline)::INTEGER
               ELSE NULL
           END as days_overdue,
           cv.fine_amount, cv.issuing_authority
    FROM compliance_violations cv
    WHERE cv.venue_id = p_venue_id
    AND cv.violation_status = 'open'
    AND (p_severity IS NULL OR cv.severity = p_severity)
    ORDER BY cv.severity DESC, cv.remediation_deadline NULLS LAST;
END;
$$;



--
-- Name: get_ownership_chain(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_ownership_chain(p_ticket_id uuid) RETURNS TABLE(owner_user_id uuid, owner_name character varying, ownership_type character varying, owned_from timestamp with time zone, owned_until timestamp with time zone, price_paid numeric, is_current boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        toh.owner_user_id,
        u.first_name || ' ' || u.last_name as owner_name,
        toh.ownership_type,
        toh.owned_from,
        toh.owned_until,
        toh.price_paid,
        toh.is_current_owner
    FROM ticket_ownership_history toh
    JOIN users u ON toh.owner_user_id = u.id
    WHERE toh.ticket_id = p_ticket_id
    ORDER BY toh.owned_from;
END;
$$;



--
-- Name: get_recent_integration_errors(uuid, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_recent_integration_errors(p_venue_id uuid, p_hours_back integer DEFAULT 24, p_limit integer DEFAULT 50) RETURNS TABLE(integration_name character varying, provider_name character varying, error_message text, error_code character varying, error_time timestamp with time zone, endpoint_url text)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT vi.integration_name, vi.provider_name, il.log_message,
           il.error_code, il.created_at, il.endpoint_url
    FROM integration_logs il
    JOIN venue_integrations vi ON il.integration_id = vi.id
    WHERE il.venue_id = p_venue_id
    AND il.log_level IN ('error', 'fatal')
    AND il.created_at > NOW() - INTERVAL '1 hour' * p_hours_back
    ORDER BY il.created_at DESC
    LIMIT p_limit;
END;
$$;



--
-- Name: get_schedule_details(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_schedule_details(p_schedule_id uuid) RETURNS TABLE(schedule_id uuid, event_id uuid, start_datetime timestamp with time zone, end_datetime timestamp with time zone, schedule_type public.schedule_type, schedule_status public.schedule_status, venue_id uuid, activities jsonb, conflicts jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT es.id, es.event_id, es.start_datetime, es.end_datetime,
           es.schedule_type, es.schedule_status, es.venue_id,
           COALESCE(
               (SELECT jsonb_agg(
                   jsonb_build_object(
                       'activity_name', sa.activity_name,
                       'activity_type', sa.activity_type,
                       'scheduled_start_time', sa.scheduled_start_time,
                       'scheduled_end_time', sa.scheduled_end_time,
                       'activity_order', sa.activity_order,
                       'is_critical', sa.is_critical
                   ) ORDER BY sa.activity_order
               ) FROM schedule_activities sa WHERE sa.schedule_id = es.id),
               '[]'::jsonb
           ) as activities,
           COALESCE(
               (SELECT jsonb_agg(
                   jsonb_build_object(
                       'conflict_type', sc.conflict_type,
                       'conflict_start', sc.conflict_start,
                       'conflict_end', sc.conflict_end,
                       'conflict_status', sc.conflict_status,
                       'severity', sc.severity
                   )
               ) FROM schedule_conflicts sc 
               WHERE sc.primary_schedule_id = es.id AND sc.conflict_status = 'unresolved'),
               '[]'::jsonb
           ) as conflicts
    FROM event_schedules es
    WHERE es.id = p_schedule_id;
END;
$$;



--
-- Name: get_seats_by_pricing_tier(uuid, public.pricing_tier); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_seats_by_pricing_tier(p_layout_id uuid, p_pricing_tier public.pricing_tier) RETURNS TABLE(section_name character varying, seat_count bigint, accessible_seats bigint, min_price numeric, max_price numeric, avg_price numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT ls_sect.section_name,
           COUNT(ls_seat.id) as seat_count,
           COUNT(ls_seat.id) FILTER (WHERE ls_seat.is_accessible = TRUE) as accessible_seats,
           MIN(ls_seat.base_price) as min_price,
           MAX(ls_seat.base_price) as max_price,
           AVG(ls_seat.base_price) as avg_price
    FROM layout_sections ls_sect
    JOIN layout_seats ls_seat ON ls_sect.id = ls_seat.section_id
    WHERE ls_sect.layout_id = p_layout_id
    AND ls_seat.pricing_tier = p_pricing_tier
    AND ls_seat.is_active = TRUE
    AND ls_seat.is_saleable = TRUE
    GROUP BY ls_sect.section_name
    ORDER BY ls_sect.section_name;
END;
$$;



--
-- Name: get_staff_performance_summary(uuid, date, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_staff_performance_summary(p_venue_id uuid, p_period_start date DEFAULT (CURRENT_DATE - '30 days'::interval), p_period_end date DEFAULT CURRENT_DATE) RETURNS TABLE(staff_name character varying, staff_role public.staff_role, total_shifts integer, total_hours numeric, no_shows integer, tardiness integer, performance_rating integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT CONCAT(u.first_name, ' ', u.last_name) as staff_name,
           vs.staff_role,
           COUNT(ss.id)::INTEGER as total_shifts,
           COALESCE(SUM(ss.hours_worked), 0) as total_hours,
           vs.no_show_count,
           vs.tardy_count,
           vs.performance_rating
    FROM venue_staff vs
    JOIN users u ON vs.user_id = u.id
    LEFT JOIN staff_schedules ss ON vs.id = ss.venue_staff_id 
        AND ss.schedule_date BETWEEN p_period_start AND p_period_end
        AND ss.schedule_status = 'completed'
    WHERE vs.venue_id = p_venue_id
    AND vs.employment_status = 'active'
    GROUP BY vs.id, u.first_name, u.last_name, vs.staff_role, 
             vs.no_show_count, vs.tardy_count, vs.performance_rating
    ORDER BY total_hours DESC;
END;
$$;



--
-- Name: get_staff_schedule(uuid, date, date, public.staff_role); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_staff_schedule(p_venue_id uuid, p_start_date date, p_end_date date, p_staff_role public.staff_role DEFAULT NULL::public.staff_role) RETURNS TABLE(schedule_id uuid, staff_name character varying, staff_role public.staff_role, schedule_date date, start_time time without time zone, end_time time without time zone, assigned_position character varying, assigned_area character varying, schedule_status character varying)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT ss.id, CONCAT(u.first_name, ' ', u.last_name) as staff_name,
           vs.staff_role, ss.schedule_date, ss.start_time, ss.end_time,
           ss.assigned_position, ss.assigned_area, ss.schedule_status
    FROM staff_schedules ss
    JOIN venue_staff vs ON ss.venue_staff_id = vs.id
    JOIN users u ON vs.user_id = u.id
    WHERE ss.venue_id = p_venue_id
    AND ss.schedule_date BETWEEN p_start_date AND p_end_date
    AND (p_staff_role IS NULL OR vs.staff_role = p_staff_role)
    ORDER BY ss.schedule_date, ss.start_time, vs.staff_role;
END;
$$;



--
-- Name: get_ticket_type_hierarchy(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_ticket_type_hierarchy(p_event_id uuid) RETURNS TABLE(ticket_type_id uuid, type_name character varying, ticket_tier character varying, tier_priority integer, base_price numeric, available_quantity integer, status character varying, benefits_count bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        tt.id,
        tt.type_name,
        tt.ticket_tier,
        tt.tier_priority,
        tt.base_price,
        tt.available_quantity,
        tt.status,
        COUNT(ttb.id) as benefits_count
    FROM ticket_types tt
    LEFT JOIN ticket_type_benefits ttb ON tt.id = ttb.ticket_type_id
    WHERE tt.event_id = p_event_id
      AND tt.status != 'DISCONTINUED'
      AND tt.is_hidden = false
    GROUP BY tt.id, tt.type_name, tt.ticket_tier, tt.tier_priority, tt.base_price, tt.available_quantity, tt.status
    ORDER BY tt.tier_priority, tt.base_price;
END;
$$;



--
-- Name: get_trending_categories(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_trending_categories(p_limit integer DEFAULT 10) RETURNS TABLE(category_id uuid, category_name character varying, trending_score numeric, trend_direction character varying)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ec.id,
        ec.category_name,
        ect.trending_score,
        ect.trend_direction
    FROM event_categories ec
    JOIN event_category_trending ect ON ec.id = ect.category_id
    WHERE ect.trending_period = 'DAILY'
      AND ect.period_start >= CURRENT_DATE - INTERVAL '1 day'
      AND ec.is_active = true
    ORDER BY ect.trending_score DESC
    LIMIT p_limit;
END;
$$;



--
-- Name: get_upcoming_events(uuid, public.event_category, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_upcoming_events(p_venue_id uuid DEFAULT NULL::uuid, p_category public.event_category DEFAULT NULL::public.event_category, p_days_ahead integer DEFAULT 30, p_limit integer DEFAULT 50) RETURNS TABLE(event_id uuid, event_name character varying, event_category public.event_category, event_date date, event_time time without time zone, venue_id uuid, event_status public.event_status, total_tickets_sold integer, headliner_name character varying)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT e.id, e.event_name, e.event_category, e.event_date, e.event_time,
           e.venue_id, e.event_status, e.total_tickets_sold,
           ep.performer_name as headliner_name
    FROM events e
    LEFT JOIN event_performers ep ON e.id = ep.event_id AND ep.headliner = TRUE
    WHERE e.deleted_at IS NULL
    AND e.event_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '1 day' * p_days_ahead
    AND (p_venue_id IS NULL OR e.venue_id = p_venue_id)
    AND (p_category IS NULL OR e.event_category = p_category)
    AND e.event_status IN ('published', 'on_sale', 'sold_out')
    ORDER BY e.event_date, e.event_time
    LIMIT p_limit;
END;
$$;



--
-- Name: get_upcoming_schedules(uuid, uuid, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_upcoming_schedules(p_venue_id uuid DEFAULT NULL::uuid, p_event_id uuid DEFAULT NULL::uuid, p_days_ahead integer DEFAULT 30, p_limit integer DEFAULT 50) RETURNS TABLE(schedule_id uuid, event_id uuid, event_name character varying, start_datetime timestamp with time zone, end_datetime timestamp with time zone, venue_id uuid, schedule_status public.schedule_status, tickets_available integer, activity_count bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT es.id, es.event_id, e.event_name, es.start_datetime, es.end_datetime,
           es.venue_id, es.schedule_status, es.tickets_available,
           COALESCE(sa.activity_count, 0) as activity_count
    FROM event_schedules es
    JOIN events e ON es.event_id = e.id
    LEFT JOIN (
        SELECT schedule_id, COUNT(*) as activity_count
        FROM schedule_activities
        GROUP BY schedule_id
    ) sa ON es.id = sa.schedule_id
    WHERE es.start_datetime BETWEEN NOW() AND NOW() + INTERVAL '1 day' * p_days_ahead
    AND (p_venue_id IS NULL OR es.venue_id = p_venue_id)
    AND (p_event_id IS NULL OR es.event_id = p_event_id)
    AND es.schedule_status IN ('confirmed', 'published', 'tentative')
    ORDER BY es.start_datetime
    LIMIT p_limit;
END;
$$;



--
-- Name: get_user_active_sessions(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_user_active_sessions(p_user_id uuid) RETURNS TABLE(session_id uuid, created_at timestamp with time zone, last_activity_at timestamp with time zone, ip_address inet, device_type public.device_type, device_name character varying, browser_name character varying, location text, is_current boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT s.id, s.created_at, s.last_activity_at, s.ip_address,
           s.device_type, s.device_name, s.browser_name,
           COALESCE(s.city || ', ' || s.region || ', ' || s.country_code, 'Unknown') as location,
           (s.last_activity_at > NOW() - INTERVAL '5 minutes') as is_current
    FROM sessions s
    WHERE s.user_id = p_user_id
    AND s.session_status = 'active'
    AND s.expires_at > NOW()
    ORDER BY s.last_activity_at DESC;
END;
$$;



--
-- Name: get_user_audit_trail(uuid, timestamp with time zone, timestamp with time zone, public.audit_category, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_user_audit_trail(p_user_id uuid, p_start_date timestamp with time zone DEFAULT (now() - '30 days'::interval), p_end_date timestamp with time zone DEFAULT now(), p_category public.audit_category DEFAULT NULL::public.audit_category, p_limit integer DEFAULT 100) RETURNS TABLE(id uuid, created_at timestamp with time zone, category public.audit_category, action public.audit_action, entity_type character varying, entity_name character varying, event_description text, severity public.audit_severity, ip_address inet)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT al.id, al.created_at, al.category, al.action, al.entity_type,
           al.entity_name, al.event_description, al.severity, al.ip_address
    FROM audit_logs al
    WHERE al.user_id = p_user_id
    AND al.created_at BETWEEN p_start_date AND p_end_date
    AND (p_category IS NULL OR al.category = p_category)
    AND al.is_archived = FALSE
    ORDER BY al.created_at DESC
    LIMIT p_limit;
END;
$$;



--
-- Name: get_user_permissions(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_user_permissions(p_user_id uuid) RETURNS TABLE(permission_name character varying, display_name character varying, category public.permission_category, resource character varying, action public.permission_action, scope public.permission_scope, source character varying, venue_id uuid, event_id uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    -- Direct user permissions
    SELECT p.permission_name, p.display_name, p.category, p.resource, 
           p.action, p.scope, 'direct'::VARCHAR(20) as source,
           up.venue_id, up.event_id
    FROM user_permissions up
    JOIN permissions p ON up.permission_id = p.id
    WHERE up.user_id = p_user_id
    AND up.is_granted = true
    AND up.is_active = true
    AND (up.expires_at IS NULL OR up.expires_at > NOW())
    AND p.is_active = true
    AND p.deleted_at IS NULL
    
    UNION
    
    -- Role-based permissions
    SELECT p.permission_name, p.display_name, p.category, p.resource,
           p.action, p.scope, 'role'::VARCHAR(20) as source,
           rp.venue_id, rp.event_id
    FROM user_roles ur
    JOIN role_permissions rp ON ur.role_id = rp.role_id
    JOIN permissions p ON rp.permission_id = p.id
    WHERE ur.user_id = p_user_id
    AND ur.is_active = true
    AND (ur.expires_at IS NULL OR ur.expires_at > NOW())
    AND p.is_active = true
    AND p.deleted_at IS NULL
    -- Exclude if user has explicit deny for this permission
    AND NOT EXISTS (
        SELECT 1 FROM user_permissions up2
        WHERE up2.user_id = p_user_id
        AND up2.permission_id = p.id
        AND up2.is_granted = false
        AND up2.is_active = true
        AND (up2.expires_at IS NULL OR up2.expires_at > NOW())
    )
    
    ORDER BY permission_name, source;
END;
$$;



--
-- Name: get_user_roles(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_user_roles(p_user_id uuid) RETURNS TABLE(role_id uuid, role_name character varying, display_name character varying, permission_level public.role_permission_level, venue_id uuid, event_id uuid, assigned_at timestamp with time zone, expires_at timestamp with time zone)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT r.id, r.role_name, r.display_name, r.permission_level,
           ur.venue_id, ur.event_id, ur.assigned_at, ur.expires_at
    FROM user_roles ur
    JOIN roles r ON ur.role_id = r.id
    WHERE ur.user_id = p_user_id
    AND ur.is_active = true
    AND (ur.expires_at IS NULL OR ur.expires_at > NOW())
    AND r.role_status = 'active'
    AND r.deleted_at IS NULL
    ORDER BY r.role_priority DESC, r.permission_level;
END;
$$;



--
-- Name: get_venue_blackout_dates(uuid, date, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_venue_blackout_dates(p_venue_id uuid, p_start_date date DEFAULT CURRENT_DATE, p_end_date date DEFAULT (CURRENT_DATE + '1 year'::interval)) RETURNS TABLE(blackout_name character varying, start_date date, end_date date, blackout_type character varying, restrictions jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT vbd.blackout_name, vbd.start_date, vbd.end_date, 
           vbd.blackout_type, vbd.restrictions
    FROM venue_blackout_dates vbd
    WHERE vbd.venue_id = p_venue_id
    AND vbd.start_date <= p_end_date
    AND vbd.end_date >= p_start_date
    ORDER BY vbd.start_date;
END;
$$;



--
-- Name: get_venue_details(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_venue_details(p_venue_id uuid) RETURNS TABLE(id uuid, venue_name character varying, venue_type public.venue_type, full_description text, address_line_1 character varying, address_line_2 character varying, city character varying, state_province character varying, country_code character, latitude numeric, longitude numeric, total_capacity integer, seated_capacity integer, standing_capacity integer, venue_status public.venue_status, verification_status public.verification_status, average_rating numeric, total_events_hosted integer, amenities jsonb, contact_info jsonb, operating_hours jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT v.id, v.venue_name, v.venue_type, v.full_description,
           v.address_line_1, v.address_line_2, v.city, v.state_province, v.country_code,
           v.latitude, v.longitude, v.total_capacity, v.seated_capacity, v.standing_capacity,
           v.venue_status, v.verification_status, v.average_rating, v.total_events_hosted,
           v.amenities,
           jsonb_build_object(
               'primary_phone', v.primary_phone,
               'primary_email', v.primary_email,
               'website_url', v.website_url,
               'contact_person_name', v.contact_person_name,
               'contact_person_phone', v.contact_person_phone,
               'contact_person_email', v.contact_person_email
           ) as contact_info,
           COALESCE(
               (SELECT jsonb_agg(
                   jsonb_build_object(
                       'day_of_week', voh.day_of_week,
                       'is_open', voh.is_open,
                       'open_time', voh.open_time,
                       'close_time', voh.close_time,
                       'is_24_hours', voh.is_24_hours
                   )
               ) FROM venue_operating_hours voh 
               WHERE voh.venue_id = v.id 
               AND (voh.effective_until IS NULL OR voh.effective_until >= CURRENT_DATE)),
               '[]'::jsonb
           ) as operating_hours
    FROM venues v
    WHERE v.id = p_venue_id
    AND v.deleted_at IS NULL;
END;
$$;



--
-- Name: get_venue_pricing_rules(uuid, jsonb, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_venue_pricing_rules(p_venue_id uuid, p_conditions jsonb DEFAULT '{}'::jsonb, p_effective_date timestamp with time zone DEFAULT now()) RETURNS TABLE(rule_name character varying, rule_type character varying, base_price numeric, price_modifier_type character varying, price_modifier_value numeric, fees jsonb, priority integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT vpr.rule_name, vpr.rule_type, vpr.base_price,
           vpr.price_modifier_type, vpr.price_modifier_value,
           vpr.fees, vpr.priority
    FROM venue_pricing_rules vpr
    WHERE vpr.venue_id = p_venue_id
    AND vpr.is_active = TRUE
    AND p_effective_date BETWEEN vpr.effective_from AND COALESCE(vpr.effective_until, 'infinity'::timestamptz)
    AND (p_conditions IS NULL OR vpr.conditions @> p_conditions)
    ORDER BY vpr.priority DESC, vpr.created_at;
END;
$$;



--
-- Name: get_venue_setting(uuid, character varying, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_venue_setting(p_venue_id uuid, p_setting_key character varying, p_default_value text DEFAULT NULL::text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    setting_value TEXT;
BEGIN
    SELECT 
        CASE 
            WHEN vs.is_sensitive = TRUE AND vs.setting_value_encrypted IS NOT NULL THEN
                pgp_sym_decrypt(vs.setting_value_encrypted, 'venue_settings_key')
            WHEN vs.setting_value_json IS NOT NULL THEN
                vs.setting_value_json::text
            ELSE 
                vs.setting_value
        END
    INTO setting_value
    FROM venue_settings vs
    WHERE vs.venue_id = p_venue_id
    AND vs.setting_key = p_setting_key
    AND vs.is_active = TRUE;
    
    RETURN COALESCE(setting_value, p_default_value);
END;
$$;



--
-- Name: get_venue_settings_by_category(uuid, public.setting_category); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_venue_settings_by_category(p_venue_id uuid, p_category public.setting_category) RETURNS TABLE(setting_key character varying, setting_name character varying, setting_value text, data_type public.setting_data_type, is_required boolean, is_readonly boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT vs.setting_key, vs.setting_name,
           CASE 
               WHEN vs.is_sensitive = TRUE AND vs.setting_value_encrypted IS NOT NULL THEN
                   '[ENCRYPTED]'
               WHEN vs.setting_value_json IS NOT NULL THEN
                   vs.setting_value_json::text
               ELSE 
                   vs.setting_value
           END as setting_value,
           vs.data_type, vs.is_required, vs.is_readonly
    FROM venue_settings vs
    WHERE vs.venue_id = p_venue_id
    AND vs.category = p_category
    AND vs.is_active = TRUE
    ORDER BY vs.display_order, vs.setting_key;
END;
$$;



--
-- Name: get_venue_staff_by_role(uuid, public.staff_role, public.employment_status); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_venue_staff_by_role(p_venue_id uuid, p_staff_role public.staff_role DEFAULT NULL::public.staff_role, p_employment_status public.employment_status DEFAULT 'active'::public.employment_status) RETURNS TABLE(staff_id uuid, user_id uuid, employee_id character varying, staff_role public.staff_role, job_title character varying, employment_status public.employment_status, hire_date date, access_level public.access_level)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT vs.id, vs.user_id, vs.employee_id, vs.staff_role, vs.job_title,
           vs.employment_status, vs.hire_date, vs.access_level
    FROM venue_staff vs
    WHERE vs.venue_id = p_venue_id
    AND (p_staff_role IS NULL OR vs.staff_role = p_staff_role)
    AND vs.employment_status = p_employment_status
    ORDER BY vs.staff_role, vs.hire_date;
END;
$$;



--
-- Name: get_venue_statistics(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_venue_statistics() RETURNS TABLE(total_venues bigint, active_venues bigint, verified_venues bigint, pending_approval bigint, venues_by_type jsonb, venues_by_country jsonb, average_capacity numeric, total_capacity bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*) as total_venues,
        COUNT(*) FILTER (WHERE venue_status = 'active') as active_venues,
        COUNT(*) FILTER (WHERE verification_status = 'verified') as verified_venues,
        COUNT(*) FILTER (WHERE venue_status = 'pending_approval') as pending_approval,
        (SELECT jsonb_object_agg(venue_type, cnt) 
         FROM (SELECT venue_type, COUNT(*) as cnt FROM venues WHERE deleted_at IS NULL GROUP BY venue_type) t) as venues_by_type,
        (SELECT jsonb_object_agg(country_code, cnt) 
         FROM (SELECT country_code, COUNT(*) as cnt FROM venues WHERE deleted_at IS NULL GROUP BY country_code) t) as venues_by_country,
        AVG(total_capacity) as average_capacity,
        SUM(total_capacity) as total_capacity
    FROM venues
    WHERE deleted_at IS NULL;
END;
$$;



--
-- Name: grant_role_permission(uuid, uuid, uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.grant_role_permission(p_role_id uuid, p_permission_id uuid, p_granted_by_user_id uuid DEFAULT NULL::uuid, p_venue_id uuid DEFAULT NULL::uuid, p_event_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    assignment_id UUID;
BEGIN
    INSERT INTO role_permissions (
        role_id, permission_id, granted_by_user_id, venue_id, event_id
    )
    VALUES (
        p_role_id, p_permission_id, p_granted_by_user_id, p_venue_id, p_event_id
    )
    ON CONFLICT (role_id, permission_id, venue_id, event_id) DO NOTHING
    RETURNING id INTO assignment_id;
    
    RETURN assignment_id;
END;
$$;



--
-- Name: grant_user_permission(uuid, uuid, boolean, uuid, uuid, uuid, timestamp with time zone, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.grant_user_permission(p_user_id uuid, p_permission_id uuid, p_is_granted boolean, p_granted_by_user_id uuid DEFAULT NULL::uuid, p_venue_id uuid DEFAULT NULL::uuid, p_event_id uuid DEFAULT NULL::uuid, p_expires_at timestamp with time zone DEFAULT NULL::timestamp with time zone, p_reason text DEFAULT NULL::text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    assignment_id UUID;
BEGIN
    INSERT INTO user_permissions (
        user_id, permission_id, is_granted, granted_by_user_id,
        venue_id, event_id, expires_at, reason
    )
    VALUES (
        p_user_id, p_permission_id, p_is_granted, p_granted_by_user_id,
        p_venue_id, p_event_id, p_expires_at, p_reason
    )
    ON CONFLICT (user_id, permission_id, venue_id, event_id) 
    DO UPDATE SET
        is_granted = EXCLUDED.is_granted,
        granted_by_user_id = EXCLUDED.granted_by_user_id,
        expires_at = EXCLUDED.expires_at,
        reason = EXCLUDED.reason,
        updated_at = NOW()
    RETURNING id INTO assignment_id;
    
    RETURN assignment_id;
END;
$$;



--
-- Name: hash_password(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.hash_password(p_password text) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
    v_salt TEXT;
    v_hash TEXT;
BEGIN
    -- Generate random salt
    v_salt := gen_salt('bf', 12); -- bcrypt with cost factor 12
    
    -- Hash password with salt
    -- In production, use pgcrypto's crypt function
    -- For demo, using simple hash
    v_hash := encode(digest(v_salt || p_password, 'sha256'), 'hex');
    
    -- Return salt and hash combined
    RETURN v_salt || '$' || v_hash;
END;
$_$;



--
-- Name: FUNCTION hash_password(p_password text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.hash_password(p_password text) IS 'Hashes password using bcrypt';


--
-- Name: increment_referral_count(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.increment_referral_count() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   IF NEW.referred_by IS NOT NULL AND NEW.email_verified = TRUE AND OLD.email_verified = FALSE THEN
       UPDATE public.users 
       SET referral_count = referral_count + 1 
       WHERE id = NEW.referred_by;
   END IF;
   RETURN NEW;
END;
$$;



--
-- Name: is_email_available(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.is_email_available(check_email character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
   RETURN NOT EXISTS (
       SELECT 1 FROM public.users 
       WHERE email = check_email 
       AND deleted_at IS NULL
   );
END;
$$;



--
-- Name: is_username_available(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.is_username_available(check_username character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
   RETURN NOT EXISTS (
       SELECT 1 FROM public.users 
       WHERE username = check_username 
       AND deleted_at IS NULL
   );
END;
$$;



--
-- Name: is_venue_available(uuid, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.is_venue_available(p_venue_id uuid, p_start_time timestamp with time zone, p_end_time timestamp with time zone) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN TRUE; -- Placeholder
END;
$$;



--
-- Name: is_venue_blackout_date(uuid, date, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.is_venue_blackout_date(p_venue_id uuid, p_check_date date, p_blackout_type character varying DEFAULT NULL::character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN EXISTS(
        SELECT 1 FROM venue_blackout_dates vbd
        WHERE vbd.venue_id = p_venue_id
        AND p_check_date BETWEEN vbd.start_date AND vbd.end_date
        AND (p_blackout_type IS NULL OR vbd.blackout_type = p_blackout_type)
    );
END;
$$;



--
-- Name: log_audit_event(uuid, public.audit_category, public.audit_action, character varying, character varying, character varying, text, jsonb, jsonb, public.audit_severity, inet, text, uuid, character varying, jsonb); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.log_audit_event(p_user_id uuid, p_category public.audit_category, p_action public.audit_action, p_entity_type character varying, p_entity_id character varying DEFAULT NULL::character varying, p_entity_name character varying DEFAULT NULL::character varying, p_event_description text DEFAULT NULL::text, p_before_data jsonb DEFAULT NULL::jsonb, p_after_data jsonb DEFAULT NULL::jsonb, p_severity public.audit_severity DEFAULT 'info'::public.audit_severity, p_ip_address inet DEFAULT NULL::inet, p_user_agent text DEFAULT NULL::text, p_session_id uuid DEFAULT NULL::uuid, p_request_id character varying DEFAULT NULL::character varying, p_additional_data jsonb DEFAULT NULL::jsonb) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    audit_log_id UUID;
    calculated_changed_fields TEXT[];
BEGIN
    -- Calculate changed fields if before and after data provided
    IF p_before_data IS NOT NULL AND p_after_data IS NOT NULL THEN
        SELECT array_agg(key) INTO calculated_changed_fields
        FROM (
            SELECT key FROM jsonb_each(p_before_data)
            EXCEPT
            SELECT key FROM jsonb_each(p_after_data)
            UNION
            SELECT key FROM jsonb_each(p_after_data)
            EXCEPT  
            SELECT key FROM jsonb_each(p_before_data)
            UNION
            SELECT b.key FROM jsonb_each(p_before_data) b
            JOIN jsonb_each(p_after_data) a ON b.key = a.key
            WHERE b.value != a.value
        ) changed;
    END IF;
    
    -- Insert audit log record
    INSERT INTO audit_logs (
        user_id, category, action, entity_type, entity_id, entity_name,
        event_description, before_data, after_data, changed_fields,
        severity, ip_address, user_agent, session_id, request_id,
        event_details
    ) VALUES (
        p_user_id, p_category, p_action, p_entity_type, p_entity_id, p_entity_name,
        COALESCE(p_event_description, p_action::text || ' ' || p_entity_type),
        p_before_data, p_after_data, calculated_changed_fields,
        p_severity, p_ip_address, p_user_agent, p_session_id, p_request_id,
        p_additional_data
    ) RETURNING id INTO audit_log_id;
    
    RETURN audit_log_id;
END;
$$;



--
-- Name: log_integration_activity(uuid, character varying, character varying, text, character varying, character varying, text, integer, integer, character varying, jsonb); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.log_integration_activity(p_integration_id uuid, p_log_level character varying, p_log_type character varying, p_log_message text, p_request_id character varying DEFAULT NULL::character varying, p_http_method character varying DEFAULT NULL::character varying, p_endpoint_url text DEFAULT NULL::text, p_response_status integer DEFAULT NULL::integer, p_response_time_ms integer DEFAULT NULL::integer, p_error_code character varying DEFAULT NULL::character varying, p_additional_context jsonb DEFAULT NULL::jsonb) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    log_id UUID;
    v_venue_id UUID;
BEGIN
    -- Get venue ID
    SELECT venue_id INTO v_venue_id FROM venue_integrations WHERE id = p_integration_id;
    
    INSERT INTO integration_logs (
        integration_id, venue_id, log_level, log_type, log_message,
        request_id, http_method, endpoint_url, response_status,
        response_time_ms, error_code, additional_context
    )
    VALUES (
        p_integration_id, v_venue_id, p_log_level, p_log_type, p_log_message,
        p_request_id, p_http_method, p_endpoint_url, p_response_status,
        p_response_time_ms, p_error_code, p_additional_context
    )
    RETURNING id INTO log_id;
    
    -- Update integration metrics
    IF p_log_level IN ('error', 'fatal') THEN
        UPDATE venue_integrations
        SET consecutive_errors = consecutive_errors + 1,
            error_count_24h = error_count_24h + 1,
            last_error_message = p_log_message,
            last_error_at = NOW()
        WHERE id = p_integration_id;
    ELSE
        UPDATE venue_integrations
        SET consecutive_errors = 0,
            total_requests = total_requests + 1,
            successful_requests = CASE WHEN p_response_status BETWEEN 200 AND 299 THEN successful_requests + 1 ELSE successful_requests END
        WHERE id = p_integration_id;
    END IF;
    
    RETURN log_id;
END;
$$;



--
-- Name: log_pricing_changes(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.log_pricing_changes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF OLD.base_price != NEW.base_price THEN
        INSERT INTO event_pricing_history (
            event_pricing_id, tier_id, change_type, old_price, new_price,
            price_change, percentage_change, reason
        ) VALUES (
            NEW.event_pricing_id, NEW.id, 'PRICE_UPDATE',
            OLD.base_price, NEW.base_price,
            NEW.base_price - OLD.base_price,
            ((NEW.base_price - OLD.base_price) / OLD.base_price) * 100,
            'Price updated'
        );
    END IF;
    RETURN NEW;
END;
$$;



--
-- Name: manage_default_payment_method(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.manage_default_payment_method() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- If setting a new default, unset other defaults for the user
    IF NEW.is_default = TRUE AND NEW.deleted_at IS NULL THEN
        UPDATE payment_methods 
        SET is_default = FALSE 
        WHERE user_id = NEW.user_id 
        AND id != NEW.id 
        AND deleted_at IS NULL;
    END IF;
    
    -- Check card expiration and update status
    IF NEW.payment_type IN ('credit_card', 'debit_card') AND NEW.exp_year IS NOT NULL AND NEW.exp_month IS NOT NULL THEN
        IF (NEW.exp_year < EXTRACT(YEAR FROM CURRENT_DATE)) OR 
           (NEW.exp_year = EXTRACT(YEAR FROM CURRENT_DATE) AND NEW.exp_month < EXTRACT(MONTH FROM CURRENT_DATE)) THEN
            NEW.status = 'expired';
            NEW.status_reason = 'Card expired';
        END IF;
    END IF;
    
    -- Increment usage count on successful use
    IF NEW.last_used_at IS NOT NULL AND OLD.last_used_at IS DISTINCT FROM NEW.last_used_at THEN
        NEW.usage_count = COALESCE(OLD.usage_count, 0) + 1;
    END IF;
    
    -- Increment failed attempts on failure
    IF NEW.last_failed_at IS NOT NULL AND OLD.last_failed_at IS DISTINCT FROM NEW.last_failed_at THEN
        NEW.failed_attempts = COALESCE(OLD.failed_attempts, 0) + 1;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: manage_invoice_status(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.manage_invoice_status() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Handle status transitions
    IF TG_OP = 'UPDATE' AND NEW.status != OLD.status THEN
        CASE NEW.status
            WHEN 'open' THEN
                IF NEW.finalized_at IS NULL THEN
                    NEW.finalized_at = CURRENT_TIMESTAMP;
                END IF;
                -- Set due date if not already set
                IF NEW.due_date IS NULL THEN
                    NEW.due_date = CURRENT_DATE + INTERVAL '30 days';
                END IF;
                
            WHEN 'paid' THEN
                NEW.paid_at = CURRENT_TIMESTAMP;
                NEW.amount_paid = NEW.total_amount;
                
            WHEN 'void' THEN
                NEW.voided_at = CURRENT_TIMESTAMP;
                
            WHEN 'overdue' THEN
                -- Automatically set when due date passes
                NULL;
        END CASE;
    END IF;
    
    -- Check if invoice should be marked as overdue
    IF NEW.status = 'open' AND NEW.due_date < CURRENT_DATE THEN
        NEW.status = 'overdue';
    END IF;
    
    -- Update payment status based on amount paid
    IF NEW.amount_paid > 0 AND NEW.amount_paid < NEW.total_amount THEN
        NEW.status = 'partially_paid';
    ELSIF NEW.amount_paid >= NEW.total_amount AND NEW.status NOT IN ('void', 'uncollectible') THEN
        NEW.status = 'paid';
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: manage_report_generation(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.manage_report_generation() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Handle status transitions
    IF TG_OP = 'UPDATE' AND NEW.generation_status != OLD.generation_status THEN
        CASE NEW.generation_status
            WHEN 'processing' THEN
                -- Reset progress
                NEW.generation_progress = 0;
                
            WHEN 'completed' THEN
                NEW.generated_at = CURRENT_TIMESTAMP;
                NEW.generation_progress = 100;
                -- Calculate generation duration
                IF OLD.generation_status = 'processing' THEN
                    NEW.generation_duration_seconds = EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - OLD.last_modified_at));
                END IF;
                -- Set expiration if not set
                IF NEW.expires_at IS NULL THEN
                    NEW.expires_at = CURRENT_TIMESTAMP + INTERVAL '1 year';
                END IF;
                
            WHEN 'failed' THEN
                -- Ensure error message is set
                IF NEW.generation_error IS NULL THEN
                    NEW.generation_error = 'Unknown error occurred';
                END IF;
        END CASE;
        
        NEW.last_modified_at = CURRENT_TIMESTAMP;
    END IF;
    
    -- Update last accessed timestamp when report is viewed
    IF TG_OP = 'UPDATE' AND 
       NEW.generation_status = 'completed' AND 
       (NEW.report_pdf_url != OLD.report_pdf_url OR 
        NEW.report_csv_url != OLD.report_csv_url OR 
        NEW.report_excel_url != OLD.report_excel_url) THEN
        NEW.last_accessed_at = CURRENT_TIMESTAMP;
    END IF;
    
    -- Handle recurring reports
    IF NEW.is_recurring AND NEW.generation_status = 'completed' THEN
        -- Calculate next generation date based on report type
        CASE NEW.report_type
            WHEN 'daily' THEN
                NEW.next_generation_date = CURRENT_TIMESTAMP + INTERVAL '1 day';
            WHEN 'weekly' THEN
                NEW.next_generation_date = CURRENT_TIMESTAMP + INTERVAL '1 week';
            WHEN 'monthly' THEN
                NEW.next_generation_date = CURRENT_TIMESTAMP + INTERVAL '1 month';
            WHEN 'quarterly' THEN
                NEW.next_generation_date = CURRENT_TIMESTAMP + INTERVAL '3 months';
            WHEN 'annual' THEN
                NEW.next_generation_date = CURRENT_TIMESTAMP + INTERVAL '1 year';
        END CASE;
        NEW.last_generation_date = CURRENT_TIMESTAMP;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: manage_subscription_lifecycle(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.manage_subscription_lifecycle() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Handle status transitions
    IF TG_OP = 'UPDATE' AND NEW.status != OLD.status THEN
        NEW.previous_status = OLD.status;
        
        CASE NEW.status
            WHEN 'active' THEN
                IF NEW.activated_at IS NULL THEN
                    NEW.activated_at = CURRENT_TIMESTAMP;
                END IF;
                NEW.failed_payment_count = 0;
                
            WHEN 'cancelled' THEN
                IF NEW.cancelled_at IS NULL THEN
                    NEW.cancelled_at = CURRENT_TIMESTAMP;
                END IF;
                
            WHEN 'paused' THEN
                NEW.paused_at = CURRENT_TIMESTAMP;
                
            WHEN 'expired' THEN
                NEW.expired_at = CURRENT_TIMESTAMP;
                
            WHEN 'trialing' THEN
                IF NEW.trial_start IS NULL THEN
                    NEW.trial_start = CURRENT_TIMESTAMP;
                END IF;
                NEW.trial_used = TRUE;
        END CASE;
        
        -- Handle resumption from pause
        IF OLD.status = 'paused' AND NEW.status = 'active' THEN
            NEW.resumed_at = CURRENT_TIMESTAMP;
        END IF;
    END IF;
    
    -- Calculate next billing date based on cycle
    IF NEW.status IN ('active', 'trialing') AND NEW.current_period_end IS NOT NULL THEN
        NEW.next_billing_date = NEW.current_period_end;
    END IF;
    
    -- Track trial conversion
    IF OLD.status = 'trialing' AND NEW.status = 'active' AND NOT NEW.trial_conversion_tracked THEN
        NEW.trial_conversion_tracked = TRUE;
    END IF;
    
    -- Reset usage counters if needed
    IF NEW.usage_reset_date IS NOT NULL AND NEW.usage_reset_date <= CURRENT_TIMESTAMP THEN
        -- Reset usage data (this would be more complex in practice)
        NEW.usage_data = jsonb_set(NEW.usage_data, '{api_calls,used}', '0');
        NEW.usage_data = jsonb_set(NEW.usage_data, '{events_created,used}', '0');
        
        -- Set next reset date based on billing cycle
        CASE NEW.billing_cycle
            WHEN 'monthly' THEN
                NEW.usage_reset_date = NEW.usage_reset_date + INTERVAL '1 month';
            WHEN 'quarterly' THEN
                NEW.usage_reset_date = NEW.usage_reset_date + INTERVAL '3 months';
            WHEN 'annual' THEN
                NEW.usage_reset_date = NEW.usage_reset_date + INTERVAL '1 year';
        END CASE;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: median(numeric[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.median(numeric[]) RETURNS numeric
    LANGUAGE sql IMMUTABLE PARALLEL SAFE
    AS $_$
    SELECT AVG(val)
    FROM (
        SELECT val
        FROM unnest($1) val
        ORDER BY 1
        LIMIT 2 - MOD(array_upper($1, 1), 2)
        OFFSET CEIL(array_upper($1, 1) / 2.0) - 1
    ) sub;
$_$;



--
-- Name: FUNCTION median(numeric[]); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.median(numeric[]) IS 'Calculates median value from numeric array';


--
-- Name: percentile(numeric[], numeric); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.percentile(p_values numeric[], p_percentile numeric) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE PARALLEL SAFE
    AS $$
DECLARE
    v_count INTEGER;
    v_position NUMERIC;
    v_lower INTEGER;
    v_upper INTEGER;
    v_sorted numeric[];
BEGIN
    -- Validate percentile
    IF p_percentile < 0 OR p_percentile > 1 THEN
        RAISE EXCEPTION 'Percentile must be between 0 and 1';
    END IF;
    
    -- Get sorted array
    v_sorted := ARRAY(SELECT unnest(p_values) ORDER BY 1);
    v_count := array_length(v_sorted, 1);
    
    IF v_count = 0 THEN
        RETURN NULL;
    END IF;
    
    -- Calculate position
    v_position := p_percentile * (v_count - 1) + 1;
    v_lower := FLOOR(v_position);
    v_upper := CEIL(v_position);
    
    -- Interpolate if necessary
    IF v_lower = v_upper THEN
        RETURN v_sorted[v_lower];
    ELSE
        RETURN v_sorted[v_lower] + (v_position - v_lower) * (v_sorted[v_upper] - v_sorted[v_lower]);
    END IF;
END;
$$;



--
-- Name: FUNCTION percentile(p_values numeric[], p_percentile numeric); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.percentile(p_values numeric[], p_percentile numeric) IS 'Calculates percentile value from numeric array';


--
-- Name: prepare_nft_metadata(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prepare_nft_metadata(p_ticket_id uuid) RETURNS jsonb
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    v_ticket RECORD;
    v_metadata JSONB;
BEGIN
    -- Get ticket and event details
    SELECT 
        t.id,
        NULL::text AS ticket_type,
        t.seat_number,
        e.name AS event_name,
        e.start_date,
        e.description AS event_description,
        v.name AS venue_name,
        v.city,
        tt.name AS ticket_type_name,
        tt.benefits
    INTO v_ticket
    FROM tickets t
    JOIN events e ON e.id = t.event_id
    JOIN venues v ON v.id = e.venue_id
    LEFT JOIN ticket_types tt ON tt.id = t.ticket_type_id
    WHERE t.id = p_ticket_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Ticket not found';
    END IF;
    
    -- Build Metaplex metadata standard
    v_metadata := jsonb_build_object(
        'name', v_ticket.event_name || ' - ' || COALESCE(v_ticket.ticket_type_name, 'General Admission'),
        'symbol', 'TCKT',
        'description', v_ticket.event_description,
        'image', 'https://arweave.net/placeholder', -- Would be actual image URL
        'animation_url', NULL,
        'external_url', 'https://tickettoken.io/ticket/' || v_ticket.id,
        'attributes', jsonb_build_array(
            jsonb_build_object('trait_type', 'Event', 'value', v_ticket.event_name),
            jsonb_build_object('trait_type', 'Venue', 'value', v_ticket.venue_name),
            jsonb_build_object('trait_type', 'City', 'value', v_ticket.city),
            jsonb_build_object('trait_type', 'Date', 'value', TO_CHAR(v_ticket.start_time, 'YYYY-MM-DD')),
            jsonb_build_object('trait_type', 'Time', 'value', TO_CHAR(v_ticket.start_time, 'HH24:MI')),
            jsonb_build_object('trait_type', 'Type', 'value', COALESCE(v_ticket.ticket_type_name, 'General')),
            jsonb_build_object('trait_type', 'Seat', 'value', COALESCE(v_ticket.seat_number, 'Open Seating'))
        ),
        'properties', jsonb_build_object(
            'category', 'ticket',
            'creators', jsonb_build_array(
                jsonb_build_object(
                    'address', 'venue_wallet_address_placeholder',
                    'share', 100
                )
            )
        )
    );
    
    RETURN v_metadata;
END;
$$;



--
-- Name: FUNCTION prepare_nft_metadata(p_ticket_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.prepare_nft_metadata(p_ticket_id uuid) IS 'Prepares Metaplex-compatible NFT metadata for ticket minting';


--
-- Name: prevent_self_purchase(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prevent_self_purchase() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_seller_id uuid;
BEGIN
  SELECT seller_id INTO v_seller_id
  FROM public.listings
  WHERE id = NEW.listing_id;

  IF v_seller_id IS NULL THEN
    RAISE EXCEPTION 'Listing % not found', NEW.listing_id;
  END IF;

  IF v_seller_id = NEW.buyer_id THEN
    RAISE EXCEPTION 'Cannot purchase your own listing';
  END IF;

  RETURN NEW;
END
$$;



--
-- Name: process_audit_record(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.process_audit_record() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    record_data JSONB;
BEGIN
    -- Set ingestion timestamp
    NEW.ingested_at = NOW();
    
    -- Calculate and set checksum for new records
    IF TG_OP = 'INSERT' THEN
        record_data = jsonb_build_object(
            'id', NEW.id,
            'user_id', NEW.user_id,
            'category', NEW.category,
            'action', NEW.action,
            'entity_type', NEW.entity_type,
            'entity_id', NEW.entity_id,
            'before_data', NEW.before_data,
            'after_data', NEW.after_data,
            'event_description', NEW.event_description,
            'created_at', NEW.created_at
        );
        
        NEW.checksum = calculate_audit_checksum(record_data);
        
        -- Auto-detect anomalous behavior based on patterns
        IF NEW.risk_score >= 70 OR 
           (NEW.severity IN ('error', 'critical') AND NEW.category = 'security') OR
           NEW.ip_address IS DISTINCT FROM (
               SELECT ip_address FROM audit_logs 
               WHERE user_id = NEW.user_id 
               AND created_at > NOW() - INTERVAL '24 hours'
               ORDER BY created_at DESC LIMIT 1
           ) THEN
            NEW.is_anomalous = TRUE;
        END IF;
        
        -- Set compliance flags based on content
        IF NEW.entity_type IN ('user', 'user_data', 'personal_info') OR 
           NEW.event_description ILIKE '%personal%' OR 
           NEW.event_description ILIKE '%privacy%' THEN
            NEW.is_gdpr_relevant = TRUE;
        END IF;
        
        IF NEW.entity_type IN ('payment', 'card', 'financial') OR 
           NEW.category = 'financial' THEN
            NEW.is_pci_relevant = TRUE;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: process_refund_workflow(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.process_refund_workflow() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_original_transaction RECORD;
BEGIN
    -- Get original transaction details if inserting
    IF TG_OP = 'INSERT' THEN
        SELECT * INTO v_original_transaction
        FROM transactions
        WHERE id = NEW.original_transaction_id;
        
        -- Set original transaction details
        NEW.original_amount = v_original_transaction.amount;
        NEW.original_payment_date = v_original_transaction.created_at;
        NEW.stripe_charge_id = v_original_transaction.stripe_charge_id;
        
        -- Set fee information from original transaction
        NEW.original_platform_fee = COALESCE(v_original_transaction.platform_fee, 0);
        NEW.original_processing_fee = COALESCE(v_original_transaction.processing_fee, 0);
        NEW.original_venue_fee = COALESCE(v_original_transaction.venue_commission, 0);
        
        -- Determine if approval is required based on amount
        IF NEW.refund_amount > 100.00 THEN
            NEW.approval_required = TRUE;
            NEW.approval_threshold = 100.00;
        END IF;
        
        -- Check if within policy period (example: 24 hours)
        IF EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - NEW.original_payment_date)) / 3600 > 24 THEN
            NEW.within_policy_period = FALSE;
            IF NOT NEW.manual_override THEN
                NEW.approval_required = TRUE;
            END IF;
        END IF;
    END IF;
    
    -- Handle status changes
    IF TG_OP = 'UPDATE' AND NEW.status != OLD.status THEN
        CASE NEW.status
            WHEN 'approved' THEN
                NEW.approved_at = CURRENT_TIMESTAMP;
                IF NEW.approved_by IS NULL AND NEW.auto_approved THEN
                    NEW.approval_notes = 'Auto-approved by policy rules';
                END IF;
            WHEN 'processing' THEN
                NEW.processing_started_at = CURRENT_TIMESTAMP;
            WHEN 'completed' THEN
                NEW.completed_at = CURRENT_TIMESTAMP;
                -- Update original transaction refund tracking
                UPDATE transactions 
                SET refund_amount = refund_amount + NEW.refund_amount,
                    refund_count = refund_count + 1,
                    is_fully_refunded = (refund_amount + NEW.refund_amount >= amount)
                WHERE id = NEW.original_transaction_id;
            WHEN 'failed' THEN
                NEW.failed_at = CURRENT_TIMESTAMP;
                NEW.retry_count = OLD.retry_count + 1;
            WHEN 'cancelled' THEN
                NEW.cancelled_at = CURRENT_TIMESTAMP;
        END CASE;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: process_scheduled_releases(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.process_scheduled_releases() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_schedule RECORD;
    v_processed_count INTEGER := 0;
BEGIN
    FOR v_schedule IN 
        SELECT * FROM ticket_type_availability_schedules 
        WHERE is_processed = false 
          AND release_date <= CURRENT_TIMESTAMP
    LOOP
        -- Update ticket type quantities
        UPDATE ticket_types
        SET 
            available_quantity = available_quantity + v_schedule.quantity_to_release,
            base_price = COALESCE(v_schedule.price_at_release, base_price),
            updated_at = CURRENT_TIMESTAMP
        WHERE id = v_schedule.ticket_type_id;
        
        -- Mark schedule as processed
        UPDATE ticket_type_availability_schedules
        SET 
            is_processed = true,
            processed_at = CURRENT_TIMESTAMP,
            processed_quantity = v_schedule.quantity_to_release
        WHERE id = v_schedule.id;
        
        v_processed_count := v_processed_count + 1;
    END LOOP;
    
    RETURN v_processed_count;
END;
$$;



--
-- Name: purge_expired_audit_logs(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.purge_expired_audit_logs() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    purged_count INTEGER := 0;
BEGIN
    -- Only purge records that have exceeded their retention period
    -- and are already archived
    DELETE FROM audit_logs
    WHERE is_archived = TRUE
    AND archived_at < NOW() - retention_period
    AND archived_at < NOW() - INTERVAL '30 days'; -- Safety buffer
    
    GET DIAGNOSTICS purged_count = ROW_COUNT;
    
    RETURN purged_count;
END;
$$;



--
-- Name: record_compliance_violation(uuid, uuid, character varying, character varying, text, public.violation_severity, character varying, date, numeric, date, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.record_compliance_violation(p_venue_id uuid, p_compliance_id uuid, p_violation_type character varying, p_violation_title character varying, p_violation_description text, p_severity public.violation_severity, p_issuing_authority character varying, p_violation_date date, p_fine_amount numeric DEFAULT NULL::numeric, p_remediation_deadline date DEFAULT NULL::date, p_created_by_user_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_violation_id UUID;
BEGIN
    INSERT INTO compliance_violations (
        venue_id, compliance_id, violation_type, violation_title,
        violation_description, severity, issuing_authority,
        violation_date, fine_amount, remediation_deadline,
        inspection_date, required_actions, created_by_user_id
    )
    VALUES (
        p_venue_id, p_compliance_id, p_violation_type, p_violation_title,
        p_violation_description, p_severity, p_issuing_authority,
        p_violation_date, p_fine_amount, p_remediation_deadline,
        p_violation_date, 'Remediation plan to be developed',
        p_created_by_user_id
    )
    RETURNING id INTO new_violation_id;
    
    RETURN new_violation_id;
END;
$$;



--
-- Name: refresh_customer_analytics_realtime(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.refresh_customer_analytics_realtime() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY customer_analytics_realtime;
END;
$$;



--
-- Name: refresh_session(character varying, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.refresh_session(p_refresh_token character varying, p_new_expiry timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    session_record RECORD;
    new_expiry TIMESTAMPTZ;
BEGIN
    -- Find session by refresh token
    SELECT * INTO session_record
    FROM sessions
    WHERE refresh_token = p_refresh_token
    AND session_status = 'active'
    AND expires_at > NOW();
    
    IF NOT FOUND THEN
        RETURN FALSE;
    END IF;
    
    -- Calculate new expiry
    new_expiry = COALESCE(p_new_expiry, NOW() + INTERVAL '8 hours');
    
    -- Update session
    UPDATE sessions
    SET expires_at = new_expiry,
        last_activity_at = NOW(),
        refresh_token = encode(gen_random_bytes(32), 'hex')
    WHERE id = session_record.id;
    
    -- Log refresh activity
    INSERT INTO session_activities (session_id, activity_type, activity_description)
    VALUES (session_record.id, 'session_refreshed', 'Session token refreshed');
    
    RETURN TRUE;
END;
$$;



--
-- Name: reschedule_event_schedule(uuid, timestamp with time zone, timestamp with time zone, text, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.reschedule_event_schedule(p_schedule_id uuid, p_new_start_datetime timestamp with time zone, p_new_end_datetime timestamp with time zone DEFAULT NULL::timestamp with time zone, p_reschedule_reason text DEFAULT NULL::text, p_updated_by_user_id uuid DEFAULT NULL::uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    old_start_datetime TIMESTAMPTZ;
BEGIN
    -- Get current start datetime
    SELECT start_datetime INTO old_start_datetime
    FROM event_schedules
    WHERE id = p_schedule_id;
    
    -- Update the schedule
    UPDATE event_schedules
    SET start_datetime = p_new_start_datetime,
        end_datetime = p_new_end_datetime,
        schedule_status = 'rescheduled',
        rescheduled_from_datetime = old_start_datetime,
        reschedule_reason = p_reschedule_reason,
        updated_by_user_id = p_updated_by_user_id,
        updated_at = NOW()
    WHERE id = p_schedule_id;
    
    -- Update all activities to new timeline
    UPDATE schedule_activities
    SET scheduled_start_time = scheduled_start_time + (p_new_start_datetime - old_start_datetime),
        scheduled_end_time = CASE 
            WHEN scheduled_end_time IS NOT NULL 
            THEN scheduled_end_time + (p_new_start_datetime - old_start_datetime)
            ELSE NULL
        END
    WHERE schedule_id = p_schedule_id;
    
    RETURN FOUND;
END;
$$;



--
-- Name: revoke_all_user_sessions(uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.revoke_all_user_sessions(p_user_id uuid, p_except_session_id uuid DEFAULT NULL::uuid, p_reason text DEFAULT 'Security revocation'::text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    revoked_count INTEGER := 0;
    session_record RECORD;
BEGIN
    FOR session_record IN
        SELECT id FROM sessions
        WHERE user_id = p_user_id
        AND session_status = 'active'
        AND (p_except_session_id IS NULL OR id != p_except_session_id)
    LOOP
        PERFORM revoke_session(session_record.id, p_reason);
        revoked_count := revoked_count + 1;
    END LOOP;
    
    RETURN revoked_count;
END;
$$;



--
-- Name: revoke_session(uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.revoke_session(p_session_id uuid, p_reason text DEFAULT 'User logout'::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE sessions
    SET session_status = 'revoked',
        logged_out_at = NOW()
    WHERE id = p_session_id
    AND session_status = 'active';
    
    IF FOUND THEN
        -- Log revocation activity
        INSERT INTO session_activities (session_id, activity_type, activity_description)
        VALUES (p_session_id, 'session_revoked', p_reason);
        
        RETURN TRUE;
    END IF;
    
    RETURN FALSE;
END;
$$;



--
-- Name: revoke_user_role(uuid, uuid, uuid, text, uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.revoke_user_role(p_user_id uuid, p_role_id uuid, p_revoked_by_user_id uuid DEFAULT NULL::uuid, p_revoke_reason text DEFAULT NULL::text, p_venue_id uuid DEFAULT NULL::uuid, p_event_id uuid DEFAULT NULL::uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE user_roles 
    SET is_active = false,
        revoked_at = NOW(),
        revoked_by_user_id = p_revoked_by_user_id,
        revoke_reason = p_revoke_reason
    WHERE user_id = p_user_id 
    AND role_id = p_role_id
    AND venue_id IS NOT DISTINCT FROM p_venue_id
    AND event_id IS NOT DISTINCT FROM p_event_id
    AND is_active = true;
    
    RETURN FOUND;
END;
$$;



--
-- Name: search_audit_logs(text, timestamp with time zone, timestamp with time zone, public.audit_category[], public.audit_severity[], integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.search_audit_logs(p_search_text text, p_start_date timestamp with time zone DEFAULT (now() - '7 days'::interval), p_end_date timestamp with time zone DEFAULT now(), p_categories public.audit_category[] DEFAULT NULL::public.audit_category[], p_severities public.audit_severity[] DEFAULT NULL::public.audit_severity[], p_limit integer DEFAULT 50) RETURNS TABLE(id uuid, created_at timestamp with time zone, user_id uuid, category public.audit_category, action public.audit_action, entity_type character varying, event_description text, severity public.audit_severity, relevance_score real)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT al.id, al.created_at, al.user_id, al.category, al.action,
           al.entity_type, al.event_description, al.severity,
           ts_rank(to_tsvector('english', al.event_description), plainto_tsquery('english', p_search_text)) as relevance_score
    FROM audit_logs al
    WHERE al.created_at BETWEEN p_start_date AND p_end_date
    AND to_tsvector('english', al.event_description) @@ plainto_tsquery('english', p_search_text)
    AND (p_categories IS NULL OR al.category = ANY(p_categories))
    AND (p_severities IS NULL OR al.severity = ANY(p_severities))
    AND al.is_archived = FALSE
    ORDER BY relevance_score DESC, al.created_at DESC
    LIMIT p_limit;
END;
$$;



--
-- Name: search_events(text, uuid, character varying, timestamp without time zone, timestamp without time zone, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.search_events(p_search_term text, p_venue_id uuid DEFAULT NULL::uuid, p_category character varying DEFAULT NULL::character varying, p_start_date timestamp without time zone DEFAULT NULL::timestamp without time zone, p_end_date timestamp without time zone DEFAULT NULL::timestamp without time zone, p_limit integer DEFAULT 20, p_offset integer DEFAULT 0) RETURNS TABLE(event_id uuid, event_name character varying, venue_name character varying, start_date timestamp with time zone, category character varying, available_tickets integer, min_price numeric, relevance_score numeric)
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    WITH event_search AS (
        SELECT 
            e.id,
            e.name,
            v.name AS venue_name,
            e.start_date,
            e.category,
            
      (SELECT COALESCE(SUM(tt.total_supply),0) FROM public.ticket_types tt WHERE tt.event_id = e.id)
 - COUNT(t.id) FILTER (WHERE t.status NOT IN ('CANCELLED', 'REFUNDED')) AS available,
            MIN(tt.price) AS min_price,
            -- Calculate relevance score
            (
                CASE WHEN e.name ILIKE '%' || p_search_term || '%' THEN 10 ELSE 0 END +
                CASE WHEN e.description ILIKE '%' || p_search_term || '%' THEN 5 ELSE 0 END +
                CASE WHEN v.name ILIKE '%' || p_search_term || '%' THEN 5 ELSE 0 END +
                CASE WHEN e.tags::TEXT ILIKE '%' || p_search_term || '%' THEN 3 ELSE 0 END
            ) AS score
        FROM events e
        JOIN venues v ON v.id = e.venue_id
        LEFT JOIN tickets t ON t.event_id = e.id
        LEFT JOIN ticket_types tt ON tt.event_id = e.id
        WHERE e.status = 'ACTIVE'
        AND end_date::timestamp > CURRENT_TIMESTAMP
        AND (p_venue_id IS NULL OR e.venue_id = p_venue_id)
        AND (p_category IS NULL OR e.category = p_category)
        AND (p_start_date IS NULL OR e.start_date >= p_start_date)
        AND (p_end_date IS NULL OR e.start_date <= p_end_date)
        GROUP BY e.id, v.name
        HAVING 
            p_search_term IS NULL OR
            e.name ILIKE '%' || p_search_term || '%' OR
            e.description ILIKE '%' || p_search_term || '%' OR
            v.name ILIKE '%' || p_search_term || '%' OR
            e.tags::TEXT ILIKE '%' || p_search_term || '%'
    )
    SELECT 
        id AS event_id,
        name AS event_name,
        venue_name,
        start_date::timestamp,
        category,
        available AS available_tickets,
        min_price,
        score AS relevance_score
    FROM event_search
    ORDER BY score DESC, start_date::timestamp ASC
    LIMIT p_limit
    OFFSET p_offset;
END;
$$;



--
-- Name: FUNCTION search_events(p_search_term text, p_venue_id uuid, p_category character varying, p_start_date timestamp without time zone, p_end_date timestamp without time zone, p_limit integer, p_offset integer); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.search_events(p_search_term text, p_venue_id uuid, p_category character varying, p_start_date timestamp without time zone, p_end_date timestamp without time zone, p_limit integer, p_offset integer) IS 'Searches events with fuzzy matching and filtering';


--
-- Name: search_events(text, uuid, public.event_category, date, date, public.age_restriction, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.search_events(p_search_text text, p_venue_id uuid DEFAULT NULL::uuid, p_category public.event_category DEFAULT NULL::public.event_category, p_start_date date DEFAULT CURRENT_DATE, p_end_date date DEFAULT NULL::date, p_age_restriction public.age_restriction DEFAULT NULL::public.age_restriction, p_limit integer DEFAULT 20, p_offset integer DEFAULT 0) RETURNS TABLE(event_id uuid, event_name character varying, event_slug character varying, event_category public.event_category, event_date date, event_time time without time zone, venue_id uuid, short_description text, primary_image_url text, price_range_min numeric, price_range_max numeric, relevance_score real)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT e.id, e.event_name, e.event_slug, e.event_category, e.event_date, e.event_time,
           e.venue_id, e.short_description, e.primary_image_url, e.price_range_min, e.price_range_max,
           ts_rank(to_tsvector('english', e.event_name || ' ' || COALESCE(e.short_description, '') || ' ' || COALESCE(e.organizer_name, '')), 
                   plainto_tsquery('english', p_search_text)) as relevance_score
    FROM events e
    WHERE e.deleted_at IS NULL
    AND e.is_public = TRUE
    AND e.event_status IN ('published', 'on_sale', 'sold_out')
    AND to_tsvector('english', e.event_name || ' ' || COALESCE(e.short_description, '') || ' ' || COALESCE(e.organizer_name, '')) 
        @@ plainto_tsquery('english', p_search_text)
    AND (p_venue_id IS NULL OR e.venue_id = p_venue_id)
    AND (p_category IS NULL OR e.event_category = p_category)
    AND e.event_date >= p_start_date
    AND (p_end_date IS NULL OR e.event_date <= p_end_date)
    AND (p_age_restriction IS NULL OR e.age_restriction = p_age_restriction)
    ORDER BY relevance_score DESC, e.event_date
    LIMIT p_limit OFFSET p_offset;
END;
$$;



--
-- Name: search_venues(text, public.venue_type[], character varying, character varying, character, integer, integer, public.venue_status[], numeric, numeric, numeric, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.search_venues(p_search_text text DEFAULT NULL::text, p_venue_types public.venue_type[] DEFAULT NULL::public.venue_type[], p_city character varying DEFAULT NULL::character varying, p_state_province character varying DEFAULT NULL::character varying, p_country_code character DEFAULT NULL::bpchar, p_min_capacity integer DEFAULT NULL::integer, p_max_capacity integer DEFAULT NULL::integer, p_venue_status public.venue_status[] DEFAULT NULL::public.venue_status[], p_latitude numeric DEFAULT NULL::numeric, p_longitude numeric DEFAULT NULL::numeric, p_radius_km numeric DEFAULT NULL::numeric, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0) RETURNS TABLE(id uuid, venue_name character varying, venue_type public.venue_type, city character varying, state_province character varying, total_capacity integer, average_rating numeric, distance_km numeric, venue_status public.venue_status)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT v.id, v.venue_name, v.venue_type, v.city, v.state_province,
           v.total_capacity, v.average_rating,
           CASE 
               WHEN p_latitude IS NOT NULL AND p_longitude IS NOT NULL AND v.latitude IS NOT NULL AND v.longitude IS NOT NULL THEN
                   6371 * acos(cos(radians(p_latitude)) * cos(radians(v.latitude)) * 
                              cos(radians(v.longitude) - radians(p_longitude)) + 
                              sin(radians(p_latitude)) * sin(radians(v.latitude)))
               ELSE NULL
           END::DECIMAL(10, 2) as distance_km,
           v.venue_status
    FROM venues v
    WHERE v.deleted_at IS NULL
    AND (p_search_text IS NULL OR 
         to_tsvector('english', v.venue_name || ' ' || COALESCE(v.display_name, '') || ' ' || COALESCE(v.short_description, '')) 
         @@ plainto_tsquery('english', p_search_text))
    AND (p_venue_types IS NULL OR v.venue_type = ANY(p_venue_types))
    AND (p_city IS NULL OR v.city ILIKE '%' || p_city || '%')
    AND (p_state_province IS NULL OR v.state_province ILIKE '%' || p_state_province || '%')
    AND (p_country_code IS NULL OR v.country_code = p_country_code)
    AND (p_min_capacity IS NULL OR v.total_capacity >= p_min_capacity)
    AND (p_max_capacity IS NULL OR v.total_capacity <= p_max_capacity)
    AND (p_venue_status IS NULL OR v.venue_status = ANY(p_venue_status))
    AND (p_radius_km IS NULL OR p_latitude IS NULL OR p_longitude IS NULL OR v.latitude IS NULL OR v.longitude IS NULL OR
         6371 * acos(cos(radians(p_latitude)) * cos(radians(v.latitude)) * 
                    cos(radians(v.longitude) - radians(p_longitude)) + 
                    sin(radians(p_latitude)) * sin(radians(v.latitude))) <= p_radius_km)
    ORDER BY 
        CASE WHEN distance_km IS NOT NULL THEN distance_km ELSE 999999 END,
        v.average_rating DESC NULLS LAST,
        v.venue_name
    LIMIT p_limit OFFSET p_offset;
END;
$$;



--
-- Name: set_event_metadata(uuid, character varying, character varying, text, jsonb, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.set_event_metadata(p_event_id uuid, p_metadata_type character varying, p_metadata_key character varying, p_metadata_value text DEFAULT NULL::text, p_metadata_json jsonb DEFAULT NULL::jsonb, p_user_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_metadata_id UUID;
    v_old_metadata RECORD;
    v_new_version INTEGER;
BEGIN
    -- Get existing metadata if it exists
    SELECT * INTO v_old_metadata
    FROM event_metadata
    WHERE event_id = p_event_id
      AND metadata_type = p_metadata_type
      AND metadata_key = p_metadata_key
      AND is_current_version = true;
    
    -- Mark old version as not current
    IF FOUND THEN
        UPDATE event_metadata
        SET is_current_version = false
        WHERE id = v_old_metadata.id;
        
        v_new_version := v_old_metadata.version + 1;
        
        -- Log the change
        INSERT INTO event_metadata_history (
            metadata_id, event_id, metadata_type, metadata_key,
            old_value, new_value, old_json, new_json,
            change_type, changed_by
        ) VALUES (
            v_old_metadata.id, p_event_id, p_metadata_type, p_metadata_key,
            v_old_metadata.metadata_value, p_metadata_value,
            v_old_metadata.metadata_json, p_metadata_json,
            'UPDATE', p_user_id
        );
    ELSE
        v_new_version := 1;
    END IF;
    
    -- Insert new version
    INSERT INTO event_metadata (
        event_id, metadata_type, metadata_key,
        metadata_value, metadata_json,
        version, is_current_version, created_by
    ) VALUES (
        p_event_id, p_metadata_type, p_metadata_key,
        p_metadata_value, p_metadata_json,
        v_new_version, true, p_user_id
    ) RETURNING id INTO v_metadata_id;
    
    -- Log creation if new
    IF v_new_version = 1 THEN
        INSERT INTO event_metadata_history (
            metadata_id, event_id, metadata_type, metadata_key,
            new_value, new_json, change_type, changed_by
        ) VALUES (
            v_metadata_id, p_event_id, p_metadata_type, p_metadata_key,
            p_metadata_value, p_metadata_json, 'CREATE', p_user_id
        );
    END IF;
    
    RETURN v_metadata_id;
END;
$$;



--
-- Name: set_ticket_type_slug(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.set_ticket_type_slug() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.type_slug IS NULL THEN
        NEW.type_slug := LOWER(REGEXP_REPLACE(REGEXP_REPLACE(NEW.type_name, '[^a-zA-Z0-9\s-]', '', 'g'), '\s+', '-', 'g'));
    END IF;
    RETURN NEW;
END;
$$;



--
-- Name: set_venue_setting(uuid, character varying, text, public.setting_category, public.setting_data_type, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.set_venue_setting(p_venue_id uuid, p_setting_key character varying, p_setting_value text, p_category public.setting_category DEFAULT 'general'::public.setting_category, p_data_type public.setting_data_type DEFAULT 'string'::public.setting_data_type, p_updated_by_user_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    setting_id UUID;
    setting_exists BOOLEAN;
BEGIN
    -- Check if setting exists
    SELECT EXISTS(
        SELECT 1 FROM venue_settings 
        WHERE venue_id = p_venue_id 
        AND setting_key = p_setting_key 
        AND is_active = TRUE
    ) INTO setting_exists;
    
    IF setting_exists THEN
        -- Update existing setting
        UPDATE venue_settings
        SET setting_value = p_setting_value,
            updated_by_user_id = p_updated_by_user_id
        WHERE venue_id = p_venue_id
        AND setting_key = p_setting_key
        AND is_active = TRUE
        RETURNING id INTO setting_id;
    ELSE
        -- Create new setting
        INSERT INTO venue_settings (
            venue_id, setting_key, setting_value, category, 
            data_type, created_by_user_id, updated_by_user_id
        )
        VALUES (
            p_venue_id, p_setting_key, p_setting_value, p_category,
            p_data_type, p_updated_by_user_id, p_updated_by_user_id
        )
        RETURNING id INTO setting_id;
    END IF;
    
    RETURN setting_id;
END;
$$;



--
-- Name: soft_delete_user(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.soft_delete_user(user_id uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
   UPDATE public.users 
   SET 
       deleted_at = CURRENT_TIMESTAMP,
       status = 'DELETED',
       email = email || '.deleted.' || EXTRACT(EPOCH FROM CURRENT_TIMESTAMP),
       username = CASE 
           WHEN username IS NOT NULL 
           THEN username || '.deleted.' || EXTRACT(EPOCH FROM CURRENT_TIMESTAMP)
           ELSE NULL
       END
   WHERE id = user_id;
   
   RETURN FOUND;
END;
$$;



--
-- Name: staff_clock_action(uuid, character varying, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.staff_clock_action(p_schedule_id uuid, p_action character varying, p_timestamp timestamp with time zone DEFAULT now()) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF p_action = 'in' THEN
        UPDATE staff_schedules
        SET actual_start_time = p_timestamp,
            schedule_status = 'in_progress'
        WHERE id = p_schedule_id
        AND actual_start_time IS NULL;
    ELSIF p_action = 'out' THEN
        UPDATE staff_schedules
        SET actual_end_time = p_timestamp,
            schedule_status = 'completed'
        WHERE id = p_schedule_id
        AND actual_start_time IS NOT NULL
        AND actual_end_time IS NULL;
    END IF;
    
    RETURN FOUND;
END;
$$;



--
-- Name: store_integration_credentials(uuid, text, text, text, text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.store_integration_credentials(p_integration_id uuid, p_api_key text DEFAULT NULL::text, p_client_id text DEFAULT NULL::text, p_client_secret text DEFAULT NULL::text, p_access_token text DEFAULT NULL::text, p_refresh_token text DEFAULT NULL::text, p_encryption_key text DEFAULT 'venue_integration_key'::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE venue_integrations
    SET api_key_encrypted = CASE WHEN p_api_key IS NOT NULL THEN pgp_sym_encrypt(p_api_key, p_encryption_key) ELSE NULL END,
        client_id_encrypted = CASE WHEN p_client_id IS NOT NULL THEN pgp_sym_encrypt(p_client_id, p_encryption_key) ELSE NULL END,
        client_secret_encrypted = CASE WHEN p_client_secret IS NOT NULL THEN pgp_sym_encrypt(p_client_secret, p_encryption_key) ELSE NULL END,
        access_token_encrypted = CASE WHEN p_access_token IS NOT NULL THEN pgp_sym_encrypt(p_access_token, p_encryption_key) ELSE NULL END,
        refresh_token_encrypted = CASE WHEN p_refresh_token IS NOT NULL THEN pgp_sym_encrypt(p_refresh_token, p_encryption_key) ELSE NULL END,
        updated_at = NOW()
    WHERE id = p_integration_id;
    
    RETURN FOUND;
END;
$$;



--
-- Name: suggest_categories_for_event(text, text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.suggest_categories_for_event(p_event_name text, p_event_description text DEFAULT NULL::text, p_limit integer DEFAULT 5) RETURNS TABLE(category_id uuid, category_name character varying, confidence_score numeric, match_reason text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_search_text TEXT;
BEGIN
    v_search_text := LOWER(p_event_name || ' ' || COALESCE(p_event_description, ''));
    
    RETURN QUERY
    SELECT 
        ec.id,
        ec.category_name,
        CASE 
            WHEN ec.category_name ILIKE '%' || p_event_name || '%' THEN 0.95
            WHEN EXISTS (
                SELECT 1 FROM event_category_tags ect 
                WHERE ect.category_id = ec.id 
                AND v_search_text LIKE '%' || LOWER(ect.tag_name) || '%'
            ) THEN 0.80
            WHEN EXISTS (
                SELECT 1 FROM event_category_attributes eca 
                WHERE eca.category_id = ec.id 
                AND v_search_text LIKE '%' || LOWER(eca.attribute_value) || '%'
            ) THEN 0.70
            ELSE 0.50
        END as confidence_score,
        CASE 
            WHEN ec.category_name ILIKE '%' || p_event_name || '%' THEN 'Category name match'
            WHEN EXISTS (
                SELECT 1 FROM event_category_tags ect 
                WHERE ect.category_id = ec.id 
                AND v_search_text LIKE '%' || LOWER(ect.tag_name) || '%'
            ) THEN 'Tag match'
            WHEN EXISTS (
                SELECT 1 FROM event_category_attributes eca 
                WHERE eca.category_id = ec.id 
                AND v_search_text LIKE '%' || LOWER(eca.attribute_value) || '%'
            ) THEN 'Attribute match'
            ELSE 'General suggestion'
        END as match_reason
    FROM event_categories ec
    WHERE ec.is_active = true
    ORDER BY confidence_score DESC
    LIMIT p_limit;
END;
$$;



--
-- Name: terminate_staff_employment(uuid, date, text, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.terminate_staff_employment(p_venue_staff_id uuid, p_termination_date date DEFAULT CURRENT_DATE, p_termination_reason text DEFAULT NULL::text, p_updated_by_user_id uuid DEFAULT NULL::uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE venue_staff
    SET employment_status = 'terminated',
        termination_date = p_termination_date,
        termination_reason = p_termination_reason,
        updated_by_user_id = p_updated_by_user_id
    WHERE id = p_venue_staff_id
    AND employment_status != 'terminated';
    
    -- Cancel future schedules
    UPDATE staff_schedules
    SET schedule_status = 'cancelled'
    WHERE venue_staff_id = p_venue_staff_id
    AND schedule_date > p_termination_date
    AND schedule_status = 'scheduled';
    
    RETURN FOUND;
END;
$$;



--
-- Name: test_integration_connectivity(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.test_integration_connectivity(p_integration_id uuid) RETURNS TABLE(is_connected boolean, response_time_ms integer, status_message text, last_test_at timestamp with time zone)
    LANGUAGE plpgsql
    AS $$
DECLARE
    integration_record RECORD;
    test_result RECORD;
BEGIN
    -- Get integration details
    SELECT * INTO integration_record
    FROM venue_integrations
    WHERE id = p_integration_id;
    
    -- Update last health check
    UPDATE venue_integrations
    SET last_health_check = NOW()
    WHERE id = p_integration_id;
    
    -- This is a placeholder for actual connectivity testing
    -- In practice, this would make an HTTP request to the health_check_url
    -- For now, we'll simulate based on integration status
    
    RETURN QUERY
    SELECT 
        CASE WHEN integration_record.integration_status = 'active' THEN TRUE ELSE FALSE END,
        CASE WHEN integration_record.integration_status = 'active' THEN 250 ELSE NULL END,
        CASE 
            WHEN integration_record.integration_status = 'active' THEN 'Connection successful'
            WHEN integration_record.integration_status = 'error' THEN 'Connection failed: ' || COALESCE(integration_record.last_error_message, 'Unknown error')
            ELSE 'Integration not active'
        END,
        NOW();
END;
$$;



--
-- Name: track_listing_price_history(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.track_listing_price_history() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND NEW.price != OLD.price) THEN
        INSERT INTO price_history (
            ticket_id,
            listing_id,
            price,
            recorded_at
        ) VALUES (
            NEW.ticket_id,
            NEW.id,
            NEW.price,
            CURRENT_TIMESTAMP
        );
    END IF;
    RETURN NULL;
END;
$$;



--
-- Name: track_order_state_change(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.track_order_state_change() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Only track if status actually changed
    IF OLD.status IS DISTINCT FROM NEW.status THEN
        INSERT INTO order_state_transitions (
            order_id,
            from_status,
            to_status,
            reason,
            metadata,
            created_at
        ) VALUES (
            NEW.id,
            OLD.status,
            NEW.status,
            'Automatic transition tracking',
            jsonb_build_object(
                'old_updated_at', OLD.updated_at,
                'new_updated_at', NEW.updated_at
            ),
            CURRENT_TIMESTAMP
        );
    END IF;
    
    -- Update the updated_at timestamp
    NEW.updated_at = CURRENT_TIMESTAMP;
    
    RETURN NEW;
END;
$$;



--
-- Name: track_price_history(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.track_price_history() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Record price change
  IF NEW.price != OLD.price OR TG_OP = 'INSERT' THEN
      INSERT INTO public.price_history (
          ticket_id, listing_id, price, currency, price_type, event_id, source
      )
      SELECT 
          NEW.ticket_id, NEW.id, NEW.price, NEW.currency, 'LISTING',
          t.event_id, 'USER'
      FROM public.tickets t
      WHERE t.id = NEW.ticket_id;
  END IF;
  RETURN NEW;
END;
$$;



--
-- Name: track_session_activity(uuid, character varying, text, text, inet); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.track_session_activity(p_session_id uuid, p_activity_type character varying, p_activity_description text DEFAULT NULL::text, p_page_url text DEFAULT NULL::text, p_ip_address inet DEFAULT NULL::inet) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    activity_id UUID;
BEGIN
    -- Update session last activity
    UPDATE sessions
    SET last_activity_at = NOW(),
        page_views_count = CASE WHEN p_activity_type = 'page_view' THEN page_views_count + 1 ELSE page_views_count END,
        api_calls_count = CASE WHEN p_activity_type = 'api_call' THEN api_calls_count + 1 ELSE api_calls_count END
    WHERE id = p_session_id;
    
    -- Insert activity record
    INSERT INTO session_activities (
        session_id, activity_type, activity_description, page_url, ip_address
    )
    VALUES (
        p_session_id, p_activity_type, p_activity_description, p_page_url, p_ip_address
    )
    RETURNING id INTO activity_id;
    
    RETURN activity_id;
END;
$$;



--
-- Name: transfer_ticket(uuid, uuid, uuid, numeric); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.transfer_ticket(p_ticket_id uuid, p_from_user_id uuid, p_to_user_id uuid, p_transfer_price numeric DEFAULT NULL::numeric) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
   v_transfer_id UUID;


   v_transaction_id UUID;


BEGIN
   -- Validate transfer is allowed
   IF NOT EXISTS (
       SELECT 1 FROM public.tickets 
       WHERE id = p_ticket_id 
       AND owner_id = p_from_user_id 
       AND is_transferable = TRUE
       AND (transfer_locked_until IS NULL OR transfer_locked_until < CURRENT_TIMESTAMP)
   ) THEN
       RAISE EXCEPTION 'Transfer not allowed for this ticket';


   END IF;


   
   -- Create transaction record
   INSERT INTO public.ticket_transactions (
       ticket_id, transaction_type, from_user_id, to_user_id, amount, status
   ) VALUES (
       p_ticket_id, 'TRANSFER', p_from_user_id, p_to_user_id, p_transfer_price, 'PROCESSING'
   ) RETURNING id INTO v_transaction_id;


   
   -- Create transfer record
   INSERT INTO public.ticket_transfers (
       ticket_id, transaction_id, from_user_id, to_user_id, 
       transfer_price, status
   ) VALUES (
       p_ticket_id, v_transaction_id, p_from_user_id, p_to_user_id,
       p_transfer_price, 'PENDING'
   ) RETURNING id INTO v_transfer_id;


   
   -- Update ticket owner and status
   UPDATE public.tickets
   SET 
       owner_id = p_to_user_id,
       transfer_count = transfer_count + 1,
       status = 'TRANSFERRED',
       updated_at = CURRENT_TIMESTAMP
   WHERE id = p_ticket_id;


   
   -- Complete transaction
   UPDATE public.ticket_transactions
   SET status = 'COMPLETED', completed_at = CURRENT_TIMESTAMP
   WHERE id = v_transaction_id;


   
   -- Complete transfer
   UPDATE public.ticket_transfers
   SET status = 'COMPLETED', accepted_at = CURRENT_TIMESTAMP
   WHERE id = v_transfer_id;


   
   RETURN v_transfer_id;


END;


$$;



--
-- Name: transfer_ticket(uuid, uuid, uuid, character varying, numeric, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.transfer_ticket(p_ticket_id uuid, p_from_user_id uuid, p_to_user_id uuid, p_transfer_type character varying DEFAULT 'GIFT'::character varying, p_transfer_price numeric DEFAULT NULL::numeric, p_initiated_by uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_transfer_id UUID;
    v_ticket RECORD;
    v_policy RECORD;
    v_new_ticket_id UUID;
BEGIN
    -- Get ticket and validate ownership
    SELECT * INTO v_ticket
    FROM tickets
    WHERE id = p_ticket_id AND owner_user_id = p_from_user_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Ticket not found or user not owner';
    END IF;
    
    -- Check if ticket is transferable
    IF NOT v_ticket.is_transferable THEN
        RAISE EXCEPTION 'Ticket is not transferable';
    END IF;
    
    -- Get transfer policy
    SELECT * INTO v_policy
    FROM ticket_type_transfer_policies
    WHERE ticket_type_id = v_ticket.ticket_type_id;
    
    -- Check transfer limits
    IF v_policy.max_transfers_per_ticket IS NOT NULL AND 
       v_ticket.transfer_count >= v_policy.max_transfers_per_ticket THEN
        RAISE EXCEPTION 'Maximum transfers exceeded for this ticket';
    END IF;
    
    -- Create transfer record
    INSERT INTO ticket_transfers (
        original_ticket_id, from_user_id, to_user_id,
        initiated_by_user_id, transfer_type, transfer_price,
        status, requires_approval
    ) VALUES (
        p_ticket_id, p_from_user_id, p_to_user_id,
        COALESCE(p_initiated_by, p_from_user_id), p_transfer_type, p_transfer_price,
        CASE WHEN COALESCE(v_policy.requires_approval, false) THEN 'PENDING' ELSE 'COMPLETED' END,
        COALESCE(v_policy.requires_approval, false)
    ) RETURNING id INTO v_transfer_id;
    
    -- If no approval required, complete transfer immediately
    IF NOT COALESCE(v_policy.requires_approval, false) THEN
        -- Update ticket ownership
        UPDATE tickets
        SET 
            owner_user_id = p_to_user_id,
            transfer_count = transfer_count + 1,
            updated_at = CURRENT_TIMESTAMP,
            status = 'TRANSFERRED'
        WHERE id = p_ticket_id;
        
        -- Record ownership change
        INSERT INTO ticket_ownership_history (
            ticket_id, owner_user_id, ownership_type,
            source_transaction_id, source_transaction_type, price_paid
        ) VALUES (
            p_ticket_id, p_to_user_id, 'TRANSFER',
            v_transfer_id, 'TRANSFER', p_transfer_price
        );
        
        -- Mark previous ownership as ended
        UPDATE ticket_ownership_history
        SET owned_until = CURRENT_TIMESTAMP, is_current_owner = false
        WHERE ticket_id = p_ticket_id AND is_current_owner = true AND owner_user_id = p_from_user_id;
        
        -- Update new ownership as current
        UPDATE ticket_ownership_history
        SET is_current_owner = true
        WHERE ticket_id = p_ticket_id AND owner_user_id = p_to_user_id 
        AND owned_until IS NULL;
        
        -- Update transfer status
        UPDATE ticket_transfers
        SET status = 'COMPLETED', completed_at = CURRENT_TIMESTAMP
        WHERE id = v_transfer_id;
    END IF;
    
    RETURN v_transfer_id;
END;
$$;



--
-- Name: trigger_capacity_threshold_check(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.trigger_capacity_threshold_check() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM check_capacity_thresholds(NEW.id);
    RETURN NEW;
END;
$$;



--
-- Name: update_activity_timing(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_activity_timing() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    
    -- Calculate duration if not provided
    IF NEW.duration IS NULL AND NEW.scheduled_end_time IS NOT NULL THEN
        NEW.duration = NEW.scheduled_end_time - NEW.scheduled_start_time;
    END IF;
    
    -- Calculate end time if duration is provided but end time is not
    IF NEW.scheduled_end_time IS NULL AND NEW.duration IS NOT NULL THEN
        NEW.scheduled_end_time = NEW.scheduled_start_time + NEW.duration;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: update_available_capacity(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_available_capacity() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   -- When sold_count or pending_count changes, update available_capacity
   NEW.available_capacity := NEW.total_capacity - NEW.sold_count - NEW.pending_count - NEW.reserved_capacity;
   
   -- Ensure available capacity doesn't go negative
   IF NEW.available_capacity < 0 THEN
       NEW.available_capacity := 0;
   END IF;
   
   RETURN NEW;
END;
$$;



--
-- Name: update_available_capacity(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_available_capacity(p_event_capacity_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE event_capacity 
    SET available_capacity = total_capacity - sold_capacity - reserved_capacity - hold_capacity,
        last_updated = CURRENT_TIMESTAMP,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_event_capacity_id;
END;
$$;



--
-- Name: update_blockchain_transactions_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_blockchain_transactions_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: update_capacity_timestamp(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_capacity_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: update_category_event_count(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_category_event_count() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   IF TG_OP = 'INSERT' AND NEW.primary_category_id IS NOT NULL THEN
       UPDATE public.event_categories 
       SET event_count = event_count + 1 
       WHERE id = NEW.primary_category_id;
   ELSIF TG_OP = 'DELETE' AND OLD.primary_category_id IS NOT NULL THEN
       UPDATE public.event_categories 
       SET event_count = event_count - 1 
       WHERE id = OLD.primary_category_id;
   ELSIF TG_OP = 'UPDATE' THEN
       IF OLD.primary_category_id IS DISTINCT FROM NEW.primary_category_id THEN
           IF OLD.primary_category_id IS NOT NULL THEN
               UPDATE public.event_categories 
               SET event_count = event_count - 1 
               WHERE id = OLD.primary_category_id;
           END IF;
           IF NEW.primary_category_id IS NOT NULL THEN
               UPDATE public.event_categories 
               SET event_count = event_count + 1 
               WHERE id = NEW.primary_category_id;
           END IF;
       END IF;
   END IF;
   RETURN NEW;
END;
$$;



--
-- Name: update_category_path(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_category_path() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.category_path = get_category_path(NEW.id);
    RETURN NEW;
END;
$$;



--
-- Name: update_category_stats(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_category_stats(p_category_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_stats RECORD;
BEGIN
    SELECT 
        COUNT(DISTINCT ecm.event_id) as event_count,
        COALESCE(SUM(t.quantity), 0) as total_tickets_sold,
        COALESCE(SUM(t.total_amount), 0) as total_revenue,
        COALESCE(AVG(e.rating), 0) as avg_rating,
        MAX(e.event_date) as last_event_date
    INTO v_stats
    FROM event_category_mappings ecm
    LEFT JOIN events e ON ecm.event_id = e.id
    LEFT JOIN tickets t ON e.id = t.event_id AND t.status = 'SOLD'
    WHERE ecm.category_id = p_category_id;
    
    UPDATE event_categories
    SET 
        event_count = v_stats.event_count,
        total_tickets_sold = v_stats.total_tickets_sold,
        total_revenue = v_stats.total_revenue,
        avg_rating = v_stats.avg_rating,
        last_event_date = v_stats.last_event_date,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_category_id;
END;
$$;



--
-- Name: update_category_timestamp(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_category_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: update_compliance_from_inspection(uuid, uuid, boolean, character varying, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_compliance_from_inspection(p_inspection_id uuid, p_compliance_id uuid, p_certificate_issued boolean, p_certificate_number character varying DEFAULT NULL::character varying, p_certificate_expiry date DEFAULT NULL::date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Update inspection record
    UPDATE compliance_inspections
    SET certificate_issued = p_certificate_issued,
        certificate_number = p_certificate_number,
        certificate_expiry_date = p_certificate_expiry
    WHERE id = p_inspection_id;
    
    -- Update compliance record if certificate issued
    IF p_certificate_issued AND p_compliance_id IS NOT NULL THEN
        UPDATE venue_compliance
        SET compliance_status = 'valid',
            certificate_number = p_certificate_number,
            expiry_date = p_certificate_expiry,
            verification_date = NOW(),
            is_verified = TRUE
        WHERE id = p_compliance_id;
    END IF;
    
    RETURN TRUE;
END;
$$;



--
-- Name: update_compliance_status(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_compliance_status() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Update timestamp
    NEW.updated_at = NOW();
    
    -- Update status based on expiry date
    IF NEW.expiry_date IS NOT NULL THEN
        IF NEW.expiry_date < CURRENT_DATE THEN
            NEW.compliance_status = 'expired';
        ELSIF NEW.expiry_date <= CURRENT_DATE + INTERVAL '30 days' AND NEW.compliance_status = 'valid' THEN
            NEW.compliance_status = 'pending_renewal';
        END IF;
    END IF;
    
    -- Set next reminder date
    IF NEW.expiry_date IS NOT NULL AND NEW.reminder_days_before_expiry IS NOT NULL THEN
        NEW.next_reminder_date = NEW.expiry_date - INTERVAL '1 day' * NEW.reminder_days_before_expiry;
    END IF;
    
    -- Handle current version logic
    IF TG_OP = 'INSERT' AND NEW.is_current_version = TRUE THEN
        -- Mark other versions as not current
        UPDATE venue_compliance 
        SET is_current_version = FALSE 
        WHERE venue_id = NEW.venue_id 
        AND compliance_type = NEW.compliance_type 
        AND id != NEW.id;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: update_customer_feedback_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_customer_feedback_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   NEW.updated_at = CURRENT_TIMESTAMP;
   -- Update has_photos flag
   NEW.has_photos = (array_length(NEW.photo_urls, 1) > 0);
   RETURN NEW;
END;
$$;



--
-- Name: update_entity_average_ratings(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_entity_average_ratings() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
   v_avg_rating DECIMAL(3,2);
   v_total_reviews INTEGER;
BEGIN
   -- Update venue average if venue review
   IF NEW.type = 'venue_review' AND NEW.venue_id IS NOT NULL THEN
       SELECT 
           AVG(overall_rating)::DECIMAL(3,2),
           COUNT(*)
       INTO v_avg_rating, v_total_reviews
       FROM customer_feedback
       WHERE venue_id = NEW.venue_id 
         AND status = 'published'
         AND overall_rating IS NOT NULL;
       
       -- Update venues table (if exists)
       -- UPDATE venues SET average_rating = v_avg_rating, total_reviews = v_total_reviews WHERE id = NEW.venue_id;
   END IF;
   
   -- Update event average if event review
   IF NEW.type = 'event_review' AND NEW.event_id IS NOT NULL THEN
       SELECT 
           AVG(overall_rating)::DECIMAL(3,2),
           COUNT(*)
       INTO v_avg_rating, v_total_reviews
       FROM customer_feedback
       WHERE event_id = NEW.event_id 
         AND status = 'published'
         AND overall_rating IS NOT NULL;
       
       -- Update events table (if exists)
       -- UPDATE events SET average_rating = v_avg_rating, total_reviews = v_total_reviews WHERE id = NEW.event_id;
   END IF;
   
   RETURN NEW;
END;
$$;



--
-- Name: update_event_metadata(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_event_metadata() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Update timestamp
    NEW.updated_at = NOW();
    
    -- Auto-generate slug if not provided
    IF NEW.event_slug IS NULL OR NEW.event_slug = '' THEN
        NEW.event_slug = lower(regexp_replace(NEW.event_name, '[^a-zA-Z0-9]+', '-', 'g'));
        NEW.event_slug = trim(NEW.event_slug, '-');
        
        -- Ensure uniqueness
        WHILE EXISTS (SELECT 1 FROM events WHERE event_slug = NEW.event_slug AND id != NEW.id) LOOP
            NEW.event_slug = NEW.event_slug || '-' || floor(random() * 1000)::text;
        END LOOP;
    END IF;
    
    -- Combine date and time into datetime
    IF NEW.event_date IS NOT NULL AND NEW.event_time IS NOT NULL THEN
        NEW.event_datetime = (NEW.event_date || ' ' || NEW.event_time)::TIMESTAMP AT TIME ZONE COALESCE(NEW.event_timezone, 'UTC');
    END IF;
    
    -- Calculate estimated end time
    IF NEW.show_start_time IS NOT NULL AND NEW.estimated_duration IS NOT NULL THEN
        NEW.estimated_end_time = NEW.show_start_time + NEW.estimated_duration;
    END IF;
    
    -- Set publication timestamp
    IF OLD.event_status != 'published' AND NEW.event_status = 'published' AND NEW.published_at IS NULL THEN
        NEW.published_at = NOW();
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: update_event_status(uuid, public.event_status, uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_event_status(p_event_id uuid, p_new_status public.event_status, p_updated_by_user_id uuid DEFAULT NULL::uuid, p_reason text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE events
    SET event_status = p_new_status,
        updated_by_user_id = p_updated_by_user_id,
        updated_at = NOW(),
        published_at = CASE WHEN p_new_status = 'published' AND published_at IS NULL THEN NOW() ELSE published_at END,
        published_by_user_id = CASE WHEN p_new_status = 'published' AND published_by_user_id IS NULL THEN p_updated_by_user_id ELSE published_by_user_id END
    WHERE id = p_event_id
    AND deleted_at IS NULL;
    
    -- Log status change if audit function exists
    IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'log_audit_event') THEN
        PERFORM log_audit_event(
            p_updated_by_user_id,
            'event_management'::audit_category,
            'update'::audit_action,
            'event',
            p_event_id::text,
            NULL,
            'Event status changed to ' || p_new_status::text,
            NULL,
            jsonb_build_object('new_status', p_new_status, 'reason', p_reason),
            'info'::audit_severity
        );
    END IF;
    
    RETURN FOUND;
END;
$$;



--
-- Name: update_event_ticket_stats(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_event_ticket_stats() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE events
    SET total_tickets = (
            SELECT COUNT(*) FROM tickets WHERE event_id = COALESCE(NEW.event_id, OLD.event_id)
        ),
        available_tickets = (
            SELECT COUNT(*) FROM tickets 
            WHERE event_id = COALESCE(NEW.event_id, OLD.event_id)
            AND status = 'available'
        )
    WHERE id = COALESCE(NEW.event_id, OLD.event_id);
    RETURN NULL;
END;
$$;



--
-- Name: update_feedback_responses_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_feedback_responses_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   NEW.updated_at = CURRENT_TIMESTAMP;
   RETURN NEW;
END;
$$;



--
-- Name: update_gas_fee_tracking_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_gas_fee_tracking_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   NEW.updated_at = CURRENT_TIMESTAMP;
   RETURN NEW;
END;
$$;



--
-- Name: update_integration_metrics(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_integration_metrics() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Update timestamp
    NEW.updated_at = NOW();
    
    -- Calculate success rate and update health status
    IF NEW.total_requests > 0 THEN
        IF (NEW.successful_requests::DECIMAL / NEW.total_requests) >= 0.95 THEN
            NEW.health_status = 'healthy';
        ELSIF (NEW.successful_requests::DECIMAL / NEW.total_requests) >= 0.80 THEN
            NEW.health_status = 'degraded';
        ELSE
            NEW.health_status = 'unhealthy';
        END IF;
    END IF;
    
    -- Update integration status based on errors
    IF NEW.consecutive_errors >= 10 THEN
        NEW.integration_status = 'error';
        NEW.is_enabled = FALSE;
    ELSIF NEW.consecutive_errors = 0 AND OLD.consecutive_errors > 0 THEN
        NEW.integration_status = 'active';
    END IF;
    
    -- Reset 24h error count daily
    IF NEW.last_error_at IS NOT NULL AND NEW.last_error_at < NOW() - INTERVAL '24 hours' THEN
        NEW.error_count_24h = 0;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: update_integration_sync_status(uuid, boolean, boolean, integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_integration_sync_status(p_integration_id uuid, p_sync_started boolean DEFAULT true, p_sync_completed boolean DEFAULT false, p_records_processed integer DEFAULT NULL::integer, p_sync_error text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF p_sync_started AND NOT p_sync_completed THEN
        -- Sync started
        UPDATE venue_integrations
        SET sync_in_progress = TRUE,
            current_retry_count = 0,
            updated_at = NOW()
        WHERE id = p_integration_id;
        
    ELSIF p_sync_completed AND NOT p_sync_started THEN
        -- Sync completed successfully
        UPDATE venue_integrations
        SET sync_in_progress = FALSE,
            last_sync_at = NOW(),
            last_successful_sync_at = NOW(),
            next_sync_at = CASE 
                WHEN sync_frequency = 'hourly' THEN NOW() + INTERVAL '1 hour'
                WHEN sync_frequency = 'daily' THEN NOW() + INTERVAL '1 day'
                WHEN sync_frequency = 'weekly' THEN NOW() + INTERVAL '1 week'
                ELSE NULL
            END,
            total_data_synced = COALESCE(total_data_synced, 0) + COALESCE(p_records_processed, 0),
            consecutive_errors = 0,
            updated_at = NOW()
        WHERE id = p_integration_id;
        
    ELSIF p_sync_error IS NOT NULL THEN
        -- Sync failed
        UPDATE venue_integrations
        SET sync_in_progress = FALSE,
            current_retry_count = current_retry_count + 1,
            consecutive_errors = consecutive_errors + 1,
            last_error_message = p_sync_error,
            last_error_at = NOW(),
            next_sync_at = CASE 
                WHEN current_retry_count < max_retry_attempts THEN 
                    NOW() + INTERVAL '1 second' * retry_backoff_seconds
                ELSE NULL
            END,
            updated_at = NOW()
        WHERE id = p_integration_id;
    END IF;
    
    RETURN FOUND;
END;
$$;



--
-- Name: update_invoices_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_invoices_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: update_layout_capacity(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_layout_capacity() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Update layout capacity totals when sections change
    UPDATE venue_layouts
    SET seated_capacity = COALESCE((
            SELECT SUM(section_capacity)
            FROM layout_sections
            WHERE layout_id = NEW.layout_id
            AND section_type IN ('seating', 'vip', 'box', 'balcony', 'orchestra', 'gallery')
            AND is_active = TRUE
        ), 0),
        standing_capacity = COALESCE((
            SELECT SUM(section_capacity)
            FROM layout_sections
            WHERE layout_id = NEW.layout_id
            AND section_type IN ('standing', 'pit', 'lawn')
            AND is_active = TRUE
        ), 0),
        wheelchair_capacity = COALESCE((
            SELECT SUM(wheelchair_seats)
            FROM layout_sections
            WHERE layout_id = NEW.layout_id
            AND is_active = TRUE
        ), 0),
        companion_capacity = COALESCE((
            SELECT SUM(companion_seats)
            FROM layout_sections
            WHERE layout_id = NEW.layout_id
            AND is_active = TRUE
        ), 0),
        vip_capacity = COALESCE((
            SELECT SUM(section_capacity)
            FROM layout_sections
            WHERE layout_id = NEW.layout_id
            AND section_type = 'vip'
            AND is_active = TRUE
        ), 0),
        updated_at = NOW()
    WHERE id = NEW.layout_id;
    
    -- Update total capacity
    UPDATE venue_layouts
    SET total_capacity = seated_capacity + standing_capacity
    WHERE id = NEW.layout_id;
    
    RETURN NEW;
END;
$$;



--
-- Name: update_loyalty_account_balance(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_loyalty_account_balance() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Update the loyalty account balance
    UPDATE loyalty_accounts
    SET 
        current_points = NEW.balance_after,
        lifetime_points = CASE 
            WHEN NEW.transaction_type = 'earned' AND NEW.points > 0 
            THEN lifetime_points + NEW.points 
            ELSE lifetime_points 
        END,
        redeemed_points = CASE 
            WHEN NEW.transaction_type = 'redeemed' AND NEW.points < 0 
            THEN redeemed_points + ABS(NEW.points) 
            ELSE redeemed_points 
        END,
        expired_points = CASE 
            WHEN NEW.transaction_type = 'expired' AND NEW.points < 0 
            THEN expired_points + ABS(NEW.points) 
            ELSE expired_points 
        END,
        last_earned_at = CASE 
            WHEN NEW.transaction_type = 'earned' AND NEW.points > 0 
            THEN NEW.processed_at 
            ELSE last_earned_at 
        END,
        last_redeemed_at = CASE 
            WHEN NEW.transaction_type = 'redeemed' 
            THEN NEW.processed_at 
            ELSE last_redeemed_at 
        END,
        total_transactions = total_transactions + 1,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = NEW.loyalty_account_id;
    
    RETURN NEW;
END;
$$;



--
-- Name: update_metadata_timestamp(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_metadata_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: update_nft_metadata_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_nft_metadata_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   NEW.updated_at = CURRENT_TIMESTAMP;
   RETURN NEW;
END;
$$;



--
-- Name: update_notification_templates_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_notification_templates_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: update_order_totals(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_order_totals() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Update order totals based on order_items
    UPDATE orders
    SET subtotal = (
            SELECT COALESCE(SUM(unit_price * quantity), 0)
            FROM order_items
            WHERE order_id = NEW.order_id
        ),
        tax_amount = (
            SELECT COALESCE(SUM(tax_amount), 0)
            FROM order_items
            WHERE order_id = NEW.order_id
        ),
        total_amount = (
            SELECT COALESCE(SUM(total_price), 0)
            FROM order_items
            WHERE order_id = NEW.order_id
        ),
        updated_at = CURRENT_TIMESTAMP
    WHERE id = NEW.order_id;
    
    RETURN NEW;
END;
$$;



--
-- Name: update_payment_methods_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_payment_methods_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: update_performer_order(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_performer_order() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    
    -- Set headliner flag based on performer type
    IF NEW.performer_type = 'headliner' THEN
        NEW.headliner = TRUE;
        NEW.featured = TRUE;
    ELSIF NEW.performer_type IN ('co_headliner', 'special_guest') THEN
        NEW.featured = TRUE;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: update_permissions_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_permissions_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;



--
-- Name: update_pricing_timestamp(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_pricing_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: update_refunds_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_refunds_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: update_roles_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_roles_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;



--
-- Name: update_schedule_metadata(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_schedule_metadata() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Update timestamp
    NEW.updated_at = NOW();
    
    -- Calculate duration if not provided
    IF NEW.duration IS NULL AND NEW.end_datetime IS NOT NULL THEN
        NEW.duration = NEW.end_datetime - NEW.start_datetime;
    END IF;
    
    -- Calculate end time if duration is provided but end time is not
    IF NEW.end_datetime IS NULL AND NEW.duration IS NOT NULL THEN
        NEW.end_datetime = NEW.start_datetime + NEW.duration;
    END IF;
    
    -- Set publish timestamp when status changes to published
    IF OLD.schedule_status != 'published' AND NEW.schedule_status = 'published' AND NEW.publish_datetime IS NULL THEN
        NEW.publish_datetime = NOW();
    END IF;
    
    -- Increment change count on updates
    IF TG_OP = 'UPDATE' AND (
        OLD.start_datetime != NEW.start_datetime OR 
        OLD.end_datetime IS DISTINCT FROM NEW.end_datetime
    ) THEN
        NEW.change_count = OLD.change_count + 1;
        NEW.last_change_datetime = NOW();
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: update_seo_last_modified(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_seo_last_modified() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.last_modified = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: update_session_activity(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_session_activity() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Update last activity timestamp
    NEW.last_activity_at = NOW();
    
    -- Calculate session duration if logging out
    IF NEW.logged_out_at IS NOT NULL AND OLD.logged_out_at IS NULL THEN
        NEW.session_duration_seconds = EXTRACT(EPOCH FROM (NEW.logged_out_at - NEW.created_at))::INTEGER;
        NEW.session_status = 'expired';
    END IF;
    
    -- Update concurrent session count
    IF NEW.session_status = 'active' AND OLD.session_status != 'active' THEN
        NEW.concurrent_sessions_count = (
            SELECT COUNT(*) 
            FROM sessions 
            WHERE user_id = NEW.user_id 
            AND session_status = 'active' 
            AND id != NEW.id
        ) + 1;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: update_settlement_status_timestamps(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_settlement_status_timestamps() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Set appropriate timestamp based on status change
    IF NEW.status != OLD.status THEN
        CASE NEW.status
            WHEN 'calculated' THEN
                NEW.calculated_at = CURRENT_TIMESTAMP;
            WHEN 'approved' THEN
                NEW.approved_at = CURRENT_TIMESTAMP;
            WHEN 'pending', 'processing' THEN
                IF NEW.initiated_at IS NULL THEN
                    NEW.initiated_at = CURRENT_TIMESTAMP;
                END IF;
                IF NEW.status = 'processing' THEN
                    NEW.processing_started_at = CURRENT_TIMESTAMP;
                END IF;
            WHEN 'completed' THEN
                NEW.completed_at = CURRENT_TIMESTAMP;
            WHEN 'failed' THEN
                NEW.failed_at = CURRENT_TIMESTAMP;
            WHEN 'cancelled' THEN
                NEW.cancelled_at = CURRENT_TIMESTAMP;
        END CASE;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: update_settlements_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_settlements_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: update_subscription_on_payment(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_subscription_on_payment() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   -- Only process subscription payments
   IF NEW.type = 'payment' AND NEW.status = 'succeeded' AND 
      EXISTS (SELECT 1 FROM public.invoices WHERE transaction_id = NEW.id AND subscription_id IS NOT NULL) THEN
       
       UPDATE public.subscriptions
       SET current_period_start = current_period_end,
           current_period_end = current_period_end + 
               CASE interval
                   WHEN 'daily' THEN INTERVAL '1 day' * interval_count
                   WHEN 'weekly' THEN INTERVAL '1 week' * interval_count
                   WHEN 'monthly' THEN INTERVAL '1 month' * interval_count
                   WHEN 'quarterly' THEN INTERVAL '3 months' * interval_count
                   WHEN 'yearly' THEN INTERVAL '1 year' * interval_count
               END
       WHERE id = (SELECT subscription_id FROM public.invoices WHERE transaction_id = NEW.id);
   END IF;
   
   RETURN NEW;
END;
$$;



--
-- Name: update_subscriptions_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_subscriptions_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: update_suspicious_sessions_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_suspicious_sessions_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;



--
-- Name: update_tag_usage(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_tag_usage() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE event_category_tags
        SET usage_count = usage_count + 1
        WHERE category_id = NEW.category_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE event_category_tags
        SET usage_count = GREATEST(0, usage_count - 1)
        WHERE category_id = OLD.category_id;
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$$;



--
-- Name: update_ticket_metadata_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_ticket_metadata_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: update_ticket_on_redemption(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_ticket_on_redemption() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   -- Update redemption count
   UPDATE public.tickets
   SET 
       redemption_count = redemption_count + 1,
       first_redeemed_at = COALESCE(first_redeemed_at, NEW.redeemed_at),
       last_redeemed_at = NEW.redeemed_at,
       status = CASE 
           WHEN redemption_count + 1 >= (
               SELECT max_redemptions_per_ticket 
               FROM public.ticket_types 
               WHERE id = tickets.ticket_type_id
           ) THEN 'REDEEMED'
           ELSE status
       END
   WHERE id = NEW.ticket_id;


   
   RETURN NEW;


END;


$$;



--
-- Name: update_ticket_quantities(uuid, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_ticket_quantities(p_ticket_type_id uuid, p_sold_change integer DEFAULT 0, p_reserved_change integer DEFAULT 0) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE ticket_types
    SET 
        sold_quantity = sold_quantity + p_sold_change,
        reserved_quantity = reserved_quantity + p_reserved_change,
        available_quantity = total_quantity - (sold_quantity + p_sold_change) - (reserved_quantity + p_reserved_change),
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_ticket_type_id;
    
    -- Update status if sold out
    UPDATE ticket_types
    SET status = CASE 
        WHEN available_quantity <= 0 AND status = 'ACTIVE' THEN 'SOLD_OUT'
        WHEN available_quantity > 0 AND status = 'SOLD_OUT' THEN 'ACTIVE'
        ELSE status
    END
    WHERE id = p_ticket_type_id;
END;
$$;



--
-- Name: update_ticket_refunds_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_ticket_refunds_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: update_ticket_timestamp(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_ticket_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: update_ticket_type_slug(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_ticket_type_slug() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.type_name != OLD.type_name OR NEW.type_slug IS NULL THEN
        NEW.type_slug := LOWER(REGEXP_REPLACE(REGEXP_REPLACE(NEW.type_name, '[^a-zA-Z0-9\s-]', '', 'g'), '\s+', '-', 'g'));
    END IF;
    RETURN NEW;
END;
$$;



--
-- Name: update_ticket_type_supply(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_ticket_type_supply() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   IF TG_OP = 'INSERT' THEN
       UPDATE public.ticket_types 
       SET current_supply = current_supply + 1
       WHERE id = NEW.ticket_type_id;


   ELSIF TG_OP = 'DELETE' THEN
       UPDATE public.ticket_types 
       SET current_supply = current_supply - 1
       WHERE id = OLD.ticket_type_id;


   END IF;


   RETURN NULL;


END;


$$;



--
-- Name: update_ticket_type_timestamp(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_ticket_type_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: update_transaction_status_timestamps(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_transaction_status_timestamps() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Set appropriate timestamp based on status change
    IF NEW.status != OLD.status THEN
        CASE NEW.status
            WHEN 'processing' THEN
                NEW.processing_started_at = CURRENT_TIMESTAMP;
            WHEN 'completed' THEN
                NEW.completed_at = CURRENT_TIMESTAMP;
            WHEN 'failed' THEN
                NEW.failed_at = CURRENT_TIMESTAMP;
            WHEN 'cancelled' THEN
                NEW.cancelled_at = CURRENT_TIMESTAMP;
        END CASE;
    END IF;
    
    -- Update refund tracking for refund transactions
    IF NEW.transaction_type = 'refund' AND NEW.status = 'completed' AND OLD.status != 'completed' THEN
        UPDATE transactions 
        SET refund_amount = refund_amount + ABS(NEW.amount),
            refund_count = refund_count + 1,
            is_fully_refunded = (refund_amount + ABS(NEW.amount) >= amount)
        WHERE id = NEW.parent_transaction_id;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: update_transactions_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_transactions_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: update_updated_at_column(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_updated_at_column() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;



--
-- Name: FUNCTION update_updated_at_column(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.update_updated_at_column() IS 'Trigger function to update updated_at timestamp';


--
-- Name: update_user_purchase_stats(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_user_purchase_stats() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP = 'INSERT' AND NEW.type = 'purchase' AND NEW.status = 'completed' THEN
        UPDATE users
        SET total_purchases = COALESCE(total_purchases, 0) + 1,
            total_spent = COALESCE(total_spent, 0) + NEW.amount,
            last_purchase_at = CURRENT_TIMESTAMP
        WHERE id = NEW.user_id;
    END IF;
    RETURN NULL;
END;
$$;



--
-- Name: update_users_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_users_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;



--
-- Name: update_venue_event_count(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_venue_event_count() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE venues 
        SET total_events = COALESCE(total_events, 0) + 1
        WHERE id = NEW.venue_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE venues 
        SET total_events = GREATEST(COALESCE(total_events, 0) - 1, 0)
        WHERE id = OLD.venue_id;
    END IF;
    RETURN NULL;
END;
$$;



--
-- Name: update_venue_hours_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_venue_hours_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;



--
-- Name: update_venue_integration_status(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_venue_integration_status() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    
    -- Update connection status based on last sync
    IF NEW.last_sync_at IS NOT NULL AND NEW.last_sync_at > NOW() - INTERVAL '1 hour' THEN
        NEW.is_connected = TRUE;
    ELSIF NEW.last_error IS NOT NULL THEN
        NEW.is_connected = FALSE;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: update_venue_metadata(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_venue_metadata() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Update timestamp
    NEW.updated_at = NOW();
    
    -- Calculate data quality score based on completeness
    NEW.data_quality_score = (
        CASE WHEN NEW.venue_name IS NOT NULL AND TRIM(NEW.venue_name) != '' THEN 10 ELSE 0 END +
        CASE WHEN NEW.short_description IS NOT NULL AND TRIM(NEW.short_description) != '' THEN 10 ELSE 0 END +
        CASE WHEN NEW.address_line_1 IS NOT NULL AND TRIM(NEW.address_line_1) != '' THEN 15 ELSE 0 END +
        CASE WHEN NEW.city IS NOT NULL AND TRIM(NEW.city) != '' THEN 10 ELSE 0 END +
        CASE WHEN NEW.primary_phone IS NOT NULL THEN 10 ELSE 0 END +
        CASE WHEN NEW.primary_email IS NOT NULL THEN 10 ELSE 0 END +
        CASE WHEN NEW.total_capacity IS NOT NULL THEN 10 ELSE 0 END +
        CASE WHEN NEW.latitude IS NOT NULL AND NEW.longitude IS NOT NULL THEN 10 ELSE 0 END +
        CASE WHEN NEW.website_url IS NOT NULL THEN 5 ELSE 0 END +
        CASE WHEN NEW.logo_url IS NOT NULL THEN 5 ELSE 0 END +
        CASE WHEN NEW.cover_image_url IS NOT NULL THEN 5 ELSE 0 END
    );
    
    -- Generate slug if not provided
    IF NEW.venue_slug IS NULL OR NEW.venue_slug = '' THEN
        NEW.venue_slug = lower(regexp_replace(NEW.venue_name, '[^a-zA-Z0-9]+', '-', 'g'));
        NEW.venue_slug = trim(NEW.venue_slug, '-');
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: update_venue_policy_version(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_venue_policy_version() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    
    -- Auto-increment version on content changes
    IF TG_OP = 'UPDATE' AND OLD.policy_text IS DISTINCT FROM NEW.policy_text THEN
        NEW.version = (
            SELECT COALESCE(MAX(CAST(regexp_replace(version, '[^0-9.]', '', 'g') AS NUMERIC)), 0) + 0.1
            FROM venue_policies 
            WHERE venue_id = NEW.venue_id AND policy_type = NEW.policy_type
        )::TEXT;
        NEW.previous_version_id = OLD.id;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: update_venue_setting_metadata(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_venue_setting_metadata() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Update timestamp
    NEW.updated_at = NOW();
    
    -- Handle setting value encryption for sensitive data
    IF NEW.is_sensitive = TRUE AND NEW.setting_value IS NOT NULL THEN
        NEW.setting_value_encrypted = pgp_sym_encrypt(NEW.setting_value, 'venue_settings_key');
        NEW.setting_value = NULL;
    END IF;
    
    -- Auto-increment version on value changes
    IF TG_OP = 'UPDATE' AND (
        OLD.setting_value IS DISTINCT FROM NEW.setting_value OR
        OLD.setting_value_json IS DISTINCT FROM NEW.setting_value_json
    ) THEN
        NEW.version = OLD.version + 1;
        
        -- Create version history by marking old version as inactive
        UPDATE venue_settings 
        SET is_active = FALSE 
        WHERE id = OLD.id;
        
        -- Create new version
        NEW.id = uuid_generate_v1();
        NEW.parent_setting_id = OLD.id;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: update_venue_staff_metadata(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_venue_staff_metadata() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Update timestamp
    NEW.updated_at = NOW();
    
    -- Auto-generate employee ID if not provided
    IF NEW.employee_id IS NULL THEN
        NEW.employee_id = 'EMP-' || EXTRACT(YEAR FROM NEW.hire_date) || '-' || 
                          LPAD(nextval('venue_staff_employee_seq')::text, 4, '0');
    END IF;
    
    -- Set probation end date for new hires (90 days default)
    IF TG_OP = 'INSERT' AND NEW.probation_end_date IS NULL AND NEW.employment_type IN ('full_time', 'part_time') THEN
        NEW.probation_end_date = NEW.hire_date + INTERVAL '90 days';
    END IF;
    
    -- Update employment status based on dates
    IF NEW.termination_date IS NOT NULL AND NEW.employment_status NOT IN ('terminated', 'contract_ended') THEN
        NEW.employment_status = 'terminated';
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: update_venue_verification(uuid, public.verification_status, uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_venue_verification(p_venue_id uuid, p_verification_status public.verification_status, p_verified_by_user_id uuid DEFAULT NULL::uuid, p_notes text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE venues
    SET verification_status = p_verification_status,
        verified_at = CASE WHEN p_verification_status = 'verified' THEN NOW() ELSE verified_at END,
        verified_by_user_id = p_verified_by_user_id,
        updated_at = NOW()
    WHERE id = p_venue_id
    AND deleted_at IS NULL;
    
    -- Log verification change in audit trail if function exists
    IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'log_audit_event') THEN
        PERFORM log_audit_event(
            p_verified_by_user_id,
            'venue_management'::audit_category,
            'update'::audit_action,
            'venue',
            p_venue_id::text,
            NULL,
            'Venue verification status updated to ' || p_verification_status::text,
            NULL,
            jsonb_build_object('verification_status', p_verification_status, 'notes', p_notes),
            'info'::audit_severity
        );
    END IF;
    
    RETURN FOUND;
END;
$$;



--
-- Name: update_violation_metrics(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_violation_metrics() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    
    -- Calculate operational impact based on severity
    IF NEW.severity = 'critical' THEN
        NEW.operational_impact = 'severe';
    ELSIF NEW.severity = 'major' THEN
        NEW.operational_impact = 'moderate';
    ELSE
        NEW.operational_impact = 'minimal';
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: update_wallet_addresses_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_wallet_addresses_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
   NEW.updated_at = CURRENT_TIMESTAMP;
   RETURN NEW;
END;
$$;



--
-- Name: update_webhook_metrics(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_webhook_metrics() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Update timestamp
    NEW.updated_at = NOW();
    
    -- Update webhook status based on failures
    IF NEW.consecutive_failures >= NEW.max_failures_before_disable THEN
        NEW.webhook_status = 'failed';
    ELSIF NEW.consecutive_failures = 0 AND OLD.consecutive_failures > 0 THEN
        NEW.webhook_status = 'active';
    END IF;
    
    -- Calculate delivery success rate
    IF NEW.total_deliveries > 0 THEN
        NEW.successful_deliveries = NEW.total_deliveries - NEW.failed_deliveries;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: user_has_permission(uuid, character varying, uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.user_has_permission(p_user_id uuid, p_permission_name character varying, p_venue_id uuid DEFAULT NULL::uuid, p_event_id uuid DEFAULT NULL::uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    has_permission BOOLEAN := FALSE;
    permission_uuid UUID;
BEGIN
    -- Get permission ID
    SELECT id INTO permission_uuid 
    FROM permissions 
    WHERE permission_name = p_permission_name 
    AND is_active = true 
    AND deleted_at IS NULL;
    
    IF permission_uuid IS NULL THEN
        RETURN FALSE;
    END IF;
    
    -- Check direct user permissions first (takes precedence)
    SELECT is_granted INTO has_permission
    FROM user_permissions up
    WHERE up.user_id = p_user_id
    AND up.permission_id = permission_uuid
    AND up.is_active = true
    AND (up.expires_at IS NULL OR up.expires_at > NOW())
    AND (p_venue_id IS NULL OR up.venue_id IS NULL OR up.venue_id = p_venue_id)
    AND (p_event_id IS NULL OR up.event_id IS NULL OR up.event_id = p_event_id)
    ORDER BY up.venue_id NULLS LAST, up.event_id NULLS LAST
    LIMIT 1;
    
    -- If direct permission found, return it
    IF has_permission IS NOT NULL THEN
        RETURN has_permission;
    END IF;
    
    -- Check role-based permissions
    SELECT COUNT(*) > 0 INTO has_permission
    FROM user_roles ur
    JOIN role_permissions rp ON ur.role_id = rp.role_id
    WHERE ur.user_id = p_user_id
    AND rp.permission_id = permission_uuid
    AND ur.is_active = true
    AND (ur.expires_at IS NULL OR ur.expires_at > NOW())
    AND (p_venue_id IS NULL OR rp.venue_id IS NULL OR rp.venue_id = p_venue_id)
    AND (p_event_id IS NULL OR rp.event_id IS NULL OR rp.event_id = p_event_id);
    
    RETURN COALESCE(has_permission, FALSE);
END;
$$;



--
-- Name: user_has_permission_level(uuid, public.role_permission_level, uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.user_has_permission_level(p_user_id uuid, p_required_level public.role_permission_level, p_venue_id uuid DEFAULT NULL::uuid, p_event_id uuid DEFAULT NULL::uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    user_max_level role_permission_level;
    level_hierarchy INTEGER;
    required_hierarchy INTEGER;
BEGIN
    -- Define permission level hierarchy (lower number = higher permission)
    CASE p_required_level
        WHEN 'super_admin' THEN required_hierarchy := 1;
        WHEN 'admin' THEN required_hierarchy := 2;
        WHEN 'manager' THEN required_hierarchy := 3;
        WHEN 'staff' THEN required_hierarchy := 4;
        WHEN 'customer' THEN required_hierarchy := 5;
        ELSE required_hierarchy := 999;
    END CASE;
    
    -- Get user's highest permission level
    SELECT MIN(
        CASE r.permission_level
            WHEN 'super_admin' THEN 1
            WHEN 'admin' THEN 2
            WHEN 'manager' THEN 3
            WHEN 'staff' THEN 4
            WHEN 'customer' THEN 5
            ELSE 999
        END
    )
    INTO level_hierarchy
    FROM user_roles ur
    JOIN roles r ON ur.role_id = r.id
    WHERE ur.user_id = p_user_id
    AND ur.is_active = true
    AND (ur.expires_at IS NULL OR ur.expires_at > NOW())
    AND (p_venue_id IS NULL OR ur.venue_id IS NULL OR ur.venue_id = p_venue_id)
    AND (p_event_id IS NULL OR ur.event_id IS NULL OR ur.event_id = p_event_id)
    AND r.role_status = 'active'
    AND r.deleted_at IS NULL;
    
    RETURN COALESCE(level_hierarchy <= required_hierarchy, false);
END;
$$;



--
-- Name: validate_json_schema(jsonb, jsonb); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.validate_json_schema(data jsonb, schema jsonb) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
   -- Simplified validation - extend as needed
   RETURN data IS NOT NULL AND jsonb_typeof(data) = 'object';
END;
$$;



--
-- Name: FUNCTION validate_json_schema(data jsonb, schema jsonb); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.validate_json_schema(data jsonb, schema jsonb) IS 'Validate JSON data against schema';


--
-- Name: validate_layout_accessibility(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.validate_layout_accessibility() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    total_seats INTEGER;
    accessible_seats INTEGER;
    min_required INTEGER;
BEGIN
    NEW.updated_at = NOW();
    
    -- Calculate ADA compliance
    IF TG_OP = 'UPDATE' OR TG_OP = 'INSERT' THEN
        SELECT COALESCE(SUM(section_capacity), 0) INTO total_seats
        FROM layout_sections
        WHERE layout_id = NEW.id
        AND section_type IN ('seating', 'vip', 'box', 'balcony', 'orchestra', 'gallery')
        AND is_active = TRUE;
        
        SELECT COALESCE(SUM(wheelchair_seats), 0) INTO accessible_seats
        FROM layout_sections
        WHERE layout_id = NEW.id
        AND is_active = TRUE;
        
        -- Calculate minimum required accessible seats (typically 1% with minimum of 2)
        min_required = GREATEST(CEIL(total_seats * 0.01), 2);
        
        -- Update ADA compliance status
        NEW.ada_compliant = (accessible_seats >= min_required);
        
        -- Add validation notes if not compliant
        IF NOT NEW.ada_compliant THEN
            NEW.validation_notes = COALESCE(NEW.validation_notes || '; ', '') || 
                                 'ADA non-compliant: ' || accessible_seats || ' accessible seats provided, ' || 
                                 min_required || ' required';
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: validate_metadata(character varying, character varying, text, jsonb); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.validate_metadata(p_metadata_type character varying, p_metadata_key character varying, p_metadata_value text, p_validation_rules jsonb) RETURNS TABLE(is_valid boolean, error_messages text[])
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_errors TEXT[] := ARRAY[]::TEXT[];
    v_rule JSONB;
    v_min_length INTEGER;
    v_max_length INTEGER;
    v_pattern TEXT;
    v_required BOOLEAN;
BEGIN
    -- Return valid if no rules
    IF p_validation_rules IS NULL OR p_validation_rules = '{}'::JSONB THEN
        RETURN QUERY SELECT true, ARRAY[]::TEXT[];
        RETURN;
    END IF;
    
    -- Check required
    v_required := COALESCE((p_validation_rules->>'required')::BOOLEAN, false);
    IF v_required AND (p_metadata_value IS NULL OR p_metadata_value = '') THEN
        v_errors := array_append(v_errors, 'Field is required');
    END IF;
    
    -- Skip other validations if value is empty and not required
    IF p_metadata_value IS NULL OR p_metadata_value = '' THEN
        RETURN QUERY SELECT array_length(v_errors, 1) = 0, v_errors;
        RETURN;
    END IF;
    
    -- Check minimum length
    v_min_length := (p_validation_rules->>'min_length')::INTEGER;
    IF v_min_length IS NOT NULL AND LENGTH(p_metadata_value) < v_min_length THEN
        v_errors := array_append(v_errors, 'Minimum length is ' || v_min_length || ' characters');
    END IF;
    
    -- Check maximum length
    v_max_length := (p_validation_rules->>'max_length')::INTEGER;
    IF v_max_length IS NOT NULL AND LENGTH(p_metadata_value) > v_max_length THEN
        v_errors := array_append(v_errors, 'Maximum length is ' || v_max_length || ' characters');
    END IF;
    
    -- Check pattern
    v_pattern := p_validation_rules->>'pattern';
    IF v_pattern IS NOT NULL AND NOT (p_metadata_value ~ v_pattern) THEN
        v_errors := array_append(v_errors, 'Value does not match required pattern');
    END IF;
    
    RETURN QUERY SELECT array_length(v_errors, 1) = 0 OR v_errors IS NULL, COALESCE(v_errors, ARRAY[]::TEXT[]);
END;
$$;



--
-- Name: validate_metadata_attributes(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.validate_metadata_attributes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Ensure attributes is an array
    IF jsonb_typeof(NEW.attributes) != 'array' THEN
        RAISE EXCEPTION 'attributes must be a JSON array';
    END IF;
    
    -- Set minted_at timestamp when status changes to minted
    IF NEW.blockchain_status = 'minted' AND OLD.blockchain_status != 'minted' THEN
        NEW.minted_at = CURRENT_TIMESTAMP;
    END IF;
    
    -- Generate metadata hash if not provided
    IF NEW.metadata_hash IS NULL THEN
        NEW.metadata_hash = encode(
            sha256(
                (NEW.attributes::text || COALESCE(NEW.image_url, '') || COALESCE(NEW.name, ''))::bytea
            ), 
            'hex'
        );
    END IF;
    
    -- Auto-generate IPFS gateway URL if hash is provided
    IF NEW.ipfs_hash IS NOT NULL AND NEW.ipfs_gateway_url IS NULL THEN
        NEW.ipfs_gateway_url = 'https://ipfs.io/ipfs/' || NEW.ipfs_hash;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: validate_promo_code(uuid, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.validate_promo_code(p_event_pricing_id uuid, p_promo_code character varying) RETURNS TABLE(is_valid boolean, discount_amount numeric, error_message text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_promo RECORD;
    v_usage_count INTEGER;
BEGIN
    SELECT * INTO v_promo
    FROM event_pricing_promo_codes
    WHERE event_pricing_id = p_event_pricing_id
      AND promo_code = p_promo_code
      AND is_active = true;
    
    IF NOT FOUND THEN
        RETURN QUERY SELECT false, 0::DECIMAL(10,2), 'Invalid promo code';
        RETURN;
    END IF;
    
    -- Check date validity
    IF v_promo.valid_from IS NOT NULL AND CURRENT_TIMESTAMP < v_promo.valid_from THEN
        RETURN QUERY SELECT false, 0::DECIMAL(10,2), 'Promo code not yet valid';
        RETURN;
    END IF;
    
    IF v_promo.valid_until IS NOT NULL AND CURRENT_TIMESTAMP > v_promo.valid_until THEN
        RETURN QUERY SELECT false, 0::DECIMAL(10,2), 'Promo code has expired';
        RETURN;
    END IF;
    
    -- Check usage limits
    IF v_promo.usage_limit IS NOT NULL AND v_promo.times_used >= v_promo.usage_limit THEN
        RETURN QUERY SELECT false, 0::DECIMAL(10,2), 'Promo code usage limit exceeded';
        RETURN;
    END IF;
    
    RETURN QUERY SELECT true, v_promo.discount_value, 'Valid promo code';
END;
$$;



--
-- Name: validate_redemption(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.validate_redemption() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Check if ticket has already been redeemed for this event
    IF NEW.redemption_type = 'entry' AND NEW.entry_granted = TRUE THEN
        IF EXISTS (
            SELECT 1 FROM ticket_redemptions 
            WHERE ticket_id = NEW.ticket_id 
            AND event_id = NEW.event_id 
            AND redemption_type = 'entry' 
            AND entry_granted = TRUE 
            AND id != NEW.id
        ) THEN
            NEW.entry_granted = FALSE;
            NEW.denial_reason = 'Ticket already redeemed';
            NEW.duplicate_attempts = COALESCE(
                (SELECT MAX(duplicate_attempts) + 1 
                 FROM ticket_redemptions 
                 WHERE ticket_id = NEW.ticket_id AND event_id = NEW.event_id),
                1
            );
            NEW.suspicious_activity = TRUE;
            NEW.suspicious_activity_details = jsonb_build_object(
                'reason', 'Duplicate redemption attempt',
                'timestamp', CURRENT_TIMESTAMP
            );
        END IF;
    END IF;
    
    -- Set verified_at timestamp
    IF NEW.entry_granted = TRUE AND NEW.verified_at IS NULL THEN
        NEW.verified_at = CURRENT_TIMESTAMP;
    END IF;
    
    -- Set entry_granted_at timestamp
    IF NEW.entry_granted = TRUE AND NEW.entry_granted_at IS NULL THEN
        NEW.entry_granted_at = CURRENT_TIMESTAMP;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: validate_seat_selection(uuid[], boolean, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.validate_seat_selection(p_seat_ids uuid[], p_requires_wheelchair boolean DEFAULT false, p_requires_companion boolean DEFAULT false) RETURNS TABLE(is_valid boolean, validation_message text, suggested_alternatives uuid[])
    LANGUAGE plpgsql
    AS $$
DECLARE
    wheelchair_count INTEGER := 0;
    companion_count INTEGER := 0;
    total_seats INTEGER;
    message TEXT := '';
    alternatives UUID[] := '{}';
BEGIN
    total_seats := array_length(p_seat_ids, 1);
    
    -- Count wheelchair and companion seats in selection
    SELECT COUNT(*) FILTER (WHERE is_accessible = TRUE),
           COUNT(*) FILTER (WHERE is_companion = TRUE)
    INTO wheelchair_count, companion_count
    FROM layout_seats
    WHERE id = ANY(p_seat_ids);
    
    -- Validate wheelchair requirements
    IF p_requires_wheelchair AND wheelchair_count = 0 THEN
        message := 'Wheelchair accessible seat required but none selected';
        
        -- Find alternative wheelchair seats in same sections
        SELECT array_agg(id) INTO alternatives
        FROM layout_seats
        WHERE section_id IN (
            SELECT DISTINCT section_id FROM layout_seats WHERE id = ANY(p_seat_ids)
        )
        AND is_accessible = TRUE
        AND is_active = TRUE
        AND is_saleable = TRUE
        LIMIT 5;
        
        RETURN QUERY SELECT FALSE, message, alternatives;
        RETURN;
    END IF;
    
    -- Validate companion seat requirements
    IF p_requires_companion AND companion_count = 0 AND wheelchair_count > 0 THEN
        message := 'Companion seat recommended for wheelchair accessible selection';
        
        -- This is a warning, not a blocking validation
        RETURN QUERY SELECT TRUE, message, alternatives;
        RETURN;
    END IF;
    
    -- All validations passed
    RETURN QUERY SELECT TRUE, 'Seat selection is valid'::TEXT, alternatives;
END;
$$;



--
-- Name: validate_session(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.validate_session(p_session_token character varying) RETURNS TABLE(session_id uuid, user_id uuid, is_valid boolean, expires_at timestamp with time zone, risk_level public.session_risk_level)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT s.id, s.user_id, 
           (s.session_status = 'active' AND s.expires_at > NOW()) as is_valid,
           s.expires_at, s.risk_level
    FROM sessions s
    WHERE s.session_token = p_session_token;
END;
$$;



--
-- Name: validate_ticket_entry(uuid, character varying, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.validate_ticket_entry(p_ticket_id uuid, p_validation_location character varying DEFAULT NULL::character varying, p_validated_by uuid DEFAULT NULL::uuid) RETURNS TABLE(is_valid boolean, validation_result character varying, error_message text, entry_allowed boolean)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_ticket RECORD;
    v_validation_id UUID;
    v_now TIMESTAMP WITH TIME ZONE := CURRENT_TIMESTAMP;
    v_last_scan TIMESTAMP WITH TIME ZONE;
    v_fraud_flags TEXT[] := ARRAY[]::TEXT[];
    v_confidence DECIMAL(3,2) := 1.00;
BEGIN
    -- Get ticket details
    SELECT t.*, e.event_date, e.event_start_time INTO v_ticket
    FROM tickets t
    JOIN events e ON t.event_id = e.id
    WHERE t.id = p_ticket_id;
    
    IF NOT FOUND THEN
        RETURN QUERY SELECT false, 'INVALID', 'Ticket not found', false;
        RETURN;
    END IF;
    
    -- Check ticket status
    IF v_ticket.status NOT IN ('SOLD', 'TRANSFERRED') THEN
        RETURN QUERY SELECT false, 'INVALID', 'Ticket status: ' || v_ticket.status, false;
        RETURN;
    END IF;
    
    -- Check if ticket is active
    IF NOT v_ticket.is_active THEN
        RETURN QUERY SELECT false, 'INVALID', 'Ticket is not active', false;
        RETURN;
    END IF;
    
    -- Check valid date range
    IF v_ticket.valid_from IS NOT NULL AND v_now < v_ticket.valid_from THEN
        RETURN QUERY SELECT false, 'INVALID', 'Ticket not yet valid', false;
        RETURN;
    END IF;
    
    IF v_ticket.valid_until IS NOT NULL AND v_now > v_ticket.valid_until THEN
        RETURN QUERY SELECT false, 'EXPIRED', 'Ticket has expired', false;
        RETURN;
    END IF;
    
    -- Check entry time windows
    IF v_ticket.entry_allowed_from IS NOT NULL AND v_now < v_ticket.entry_allowed_from THEN
        RETURN QUERY SELECT false, 'INVALID', 'Entry not yet allowed', false;
        RETURN;
    END IF;
    
    IF v_ticket.entry_cutoff IS NOT NULL AND v_now > v_ticket.entry_cutoff THEN
        RETURN QUERY SELECT false, 'EXPIRED', 'Entry cutoff time passed', false;
        RETURN;
    END IF;
    
    -- Check for recent duplicate scans
    SELECT last_scanned_at INTO v_last_scan
    FROM tickets WHERE id = p_ticket_id;
    
    IF v_last_scan IS NOT NULL AND v_now - v_last_scan < INTERVAL '30 seconds' THEN
        v_fraud_flags := array_append(v_fraud_flags, 'RAPID_SCAN');
        v_confidence := v_confidence - 0.3;
    END IF;
    
    -- Check if already used (for single-entry tickets)
    IF v_ticket.scan_count > 0 AND v_ticket.first_scanned_at IS NOT NULL THEN
        -- Allow re-entry within 15 minutes for legitimate cases
        IF v_now - v_ticket.first_scanned_at > INTERVAL '15 minutes' THEN
            RETURN QUERY SELECT false, 'USED', 'Ticket already used', false;
            RETURN;
        ELSE
            v_fraud_flags := array_append(v_fraud_flags, 'RECENT_REENTRY');
            v_confidence := v_confidence - 0.2;
        END IF;
    END IF;
    
    -- Update ticket scan information
    UPDATE tickets
    SET 
        scan_count = scan_count + 1,
        last_scanned_at = v_now,
        first_scanned_at = COALESCE(first_scanned_at, v_now),
        updated_at = v_now
    WHERE id = p_ticket_id;
    
    -- Log validation
    INSERT INTO ticket_validations (
        ticket_id, validation_type, validation_method, validation_result,
        validation_location, validated_by_user_id, fraud_flags,
        confidence_score, duplicate_scan_detected,
        time_since_last_scan
    ) VALUES (
        p_ticket_id, 'ENTRY_SCAN', 'QR_SCAN', 'VALID',
        p_validation_location, p_validated_by, v_fraud_flags,
        v_confidence, array_length(v_fraud_flags, 1) > 0,
        CASE WHEN v_last_scan IS NOT NULL THEN v_now - v_last_scan ELSE NULL END
    ) RETURNING id INTO v_validation_id;
    
    RETURN QUERY SELECT true, 'VALID', NULL, true;
END;
$$;



--
-- Name: validate_ticket_ownership(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.validate_ticket_ownership() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_owner_id uuid;
BEGIN
  SELECT owner_id INTO v_owner_id
  FROM public.tickets
  WHERE id = NEW.ticket_id;

  IF v_owner_id IS NULL THEN
    RAISE EXCEPTION 'Ticket % not found', NEW.ticket_id;
  END IF;

  IF v_owner_id <> NEW.seller_id THEN
    RAISE EXCEPTION 'Cannot list ticket you do not own';
  END IF;

  RETURN NEW;
END
$$;



--
-- Name: validate_ticket_purchase_price(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.validate_ticket_purchase_price() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.face_value < 0 THEN
        RAISE EXCEPTION 'Ticket purchase price cannot be negative';
    END IF;
    
    IF NEW.face_value > 10000 THEN
        RAISE EXCEPTION 'Ticket purchase price exceeds maximum allowed';
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: validate_ticket_redemption(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.validate_ticket_redemption(p_ticket_id uuid, p_event_schedule_id uuid DEFAULT NULL::uuid) RETURNS TABLE(is_valid boolean, error_message text)
    LANGUAGE plpgsql
    AS $$
DECLARE
   v_ticket RECORD;


   v_ticket_type RECORD;


   v_event RECORD;


   v_schedule RECORD;


BEGIN
   -- Get ticket details
   SELECT t.*, tt.max_redemptions_per_ticket
   INTO v_ticket
   FROM public.tickets t
   JOIN public.ticket_types tt ON t.ticket_type_id = tt.id
   WHERE t.id = p_ticket_id;


   
   IF NOT FOUND THEN
       RETURN QUERY SELECT FALSE, 'Ticket not found';


       RETURN;


   END IF;


   
   -- Check ticket status
   IF v_ticket.status NOT IN ('ACTIVE', 'TRANSFERRED') THEN
       RETURN QUERY SELECT FALSE, 'Ticket status is ' || v_ticket.status;


       RETURN;


   END IF;


   
   -- Check if ticket is valid
   IF NOT v_ticket.is_valid THEN
       RETURN QUERY SELECT FALSE, 'Ticket has been invalidated: ' || COALESCE(v_ticket.invalidation_reason, 'Unknown reason');


       RETURN;


   END IF;


   
   -- Check redemption limit
   IF v_ticket.redemption_count >= v_ticket.max_redemptions_per_ticket THEN
       RETURN QUERY SELECT FALSE, 'Ticket has reached maximum redemptions';


       RETURN;


   END IF;


   
   -- All checks passed
   RETURN QUERY SELECT TRUE, NULL::TEXT;


END;


$$;



--
-- Name: validate_ticket_status_transition(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.validate_ticket_status_transition() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF TG_OP <> 'UPDATE' THEN
    RETURN NEW;
  END IF;

  IF OLD.status = 'DRAFT' AND NEW.status NOT IN ('MINTING','ACTIVE','CANCELLED') THEN
    RAISE EXCEPTION 'Invalid status transition from DRAFT to %', NEW.status;
  ELSIF OLD.status = 'MINTING' AND NEW.status NOT IN ('ACTIVE','FAILED') THEN
    RAISE EXCEPTION 'Invalid status transition from MINTING to %', NEW.status;
  ELSIF OLD.status = 'ACTIVE' AND NEW.status NOT IN ('LISTED','TRANSFERRED','REDEEMED','CANCELLED') THEN
    RAISE EXCEPTION 'Invalid status transition from ACTIVE to %', NEW.status;
  ELSIF OLD.status = 'REDEEMED' THEN
    RAISE EXCEPTION 'Cannot change status after ticket is REDEEMED';
  ELSIF OLD.status = 'CANCELLED' THEN
    RAISE EXCEPTION 'Cannot change status after ticket is CANCELLED';
  END IF;

  RETURN NEW;
END
$$;



--
-- Name: validate_ticket_transfer(uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.validate_ticket_transfer(p_ticket_id uuid, p_from_user_id uuid, p_to_user_id uuid) RETURNS TABLE(is_valid boolean, error_code character varying, error_message text)
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    v_ticket RECORD;
    v_event RECORD;
BEGIN
    -- Get ticket details
    SELECT t.*, e.start_date, e.transfer_freeze_time, e.allow_transfers
    INTO v_ticket
    FROM tickets t
    JOIN events e ON e.id = t.event_id
    WHERE t.id = p_ticket_id;
    
    -- Check ticket exists
    IF NOT FOUND THEN
        RETURN QUERY SELECT FALSE, 'TICKET_NOT_FOUND', 'Ticket does not exist';
        RETURN;
    END IF;
    
    -- Check ownership
    IF v_ticket.customer_id != p_from_user_id THEN
        RETURN QUERY SELECT FALSE, 'NOT_OWNER', 'User does not own this ticket';
        RETURN;
    END IF;
    
    -- Check ticket status
    IF v_ticket.status != 'ACTIVE' THEN
        RETURN QUERY SELECT FALSE, 'INVALID_STATUS', 'Ticket status is ' || v_ticket.status;
        RETURN;
    END IF;
    
    -- Check if transfers allowed
    IF NOT v_ticket.allow_transfers THEN
        RETURN QUERY SELECT FALSE, 'TRANSFERS_DISABLED', 'Transfers are disabled for this event';
        RETURN;
    END IF;
    
    -- Check transfer freeze
    IF v_ticket.transfer_freeze_time IS NOT NULL AND CURRENT_TIMESTAMP >= v_ticket.transfer_freeze_time THEN
        RETURN QUERY SELECT FALSE, 'TRANSFER_FROZEN', 'Transfer window has closed';
        RETURN;
    END IF;
    
    -- Check if transferring to self
    IF p_from_user_id = p_to_user_id THEN
        RETURN QUERY SELECT FALSE, 'SELF_TRANSFER', 'Cannot transfer to yourself';
        RETURN;
    END IF;
    
    -- All checks passed
    RETURN QUERY SELECT TRUE, NULL::VARCHAR(50), NULL::TEXT;
END;
$$;



--
-- Name: FUNCTION validate_ticket_transfer(p_ticket_id uuid, p_from_user_id uuid, p_to_user_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.validate_ticket_transfer(p_ticket_id uuid, p_from_user_id uuid, p_to_user_id uuid) IS 'Validates if a ticket transfer is allowed';


--
-- Name: validate_transfer_eligibility(uuid, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.validate_transfer_eligibility(p_ticket_id uuid, p_hours_until_event integer DEFAULT NULL::integer) RETURNS TABLE(is_eligible boolean, error_message text, transfer_fee numeric)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_ticket RECORD;
    v_policy RECORD;
    v_transfer_count INTEGER;
BEGIN
    -- Get ticket and policy info
    SELECT t.*, tt.is_transferable INTO v_ticket
    FROM tickets t
    JOIN ticket_types tt ON t.ticket_type_id = tt.id
    WHERE t.id = p_ticket_id;
    
    IF NOT FOUND THEN
        RETURN QUERY SELECT false, 'Ticket not found', 0::DECIMAL(10,2);
        RETURN;
    END IF;
    
    -- Check if transfers are allowed for this ticket type
    IF NOT v_ticket.is_transferable THEN
        RETURN QUERY SELECT false, 'This ticket type is not transferable', 0::DECIMAL(10,2);
        RETURN;
    END IF;
    
    -- Get transfer policy
    SELECT * INTO v_policy
    FROM ticket_type_transfer_policies
    WHERE ticket_type_id = v_ticket.ticket_type_id;
    
    IF NOT FOUND OR NOT v_policy.transfer_allowed THEN
        RETURN QUERY SELECT false, 'Transfers not allowed for this ticket type', 0::DECIMAL(10,2);
        RETURN;
    END IF;
    
    -- Check transfer deadline
    IF v_policy.transfer_deadline_hours IS NOT NULL AND 
       p_hours_until_event IS NOT NULL AND 
       p_hours_until_event < v_policy.transfer_deadline_hours THEN
        RETURN QUERY SELECT false, 'Transfer deadline has passed', 0::DECIMAL(10,2);
        RETURN;
    END IF;
    
    -- Check transfer limits
    SELECT COUNT(*) INTO v_transfer_count
    FROM ticket_transfers
    WHERE original_ticket_id = p_ticket_id;
    
    IF v_transfer_count >= v_policy.max_transfers_per_ticket THEN
        RETURN QUERY SELECT false, 'Maximum transfers exceeded for this ticket', 0::DECIMAL(10,2);
        RETURN;
    END IF;
    
    RETURN QUERY SELECT true, NULL, COALESCE(v_policy.transfer_fee, 0);
END;
$$;



--
-- Name: validate_transfer_status_transition(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.validate_transfer_status_transition() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Only allow valid status transitions
    IF OLD.status = 'completed' OR OLD.status = 'cancelled' THEN
        RAISE EXCEPTION 'Cannot modify a transfer that is already % ', OLD.status;
    END IF;
    
    -- Set completion timestamps based on new status
    IF NEW.status = 'completed' AND OLD.status != 'completed' THEN
        NEW.completed_at = CURRENT_TIMESTAMP;
    ELSIF NEW.status = 'cancelled' AND OLD.status != 'cancelled' THEN
        NEW.cancelled_at = CURRENT_TIMESTAMP;
    END IF;
    
    RETURN NEW;
END;
$$;



--
-- Name: validate_venue_settings(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.validate_venue_settings(p_venue_id uuid) RETURNS TABLE(setting_key character varying, validation_error text, severity character varying)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    -- Check required settings
    SELECT vs.setting_key, 'Required setting is missing or empty' as validation_error, 'error' as severity
    FROM venue_settings vs
    WHERE vs.venue_id = p_venue_id
    AND vs.is_required = TRUE
    AND vs.is_active = TRUE
    AND (vs.setting_value IS NULL OR TRIM(vs.setting_value) = '')
    AND vs.setting_value_json IS NULL
    
    UNION ALL
    
    -- Check numeric ranges
    SELECT vs.setting_key, 'Value is outside allowed range' as validation_error, 'error' as severity
    FROM venue_settings vs
    WHERE vs.venue_id = p_venue_id
    AND vs.is_active = TRUE
    AND vs.data_type IN ('integer', 'decimal')
    AND vs.setting_value IS NOT NULL
    AND (
        (vs.min_value IS NOT NULL AND vs.setting_value::DECIMAL < vs.min_value) OR
        (vs.max_value IS NOT NULL AND vs.setting_value::DECIMAL > vs.max_value)
    )
    
    UNION ALL
    
    -- Check allowed values
    SELECT vs.setting_key, 'Value is not in allowed list' as validation_error, 'error' as severity
    FROM venue_settings vs
    WHERE vs.venue_id = p_venue_id
    AND vs.is_active = TRUE
    AND vs.allowed_values IS NOT NULL
    AND vs.setting_value IS NOT NULL
    AND NOT (vs.setting_value = ANY(vs.allowed_values));
END;
$$;



--
-- Name: venue_distance(numeric, numeric, numeric, numeric); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.venue_distance(lat1 numeric, lon1 numeric, lat2 numeric, lon2 numeric) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
    R NUMERIC := 6371; -- Earth radius in km
    dlat NUMERIC;
    dlon NUMERIC;
    a NUMERIC;
    c NUMERIC;
BEGIN
    dlat := RADIANS(lat2 - lat1);
    dlon := RADIANS(lon2 - lon1);
    a := SIN(dlat/2) * SIN(dlat/2) + COS(RADIANS(lat1)) * COS(RADIANS(lat2)) * SIN(dlon/2) * SIN(dlon/2);
    c := 2 * ATAN2(SQRT(a), SQRT(1-a));
    RETURN R * c;
END;
$$;



--
-- Name: verify_signature(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.verify_signature(p_message text, p_signature text, p_public_key text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE PARALLEL SAFE
    AS $$
DECLARE
    v_is_valid BOOLEAN;
BEGIN
    -- This is a placeholder implementation
    -- In production, would use actual Ed25519 signature verification
    
    -- Basic validation
    IF LENGTH(p_signature) != 88 THEN -- Base58 encoded signature length
        RETURN FALSE;
    END IF;
    
    IF LENGTH(p_public_key) != 44 THEN -- Base58 encoded public key length
        RETURN FALSE;
    END IF;
    
    -- Placeholder verification (always returns true for demo)
    -- In production: implement actual signature verification
    v_is_valid := TRUE;
    
    RETURN v_is_valid;
EXCEPTION
    WHEN OTHERS THEN
        RETURN FALSE;
END;
$$;



--
-- Name: FUNCTION verify_signature(p_message text, p_signature text, p_public_key text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.verify_signature(p_message text, p_signature text, p_public_key text) IS 'Verifies Solana wallet signature';


SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: audit_log; Type: TABLE; Schema: audit; Owner: postgres
--

CREATE TABLE audit.audit_log (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    table_name text NOT NULL,
    operation text NOT NULL,
    user_id uuid,
    changed_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    old_data jsonb,
    new_data jsonb,
    query text,
    ip_address inet
);



--
-- Name: aml_checks; Type: TABLE; Schema: compliance; Owner: postgres
--

CREATE TABLE compliance.aml_checks (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    customer_profile_id uuid NOT NULL,
    transaction_id uuid,
    event_id uuid,
    check_type character varying(20) NOT NULL,
    check_status character varying(20) DEFAULT 'pending'::character varying NOT NULL,
    amount numeric(12,2),
    currency character varying(3) DEFAULT 'USD'::character varying,
    payment_method character varying(50),
    transaction_count integer DEFAULT 1,
    risk_score integer DEFAULT 0,
    risk_level character varying(10) DEFAULT 'low'::character varying,
    triggered_rules text[] DEFAULT '{}'::text[],
    rule_scores jsonb DEFAULT '{}'::jsonb,
    pattern_detected character varying(100),
    daily_limit numeric(12,2),
    monthly_limit numeric(12,2),
    exceeded_threshold boolean DEFAULT false,
    structuring_detected boolean DEFAULT false,
    rapid_movement boolean DEFAULT false,
    unusual_pattern text,
    country_risk_score integer DEFAULT 0,
    high_risk_country boolean DEFAULT false,
    ip_country character varying(2),
    velocity_score integer DEFAULT 0,
    behavior_change_score integer DEFAULT 0,
    account_age_days integer,
    related_customer_ids uuid[] DEFAULT '{}'::uuid[],
    network_risk_score integer DEFAULT 0,
    investigation_status character varying(20),
    investigator_id uuid,
    investigation_notes text,
    sar_filed boolean DEFAULT false,
    sar_reference character varying(100),
    reported_to_authorities boolean DEFAULT false,
    cleared_by uuid,
    cleared_at timestamp with time zone,
    clearance_reason text,
    account_frozen boolean DEFAULT false,
    transactions_blocked boolean DEFAULT false,
    enhanced_monitoring boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    last_reviewed_at timestamp with time zone,
    CONSTRAINT aml_checks_risk_score_check CHECK (((risk_score >= 0) AND (risk_score <= 100))),
    CONSTRAINT chk_behavior_change CHECK (((behavior_change_score >= 0) AND (behavior_change_score <= 100))),
    CONSTRAINT chk_check_status CHECK (((check_status)::text = ANY (ARRAY[('pending'::character varying)::text, ('cleared'::character varying)::text, ('flagged'::character varying)::text, ('escalated'::character varying)::text]))),
    CONSTRAINT chk_check_type CHECK (((check_type)::text = ANY (ARRAY[('transaction'::character varying)::text, ('customer'::character varying)::text, ('pattern'::character varying)::text]))),
    CONSTRAINT chk_country_risk CHECK (((country_risk_score >= 0) AND (country_risk_score <= 100))),
    CONSTRAINT chk_currency CHECK (((currency)::text ~ '^[A-Z]{3}$'::text)),
    CONSTRAINT chk_investigation_status CHECK (((investigation_status IS NULL) OR ((investigation_status)::text = ANY (ARRAY[('open'::character varying)::text, ('in_progress'::character varying)::text, ('closed'::character varying)::text])))),
    CONSTRAINT chk_network_risk CHECK (((network_risk_score >= 0) AND (network_risk_score <= 100))),
    CONSTRAINT chk_risk_level CHECK (((risk_level)::text = ANY (ARRAY[('low'::character varying)::text, ('medium'::character varying)::text, ('high'::character varying)::text, ('critical'::character varying)::text]))),
    CONSTRAINT chk_velocity_score CHECK (((velocity_score >= 0) AND (velocity_score <= 100)))
);



--
-- Name: TABLE aml_checks; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON TABLE compliance.aml_checks IS 'Anti-Money Laundering compliance checks and monitoring';


--
-- Name: COLUMN aml_checks.id; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.id IS 'Unique identifier for AML check';


--
-- Name: COLUMN aml_checks.customer_profile_id; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.customer_profile_id IS 'Customer being checked for AML compliance';


--
-- Name: COLUMN aml_checks.transaction_id; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.transaction_id IS 'Specific transaction triggering check';


--
-- Name: COLUMN aml_checks.event_id; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.event_id IS 'Event related to the check';


--
-- Name: COLUMN aml_checks.check_type; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.check_type IS 'Type of AML check performed';


--
-- Name: COLUMN aml_checks.check_status; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.check_status IS 'Current status of the check';


--
-- Name: COLUMN aml_checks.amount; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.amount IS 'Transaction amount being checked';


--
-- Name: COLUMN aml_checks.currency; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.currency IS 'Currency code (ISO 4217)';


--
-- Name: COLUMN aml_checks.payment_method; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.payment_method IS 'Payment method used';


--
-- Name: COLUMN aml_checks.transaction_count; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.transaction_count IS 'Number of transactions in this check';


--
-- Name: COLUMN aml_checks.risk_score; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.risk_score IS 'Calculated risk score (0-100)';


--
-- Name: COLUMN aml_checks.risk_level; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.risk_level IS 'Risk level categorization';


--
-- Name: COLUMN aml_checks.triggered_rules; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.triggered_rules IS 'Array of AML rules that were triggered';


--
-- Name: COLUMN aml_checks.rule_scores; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.rule_scores IS 'Individual scores for each triggered rule';


--
-- Name: COLUMN aml_checks.pattern_detected; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.pattern_detected IS 'Type of suspicious pattern detected';


--
-- Name: COLUMN aml_checks.daily_limit; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.daily_limit IS 'Daily transaction limit for comparison';


--
-- Name: COLUMN aml_checks.monthly_limit; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.monthly_limit IS 'Monthly transaction limit for comparison';


--
-- Name: COLUMN aml_checks.exceeded_threshold; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.exceeded_threshold IS 'Whether transaction limits were exceeded';


--
-- Name: COLUMN aml_checks.structuring_detected; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.structuring_detected IS 'Detected transaction structuring/smurfing';


--
-- Name: COLUMN aml_checks.rapid_movement; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.rapid_movement IS 'Detected rapid movement of funds';


--
-- Name: COLUMN aml_checks.unusual_pattern; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.unusual_pattern IS 'Description of any unusual patterns';


--
-- Name: COLUMN aml_checks.country_risk_score; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.country_risk_score IS 'Risk score based on countries involved';


--
-- Name: COLUMN aml_checks.high_risk_country; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.high_risk_country IS 'Whether high-risk country is involved';


--
-- Name: COLUMN aml_checks.ip_country; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.ip_country IS 'Country detected from IP address';


--
-- Name: COLUMN aml_checks.velocity_score; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.velocity_score IS 'Score based on transaction velocity';


--
-- Name: COLUMN aml_checks.behavior_change_score; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.behavior_change_score IS 'Score based on behavior deviation';


--
-- Name: COLUMN aml_checks.account_age_days; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.account_age_days IS 'Age of customer account in days';


--
-- Name: COLUMN aml_checks.related_customer_ids; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.related_customer_ids IS 'Other customers in transaction network';


--
-- Name: COLUMN aml_checks.network_risk_score; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.network_risk_score IS 'Risk score from network analysis';


--
-- Name: COLUMN aml_checks.investigation_status; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.investigation_status IS 'Status of manual investigation';


--
-- Name: COLUMN aml_checks.investigator_id; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.investigator_id IS 'User assigned to investigate';


--
-- Name: COLUMN aml_checks.investigation_notes; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.investigation_notes IS 'Notes from investigation';


--
-- Name: COLUMN aml_checks.sar_filed; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.sar_filed IS 'Whether SAR was filed';


--
-- Name: COLUMN aml_checks.sar_reference; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.sar_reference IS 'Reference number of filed SAR';


--
-- Name: COLUMN aml_checks.reported_to_authorities; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.reported_to_authorities IS 'Whether reported to authorities';


--
-- Name: COLUMN aml_checks.cleared_by; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.cleared_by IS 'User who cleared the check';


--
-- Name: COLUMN aml_checks.cleared_at; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.cleared_at IS 'When check was cleared';


--
-- Name: COLUMN aml_checks.clearance_reason; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.clearance_reason IS 'Reason for clearing the check';


--
-- Name: COLUMN aml_checks.account_frozen; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.account_frozen IS 'Whether account was frozen';


--
-- Name: COLUMN aml_checks.transactions_blocked; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.transactions_blocked IS 'Whether transactions were blocked';


--
-- Name: COLUMN aml_checks.enhanced_monitoring; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.enhanced_monitoring IS 'Whether enhanced monitoring was enabled';


--
-- Name: COLUMN aml_checks.last_reviewed_at; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.aml_checks.last_reviewed_at IS 'Last manual review timestamp';


--
-- Name: aml_monitoring_dashboard; Type: VIEW; Schema: compliance; Owner: postgres
--

CREATE VIEW compliance.aml_monitoring_dashboard AS
 SELECT aml_checks.check_status,
    aml_checks.risk_level,
    count(*) AS total_checks,
    count(*) FILTER (WHERE (aml_checks.created_at >= CURRENT_DATE)) AS today_checks,
    count(*) FILTER (WHERE (aml_checks.created_at >= (CURRENT_DATE - '7 days'::interval))) AS week_checks,
    count(*) FILTER (WHERE (aml_checks.sar_filed = true)) AS sars_filed,
    count(*) FILTER (WHERE (aml_checks.investigation_status IS NOT NULL)) AS under_investigation,
    avg(aml_checks.risk_score) AS avg_risk_score,
    max(aml_checks.risk_score) AS max_risk_score
   FROM compliance.aml_checks
  WHERE (aml_checks.created_at >= (CURRENT_DATE - '30 days'::interval))
  GROUP BY aml_checks.check_status, aml_checks.risk_level
  ORDER BY
        CASE aml_checks.risk_level
            WHEN 'critical'::text THEN 1
            WHEN 'high'::text THEN 2
            WHEN 'medium'::text THEN 3
            WHEN 'low'::text THEN 4
            ELSE NULL::integer
        END, aml_checks.check_status;



--
-- Name: VIEW aml_monitoring_dashboard; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON VIEW compliance.aml_monitoring_dashboard IS 'AML monitoring dashboard summary view';


--
-- Name: compliance_reports; Type: TABLE; Schema: compliance; Owner: postgres
--

CREATE TABLE compliance.compliance_reports (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    report_type character varying(20) NOT NULL,
    report_name character varying(255) NOT NULL,
    report_number character varying(100) NOT NULL,
    regulator character varying(255) NOT NULL,
    jurisdiction character varying(100) NOT NULL,
    regulation_reference character varying(255),
    period_start date NOT NULL,
    period_end date NOT NULL,
    reporting_frequency character varying(20),
    status character varying(20) DEFAULT 'draft'::character varying NOT NULL,
    due_date date NOT NULL,
    submitted_at timestamp with time zone,
    submission_method character varying(50),
    confirmation_number character varying(255),
    report_data jsonb DEFAULT '{}'::jsonb NOT NULL,
    summary text,
    total_transactions integer DEFAULT 0,
    flagged_transactions integer DEFAULT 0,
    total_amount numeric(15,2) DEFAULT 0,
    currency character varying(3) DEFAULT 'USD'::character varying,
    suspicious_amount numeric(15,2) DEFAULT 0,
    customer_count integer DEFAULT 0,
    customer_ids uuid[] DEFAULT '{}'::uuid[],
    high_risk_customers integer DEFAULT 0,
    findings_count integer DEFAULT 0,
    critical_findings integer DEFAULT 0,
    findings_details jsonb DEFAULT '[]'::jsonb,
    attachment_urls text[] DEFAULT '{}'::text[],
    supporting_documents jsonb DEFAULT '{}'::jsonb,
    evidence_links text[] DEFAULT '{}'::text[],
    prepared_by uuid,
    reviewed_by uuid,
    approved_by uuid,
    approval_notes text,
    is_amendment boolean DEFAULT false,
    original_report_id uuid,
    amendment_reason text,
    retention_years integer DEFAULT 7,
    destruction_date date,
    archived boolean DEFAULT false,
    modifications jsonb DEFAULT '[]'::jsonb,
    access_log jsonb DEFAULT '[]'::jsonb,
    tags text[] DEFAULT '{}'::text[],
    internal_reference character varying(255),
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    locked_at timestamp with time zone,
    CONSTRAINT chk_amendment CHECK ((((is_amendment = false) AND (original_report_id IS NULL)) OR ((is_amendment = true) AND (original_report_id IS NOT NULL) AND (amendment_reason IS NOT NULL)))),
    CONSTRAINT chk_amounts CHECK (((total_amount >= (0)::numeric) AND (suspicious_amount >= (0)::numeric))),
    CONSTRAINT chk_counts CHECK (((customer_count >= 0) AND (total_transactions >= 0) AND (flagged_transactions >= 0) AND (findings_count >= 0) AND (critical_findings >= 0) AND (high_risk_customers >= 0))),
    CONSTRAINT chk_currency CHECK (((currency)::text ~ '^[A-Z]{3}$'::text)),
    CONSTRAINT chk_period_dates CHECK ((period_end >= period_start)),
    CONSTRAINT chk_report_type CHECK (((report_type)::text = ANY (ARRAY[('sar'::character varying)::text, ('ctr'::character varying)::text, ('periodic'::character varying)::text, ('audit'::character varying)::text]))),
    CONSTRAINT chk_reporting_frequency CHECK (((reporting_frequency IS NULL) OR ((reporting_frequency)::text = ANY (ARRAY[('daily'::character varying)::text, ('weekly'::character varying)::text, ('monthly'::character varying)::text, ('quarterly'::character varying)::text, ('annual'::character varying)::text])))),
    CONSTRAINT chk_status CHECK (((status)::text = ANY (ARRAY[('draft'::character varying)::text, ('pending_review'::character varying)::text, ('approved'::character varying)::text, ('submitted'::character varying)::text, ('acknowledged'::character varying)::text, ('rejected'::character varying)::text]))),
    CONSTRAINT chk_submission_method CHECK (((submission_method IS NULL) OR ((submission_method)::text = ANY (ARRAY[('e-filing'::character varying)::text, ('mail'::character varying)::text, ('portal'::character varying)::text, ('api'::character varying)::text]))))
);



--
-- Name: TABLE compliance_reports; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON TABLE compliance.compliance_reports IS 'Regulatory compliance reports and submissions';


--
-- Name: COLUMN compliance_reports.id; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.id IS 'Unique identifier for compliance report';


--
-- Name: COLUMN compliance_reports.report_type; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.report_type IS 'Type of report: sar, ctr, periodic, audit';


--
-- Name: COLUMN compliance_reports.report_name; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.report_name IS 'Human-readable name for the report';


--
-- Name: COLUMN compliance_reports.report_number; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.report_number IS 'Unique report number/identifier';


--
-- Name: COLUMN compliance_reports.regulator; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.regulator IS 'Regulatory body receiving the report';


--
-- Name: COLUMN compliance_reports.jurisdiction; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.jurisdiction IS 'Legal jurisdiction for the report';


--
-- Name: COLUMN compliance_reports.regulation_reference; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.regulation_reference IS 'Specific regulation or requirement';


--
-- Name: COLUMN compliance_reports.period_start; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.period_start IS 'Start date of reporting period';


--
-- Name: COLUMN compliance_reports.period_end; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.period_end IS 'End date of reporting period';


--
-- Name: COLUMN compliance_reports.reporting_frequency; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.reporting_frequency IS 'How often report is required';


--
-- Name: COLUMN compliance_reports.status; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.status IS 'Current status of the report';


--
-- Name: COLUMN compliance_reports.due_date; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.due_date IS 'Regulatory deadline for submission';


--
-- Name: COLUMN compliance_reports.submitted_at; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.submitted_at IS 'When report was submitted';


--
-- Name: COLUMN compliance_reports.submission_method; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.submission_method IS 'How report was submitted';


--
-- Name: COLUMN compliance_reports.confirmation_number; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.confirmation_number IS 'Confirmation from regulator';


--
-- Name: COLUMN compliance_reports.report_data; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.report_data IS 'Structured report data in JSON format';


--
-- Name: COLUMN compliance_reports.summary; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.summary IS 'Executive summary of report';


--
-- Name: COLUMN compliance_reports.total_transactions; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.total_transactions IS 'Total transaction count in period';


--
-- Name: COLUMN compliance_reports.flagged_transactions; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.flagged_transactions IS 'Number of flagged transactions';


--
-- Name: COLUMN compliance_reports.total_amount; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.total_amount IS 'Total monetary amount in report';


--
-- Name: COLUMN compliance_reports.currency; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.currency IS 'Currency code for amounts';


--
-- Name: COLUMN compliance_reports.suspicious_amount; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.suspicious_amount IS 'Total suspicious amount';


--
-- Name: COLUMN compliance_reports.customer_count; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.customer_count IS 'Number of customers covered';


--
-- Name: COLUMN compliance_reports.customer_ids; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.customer_ids IS 'Array of customer IDs in report';


--
-- Name: COLUMN compliance_reports.high_risk_customers; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.high_risk_customers IS 'Count of high-risk customers';


--
-- Name: COLUMN compliance_reports.findings_count; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.findings_count IS 'Total number of findings';


--
-- Name: COLUMN compliance_reports.critical_findings; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.critical_findings IS 'Number of critical findings';


--
-- Name: COLUMN compliance_reports.findings_details; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.findings_details IS 'Detailed findings information';


--
-- Name: COLUMN compliance_reports.attachment_urls; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.attachment_urls IS 'URLs to report attachments';


--
-- Name: COLUMN compliance_reports.supporting_documents; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.supporting_documents IS 'Supporting documentation';


--
-- Name: COLUMN compliance_reports.evidence_links; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.evidence_links IS 'Links to supporting evidence';


--
-- Name: COLUMN compliance_reports.prepared_by; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.prepared_by IS 'User who prepared the report';


--
-- Name: COLUMN compliance_reports.reviewed_by; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.reviewed_by IS 'User who reviewed the report';


--
-- Name: COLUMN compliance_reports.approved_by; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.approved_by IS 'User who approved the report';


--
-- Name: COLUMN compliance_reports.approval_notes; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.approval_notes IS 'Notes from approval process';


--
-- Name: COLUMN compliance_reports.is_amendment; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.is_amendment IS 'Whether this amends a previous report';


--
-- Name: COLUMN compliance_reports.original_report_id; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.original_report_id IS 'ID of report being amended';


--
-- Name: COLUMN compliance_reports.amendment_reason; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.amendment_reason IS 'Reason for amendment';


--
-- Name: COLUMN compliance_reports.retention_years; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.retention_years IS 'Years to retain report';


--
-- Name: COLUMN compliance_reports.destruction_date; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.destruction_date IS 'When to destroy report';


--
-- Name: COLUMN compliance_reports.archived; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.archived IS 'Whether report is archived';


--
-- Name: COLUMN compliance_reports.modifications; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.modifications IS 'Audit trail of modifications';


--
-- Name: COLUMN compliance_reports.access_log; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.access_log IS 'Log of who accessed report';


--
-- Name: COLUMN compliance_reports.tags; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.tags IS 'Tags for categorization';


--
-- Name: COLUMN compliance_reports.internal_reference; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.internal_reference IS 'Internal tracking reference';


--
-- Name: COLUMN compliance_reports.locked_at; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.compliance_reports.locked_at IS 'When report was locked from editing';


--
-- Name: compliance_report_dashboard; Type: VIEW; Schema: compliance; Owner: postgres
--

CREATE VIEW compliance.compliance_report_dashboard AS
 SELECT compliance_reports.report_type,
    compliance_reports.status,
    count(*) AS total_reports,
    count(*) FILTER (WHERE ((compliance_reports.due_date <= (CURRENT_DATE + '7 days'::interval)) AND ((compliance_reports.status)::text <> ALL (ARRAY[('submitted'::character varying)::text, ('acknowledged'::character varying)::text])))) AS due_soon,
    count(*) FILTER (WHERE ((compliance_reports.due_date < CURRENT_DATE) AND ((compliance_reports.status)::text <> ALL (ARRAY[('submitted'::character varying)::text, ('acknowledged'::character varying)::text])))) AS overdue,
    count(*) FILTER (WHERE (compliance_reports.created_at >= (CURRENT_DATE - '30 days'::interval))) AS recent_reports,
    count(*) FILTER (WHERE (compliance_reports.is_amendment = true)) AS amendments,
    sum(compliance_reports.findings_count) AS total_findings,
    sum(compliance_reports.critical_findings) AS total_critical_findings
   FROM compliance.compliance_reports
  WHERE (compliance_reports.created_at >= (CURRENT_DATE - '90 days'::interval))
  GROUP BY compliance_reports.report_type, compliance_reports.status
  ORDER BY compliance_reports.report_type,
        CASE compliance_reports.status
            WHEN 'draft'::text THEN 1
            WHEN 'pending_review'::text THEN 2
            WHEN 'approved'::text THEN 3
            WHEN 'submitted'::text THEN 4
            WHEN 'acknowledged'::text THEN 5
            WHEN 'rejected'::text THEN 6
            ELSE NULL::integer
        END;



--
-- Name: VIEW compliance_report_dashboard; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON VIEW compliance.compliance_report_dashboard IS 'Dashboard view for compliance reporting status';


--
-- Name: kyc_records; Type: TABLE; Schema: compliance; Owner: postgres
--

CREATE TABLE compliance.kyc_records (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    customer_profile_id uuid NOT NULL,
    verification_level character varying(20) DEFAULT 'basic'::character varying NOT NULL,
    verification_status character varying(20) DEFAULT 'pending'::character varying NOT NULL,
    document_type character varying(30),
    document_number_hash character varying(255),
    document_front_url character varying(500),
    document_back_url character varying(500),
    selfie_url character varying(500),
    storage_encrypted boolean DEFAULT true,
    submitted_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    verified_at timestamp with time zone,
    expires_at timestamp with time zone,
    kyc_provider character varying(100),
    provider_reference_id character varying(255),
    provider_score numeric(5,4),
    first_name_verified character varying(100),
    last_name_verified character varying(100),
    date_of_birth_verified date,
    address_verified text,
    address_proof_type character varying(50),
    address_match_score numeric(5,4),
    face_match_score numeric(5,4),
    liveness_check_passed boolean,
    biometric_data_hash character varying(255),
    risk_score integer,
    risk_factors jsonb DEFAULT '[]'::jsonb,
    pep_check boolean DEFAULT false,
    sanctions_check boolean DEFAULT false,
    rejection_reason character varying(100),
    rejection_details text,
    can_resubmit boolean DEFAULT true,
    requires_manual_review boolean DEFAULT false,
    reviewed_by uuid,
    review_notes text,
    aml_cleared boolean DEFAULT false,
    cft_cleared boolean DEFAULT false,
    regulatory_flags jsonb DEFAULT '{}'::jsonb,
    retention_period_days integer DEFAULT 2555,
    deletion_scheduled_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    verified_by uuid,
    CONSTRAINT chk_address_match_score CHECK (((address_match_score IS NULL) OR ((address_match_score >= (0)::numeric) AND (address_match_score <= (1)::numeric)))),
    CONSTRAINT chk_document_type CHECK (((document_type IS NULL) OR ((document_type)::text = ANY (ARRAY[('passport'::character varying)::text, ('drivers_license'::character varying)::text, ('national_id'::character varying)::text, ('other'::character varying)::text])))),
    CONSTRAINT chk_face_match_score CHECK (((face_match_score IS NULL) OR ((face_match_score >= (0)::numeric) AND (face_match_score <= (1)::numeric)))),
    CONSTRAINT chk_provider_score CHECK (((provider_score IS NULL) OR ((provider_score >= (0)::numeric) AND (provider_score <= (1)::numeric)))),
    CONSTRAINT chk_retention_period CHECK ((retention_period_days > 0)),
    CONSTRAINT chk_verification_level CHECK (((verification_level)::text = ANY (ARRAY[('basic'::character varying)::text, ('enhanced'::character varying)::text, ('full'::character varying)::text]))),
    CONSTRAINT chk_verification_status CHECK (((verification_status)::text = ANY (ARRAY[('pending'::character varying)::text, ('approved'::character varying)::text, ('rejected'::character varying)::text, ('expired'::character varying)::text]))),
    CONSTRAINT kyc_records_risk_score_check CHECK (((risk_score >= 0) AND (risk_score <= 100)))
);



--
-- Name: TABLE kyc_records; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON TABLE compliance.kyc_records IS 'Know Your Customer verification records for regulatory compliance';


--
-- Name: COLUMN kyc_records.id; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.id IS 'Unique identifier for KYC record';


--
-- Name: COLUMN kyc_records.customer_profile_id; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.customer_profile_id IS 'Reference to customer being verified';


--
-- Name: COLUMN kyc_records.verification_level; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.verification_level IS 'Level of verification: basic, enhanced, or full';


--
-- Name: COLUMN kyc_records.verification_status; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.verification_status IS 'Current status: pending, approved, rejected, or expired';


--
-- Name: COLUMN kyc_records.document_type; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.document_type IS 'Type of identity document provided';


--
-- Name: COLUMN kyc_records.document_number_hash; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.document_number_hash IS 'Hashed document number for security';


--
-- Name: COLUMN kyc_records.document_front_url; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.document_front_url IS 'Secure storage URL for document front image';


--
-- Name: COLUMN kyc_records.document_back_url; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.document_back_url IS 'Secure storage URL for document back image';


--
-- Name: COLUMN kyc_records.selfie_url; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.selfie_url IS 'Secure storage URL for customer selfie';


--
-- Name: COLUMN kyc_records.storage_encrypted; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.storage_encrypted IS 'Whether document storage is encrypted';


--
-- Name: COLUMN kyc_records.submitted_at; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.submitted_at IS 'When KYC documents were submitted';


--
-- Name: COLUMN kyc_records.verified_at; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.verified_at IS 'When verification was completed';


--
-- Name: COLUMN kyc_records.expires_at; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.expires_at IS 'When this verification expires';


--
-- Name: COLUMN kyc_records.kyc_provider; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.kyc_provider IS 'Third-party KYC provider used';


--
-- Name: COLUMN kyc_records.provider_reference_id; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.provider_reference_id IS 'Reference ID from KYC provider';


--
-- Name: COLUMN kyc_records.provider_score; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.provider_score IS 'Confidence score from provider (0-1)';


--
-- Name: COLUMN kyc_records.first_name_verified; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.first_name_verified IS 'First name as verified from documents';


--
-- Name: COLUMN kyc_records.last_name_verified; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.last_name_verified IS 'Last name as verified from documents';


--
-- Name: COLUMN kyc_records.date_of_birth_verified; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.date_of_birth_verified IS 'Date of birth as verified from documents';


--
-- Name: COLUMN kyc_records.address_verified; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.address_verified IS 'Address as verified from proof documents';


--
-- Name: COLUMN kyc_records.address_proof_type; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.address_proof_type IS 'Type of address proof provided';


--
-- Name: COLUMN kyc_records.address_match_score; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.address_match_score IS 'Confidence score for address match (0-1)';


--
-- Name: COLUMN kyc_records.face_match_score; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.face_match_score IS 'Biometric face match confidence (0-1)';


--
-- Name: COLUMN kyc_records.liveness_check_passed; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.liveness_check_passed IS 'Whether liveness detection passed';


--
-- Name: COLUMN kyc_records.biometric_data_hash; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.biometric_data_hash IS 'Hash of biometric data for integrity';


--
-- Name: COLUMN kyc_records.risk_score; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.risk_score IS 'Overall risk score (0-100, lower is better)';


--
-- Name: COLUMN kyc_records.risk_factors; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.risk_factors IS 'Array of identified risk factors';


--
-- Name: COLUMN kyc_records.pep_check; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.pep_check IS 'Whether PEP (Politically Exposed Person) check was performed';


--
-- Name: COLUMN kyc_records.sanctions_check; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.sanctions_check IS 'Whether sanctions list check was performed';


--
-- Name: COLUMN kyc_records.rejection_reason; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.rejection_reason IS 'Primary reason for rejection';


--
-- Name: COLUMN kyc_records.rejection_details; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.rejection_details IS 'Detailed explanation of rejection';


--
-- Name: COLUMN kyc_records.can_resubmit; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.can_resubmit IS 'Whether customer can submit new KYC';


--
-- Name: COLUMN kyc_records.requires_manual_review; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.requires_manual_review IS 'Flagged for human review';


--
-- Name: COLUMN kyc_records.reviewed_by; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.reviewed_by IS 'User who performed manual review';


--
-- Name: COLUMN kyc_records.review_notes; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.review_notes IS 'Notes from manual review';


--
-- Name: COLUMN kyc_records.aml_cleared; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.aml_cleared IS 'Anti-Money Laundering compliance cleared';


--
-- Name: COLUMN kyc_records.cft_cleared; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.cft_cleared IS 'Counter-Financing of Terrorism cleared';


--
-- Name: COLUMN kyc_records.regulatory_flags; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.regulatory_flags IS 'Additional regulatory compliance flags';


--
-- Name: COLUMN kyc_records.retention_period_days; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.retention_period_days IS 'How long to retain KYC data';


--
-- Name: COLUMN kyc_records.deletion_scheduled_at; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.deletion_scheduled_at IS 'When to delete this record';


--
-- Name: COLUMN kyc_records.verified_by; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.kyc_records.verified_by IS 'User or system that performed verification';


--
-- Name: current_kyc_status; Type: VIEW; Schema: compliance; Owner: postgres
--

CREATE VIEW compliance.current_kyc_status AS
 SELECT DISTINCT ON (kyc_records.customer_profile_id) kyc_records.customer_profile_id,
    kyc_records.id AS kyc_record_id,
    kyc_records.verification_level,
    kyc_records.verification_status,
    kyc_records.verified_at,
    kyc_records.expires_at,
    kyc_records.risk_score,
        CASE
            WHEN (((kyc_records.verification_status)::text = 'approved'::text) AND ((kyc_records.expires_at IS NULL) OR (kyc_records.expires_at > CURRENT_TIMESTAMP))) THEN 'valid'::text
            WHEN (((kyc_records.verification_status)::text = 'approved'::text) AND (kyc_records.expires_at <= CURRENT_TIMESTAMP)) THEN 'expired'::text
            WHEN ((kyc_records.verification_status)::text = 'pending'::text) THEN 'pending'::text
            WHEN ((kyc_records.verification_status)::text = 'rejected'::text) THEN 'rejected'::text
            ELSE 'none'::text
        END AS kyc_status
   FROM compliance.kyc_records
  ORDER BY kyc_records.customer_profile_id, kyc_records.created_at DESC;



--
-- Name: VIEW current_kyc_status; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON VIEW compliance.current_kyc_status IS 'Current KYC status for each customer';


--
-- Name: data_retention; Type: TABLE; Schema: compliance; Owner: postgres
--

CREATE TABLE compliance.data_retention (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    policy_name character varying(255) NOT NULL,
    policy_type character varying(20) NOT NULL,
    is_active boolean DEFAULT true,
    data_category character varying(100) NOT NULL,
    data_type character varying(100) NOT NULL,
    sensitivity_level character varying(20) NOT NULL,
    retention_period_days integer,
    retention_period_years integer,
    retention_basis character varying(20) DEFAULT 'creation_date'::character varying,
    regulatory_requirement character varying(255),
    jurisdiction character varying(100),
    legal_citation text,
    table_names text[] DEFAULT '{}'::text[],
    column_names text[] DEFAULT '{}'::text[],
    entity_types text[] DEFAULT '{}'::text[],
    deletion_method character varying(20) DEFAULT 'soft_delete'::character varying,
    deletion_schedule character varying(50),
    exception_criteria jsonb DEFAULT '{}'::jsonb,
    legal_hold boolean DEFAULT false,
    litigation_hold_ids uuid[] DEFAULT '{}'::uuid[],
    archive_after_days integer,
    archive_location character varying(255),
    archive_format character varying(50),
    anonymization_rules jsonb DEFAULT '{}'::jsonb,
    fields_to_preserve text[] DEFAULT '{}'::text[],
    anonymization_method character varying(50),
    last_purge_date timestamp with time zone,
    next_purge_date timestamp with time zone,
    records_purged_count bigint DEFAULT 0,
    audit_before_deletion boolean DEFAULT true,
    approval_required boolean DEFAULT false,
    approvers uuid[] DEFAULT '{}'::uuid[],
    is_restorable boolean DEFAULT false,
    restoration_period_days integer,
    restoration_process text,
    compliance_check_frequency character varying(20),
    last_compliance_check timestamp with time zone,
    compliance_status character varying(20),
    notify_before_deletion boolean DEFAULT true,
    notification_days integer DEFAULT 30,
    notification_recipients text[] DEFAULT '{}'::text[],
    business_justification text,
    data_owner uuid,
    review_frequency character varying(20) DEFAULT 'annual'::character varying,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    created_by uuid,
    last_reviewed_by uuid,
    CONSTRAINT chk_compliance_status CHECK (((compliance_status IS NULL) OR ((compliance_status)::text = ANY (ARRAY[('compliant'::character varying)::text, ('non_compliant'::character varying)::text, ('pending'::character varying)::text])))),
    CONSTRAINT chk_deletion_method CHECK (((deletion_method)::text = ANY (ARRAY[('soft_delete'::character varying)::text, ('hard_delete'::character varying)::text, ('anonymize'::character varying)::text, ('archive'::character varying)::text]))),
    CONSTRAINT chk_policy_type CHECK (((policy_type)::text = ANY (ARRAY[('regulatory'::character varying)::text, ('business'::character varying)::text, ('technical'::character varying)::text]))),
    CONSTRAINT chk_restoration CHECK (((is_restorable = false) OR ((is_restorable = true) AND (restoration_period_days IS NOT NULL) AND (restoration_period_days > 0)))),
    CONSTRAINT chk_retention_basis CHECK (((retention_basis)::text = ANY (ARRAY[('creation_date'::character varying)::text, ('last_modified'::character varying)::text, ('last_accessed'::character varying)::text]))),
    CONSTRAINT chk_retention_period CHECK ((((retention_period_days IS NOT NULL) AND (retention_period_days > 0)) OR ((retention_period_years IS NOT NULL) AND (retention_period_years > 0)))),
    CONSTRAINT chk_review_frequency CHECK (((review_frequency)::text = ANY (ARRAY[('monthly'::character varying)::text, ('quarterly'::character varying)::text, ('semi_annual'::character varying)::text, ('annual'::character varying)::text]))),
    CONSTRAINT chk_sensitivity_level CHECK (((sensitivity_level)::text = ANY (ARRAY[('public'::character varying)::text, ('internal'::character varying)::text, ('confidential'::character varying)::text, ('restricted'::character varying)::text])))
);



--
-- Name: TABLE data_retention; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON TABLE compliance.data_retention IS 'Data retention policies for compliance and lifecycle management';


--
-- Name: COLUMN data_retention.id; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.id IS 'Unique identifier for retention policy';


--
-- Name: COLUMN data_retention.policy_name; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.policy_name IS 'Unique name for the policy';


--
-- Name: COLUMN data_retention.policy_type; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.policy_type IS 'Type: regulatory, business, or technical';


--
-- Name: COLUMN data_retention.is_active; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.is_active IS 'Whether policy is currently active';


--
-- Name: COLUMN data_retention.data_category; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.data_category IS 'Category of data covered';


--
-- Name: COLUMN data_retention.data_type; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.data_type IS 'Specific type of data';


--
-- Name: COLUMN data_retention.sensitivity_level; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.sensitivity_level IS 'Data sensitivity classification';


--
-- Name: COLUMN data_retention.retention_period_days; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.retention_period_days IS 'Retention period in days';


--
-- Name: COLUMN data_retention.retention_period_years; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.retention_period_years IS 'Retention period in years';


--
-- Name: COLUMN data_retention.retention_basis; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.retention_basis IS 'Date basis for retention calculation';


--
-- Name: COLUMN data_retention.regulatory_requirement; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.regulatory_requirement IS 'Regulation requiring this retention';


--
-- Name: COLUMN data_retention.jurisdiction; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.jurisdiction IS 'Legal jurisdiction for requirement';


--
-- Name: COLUMN data_retention.legal_citation; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.legal_citation IS 'Legal reference or citation';


--
-- Name: COLUMN data_retention.table_names; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.table_names IS 'Database tables covered by policy';


--
-- Name: COLUMN data_retention.column_names; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.column_names IS 'Specific columns covered';


--
-- Name: COLUMN data_retention.entity_types; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.entity_types IS 'Business entities covered';


--
-- Name: COLUMN data_retention.deletion_method; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.deletion_method IS 'How data is deleted';


--
-- Name: COLUMN data_retention.deletion_schedule; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.deletion_schedule IS 'Schedule for deletion runs';


--
-- Name: COLUMN data_retention.exception_criteria; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.exception_criteria IS 'Criteria for retention exceptions';


--
-- Name: COLUMN data_retention.legal_hold; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.legal_hold IS 'Whether under legal hold';


--
-- Name: COLUMN data_retention.litigation_hold_ids; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.litigation_hold_ids IS 'Related litigation hold IDs';


--
-- Name: COLUMN data_retention.archive_after_days; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.archive_after_days IS 'Days before archiving';


--
-- Name: COLUMN data_retention.archive_location; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.archive_location IS 'Where archives are stored';


--
-- Name: COLUMN data_retention.archive_format; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.archive_format IS 'Format for archived data';


--
-- Name: COLUMN data_retention.anonymization_rules; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.anonymization_rules IS 'Rules for anonymizing data';


--
-- Name: COLUMN data_retention.fields_to_preserve; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.fields_to_preserve IS 'Fields to keep when anonymizing';


--
-- Name: COLUMN data_retention.anonymization_method; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.anonymization_method IS 'Method used for anonymization';


--
-- Name: COLUMN data_retention.last_purge_date; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.last_purge_date IS 'When last purge was executed';


--
-- Name: COLUMN data_retention.next_purge_date; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.next_purge_date IS 'When next purge is scheduled';


--
-- Name: COLUMN data_retention.records_purged_count; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.records_purged_count IS 'Total records purged to date';


--
-- Name: COLUMN data_retention.audit_before_deletion; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.audit_before_deletion IS 'Whether to audit before deletion';


--
-- Name: COLUMN data_retention.approval_required; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.approval_required IS 'Whether deletion requires approval';


--
-- Name: COLUMN data_retention.approvers; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.approvers IS 'Users who can approve deletions';


--
-- Name: COLUMN data_retention.is_restorable; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.is_restorable IS 'Whether deleted data can be restored';


--
-- Name: COLUMN data_retention.restoration_period_days; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.restoration_period_days IS 'How long data can be restored';


--
-- Name: COLUMN data_retention.restoration_process; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.restoration_process IS 'Process for restoring data';


--
-- Name: COLUMN data_retention.compliance_check_frequency; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.compliance_check_frequency IS 'How often to check compliance';


--
-- Name: COLUMN data_retention.last_compliance_check; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.last_compliance_check IS 'Last compliance check date';


--
-- Name: COLUMN data_retention.compliance_status; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.compliance_status IS 'Current compliance status';


--
-- Name: COLUMN data_retention.notify_before_deletion; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.notify_before_deletion IS 'Whether to send notifications';


--
-- Name: COLUMN data_retention.notification_days; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.notification_days IS 'Days before deletion to notify';


--
-- Name: COLUMN data_retention.notification_recipients; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.notification_recipients IS 'Who receives notifications';


--
-- Name: COLUMN data_retention.business_justification; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.business_justification IS 'Business reason for policy';


--
-- Name: COLUMN data_retention.data_owner; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.data_owner IS 'User responsible for data';


--
-- Name: COLUMN data_retention.review_frequency; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.data_retention.review_frequency IS 'How often to review policy';


--
-- Name: data_retention_dashboard; Type: VIEW; Schema: compliance; Owner: postgres
--

CREATE VIEW compliance.data_retention_dashboard AS
 SELECT data_retention.policy_type,
    data_retention.sensitivity_level,
    count(*) AS total_policies,
    count(*) FILTER (WHERE data_retention.is_active) AS active_policies,
    count(*) FILTER (WHERE data_retention.legal_hold) AS legal_holds,
    count(*) FILTER (WHERE (data_retention.next_purge_date <= (CURRENT_DATE + '30 days'::interval))) AS purge_upcoming,
    count(*) FILTER (WHERE ((data_retention.compliance_status)::text = 'non_compliant'::text)) AS non_compliant,
    sum(data_retention.records_purged_count) AS total_records_purged
   FROM compliance.data_retention
  GROUP BY data_retention.policy_type, data_retention.sensitivity_level
  ORDER BY data_retention.policy_type,
        CASE data_retention.sensitivity_level
            WHEN 'restricted'::text THEN 1
            WHEN 'confidential'::text THEN 2
            WHEN 'internal'::text THEN 3
            WHEN 'public'::text THEN 4
            ELSE NULL::integer
        END;



--
-- Name: VIEW data_retention_dashboard; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON VIEW compliance.data_retention_dashboard IS 'Dashboard view for data retention policies';


--
-- Name: sanctions_screening; Type: TABLE; Schema: compliance; Owner: postgres
--

CREATE TABLE compliance.sanctions_screening (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    customer_profile_id uuid NOT NULL,
    screening_type character varying(20) NOT NULL,
    screening_status character varying(20) DEFAULT 'pending'::character varying NOT NULL,
    sanctions_lists text[] DEFAULT '{}'::text[],
    lists_version character varying(50),
    last_list_update timestamp with time zone,
    match_score numeric(5,2) DEFAULT 0,
    match_type character varying(20),
    matched_fields text[] DEFAULT '{}'::text[],
    matched_entity_name character varying(500),
    matched_entity_type character varying(50),
    matched_entity_id character varying(255),
    sanction_type character varying(100),
    issuing_authority character varying(255),
    sanction_date date,
    expiry_date date,
    sanctioned_countries text[] DEFAULT '{}'::text[],
    nationality_match boolean DEFAULT false,
    residence_match boolean DEFAULT false,
    matched_aliases text[] DEFAULT '{}'::text[],
    matched_documents jsonb DEFAULT '{}'::jsonb,
    date_of_birth_match boolean DEFAULT false,
    risk_rating character varying(20),
    requires_enhanced_due_diligence boolean DEFAULT false,
    is_false_positive boolean DEFAULT false,
    false_positive_reason text,
    confirmed_by uuid,
    review_required boolean DEFAULT true,
    reviewed_by uuid,
    review_date timestamp with time zone,
    review_decision character varying(50),
    supporting_documents jsonb DEFAULT '{}'::jsonb,
    case_number character varying(100),
    notes text,
    monitoring_frequency character varying(20) DEFAULT 'monthly'::character varying,
    next_check_date date,
    auto_clear_date date,
    reported_to_compliance boolean DEFAULT false,
    regulatory_filing_id character varying(255),
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    last_checked_at timestamp with time zone,
    CONSTRAINT chk_match_score_status CHECK (((((screening_status)::text = 'clear'::text) AND (match_score < (50)::numeric)) OR (((screening_status)::text = ANY (ARRAY[('potential_match'::character varying)::text, ('confirmed_match'::character varying)::text])) AND (match_score >= (50)::numeric)) OR ((screening_status)::text = 'pending'::text))),
    CONSTRAINT chk_match_type CHECK (((match_type IS NULL) OR ((match_type)::text = ANY (ARRAY[('exact'::character varying)::text, ('fuzzy'::character varying)::text, ('phonetic'::character varying)::text])))),
    CONSTRAINT chk_monitoring_frequency CHECK (((monitoring_frequency)::text = ANY (ARRAY[('daily'::character varying)::text, ('weekly'::character varying)::text, ('monthly'::character varying)::text, ('quarterly'::character varying)::text]))),
    CONSTRAINT chk_review_decision CHECK (((review_decision IS NULL) OR ((review_decision)::text = ANY (ARRAY[('approve'::character varying)::text, ('reject'::character varying)::text, ('escalate'::character varying)::text])))),
    CONSTRAINT chk_risk_rating CHECK (((risk_rating IS NULL) OR ((risk_rating)::text = ANY (ARRAY[('low'::character varying)::text, ('medium'::character varying)::text, ('high'::character varying)::text, ('critical'::character varying)::text])))),
    CONSTRAINT chk_screening_status CHECK (((screening_status)::text = ANY (ARRAY[('pending'::character varying)::text, ('clear'::character varying)::text, ('potential_match'::character varying)::text, ('confirmed_match'::character varying)::text]))),
    CONSTRAINT chk_screening_type CHECK (((screening_type)::text = ANY (ARRAY[('onboarding'::character varying)::text, ('periodic'::character varying)::text, ('triggered'::character varying)::text]))),
    CONSTRAINT sanctions_screening_match_score_check CHECK (((match_score >= (0)::numeric) AND (match_score <= (100)::numeric)))
);



--
-- Name: TABLE sanctions_screening; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON TABLE compliance.sanctions_screening IS 'Sanctions list screening records for compliance';


--
-- Name: COLUMN sanctions_screening.id; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.id IS 'Unique identifier for screening record';


--
-- Name: COLUMN sanctions_screening.customer_profile_id; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.customer_profile_id IS 'Customer being screened';


--
-- Name: COLUMN sanctions_screening.screening_type; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.screening_type IS 'Type of screening: onboarding, periodic, or triggered';


--
-- Name: COLUMN sanctions_screening.screening_status; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.screening_status IS 'Current status of screening';


--
-- Name: COLUMN sanctions_screening.sanctions_lists; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.sanctions_lists IS 'Array of sanctions lists checked';


--
-- Name: COLUMN sanctions_screening.lists_version; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.lists_version IS 'Version identifier of sanctions lists';


--
-- Name: COLUMN sanctions_screening.last_list_update; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.last_list_update IS 'When sanctions lists were last updated';


--
-- Name: COLUMN sanctions_screening.match_score; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.match_score IS 'Confidence score of match (0-100)';


--
-- Name: COLUMN sanctions_screening.match_type; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.match_type IS 'Type of matching used';


--
-- Name: COLUMN sanctions_screening.matched_fields; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.matched_fields IS 'Fields that matched';


--
-- Name: COLUMN sanctions_screening.matched_entity_name; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.matched_entity_name IS 'Name of matched sanctioned entity';


--
-- Name: COLUMN sanctions_screening.matched_entity_type; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.matched_entity_type IS 'Type of sanctioned entity';


--
-- Name: COLUMN sanctions_screening.matched_entity_id; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.matched_entity_id IS 'ID of entity in sanctions database';


--
-- Name: COLUMN sanctions_screening.sanction_type; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.sanction_type IS 'Type of sanction applied';


--
-- Name: COLUMN sanctions_screening.issuing_authority; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.issuing_authority IS 'Authority that issued sanction';


--
-- Name: COLUMN sanctions_screening.sanction_date; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.sanction_date IS 'Date sanction was issued';


--
-- Name: COLUMN sanctions_screening.expiry_date; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.expiry_date IS 'Date sanction expires (if applicable)';


--
-- Name: COLUMN sanctions_screening.sanctioned_countries; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.sanctioned_countries IS 'Countries involved in sanction';


--
-- Name: COLUMN sanctions_screening.nationality_match; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.nationality_match IS 'Customer nationality matches sanction';


--
-- Name: COLUMN sanctions_screening.residence_match; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.residence_match IS 'Customer residence matches sanction';


--
-- Name: COLUMN sanctions_screening.matched_aliases; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.matched_aliases IS 'Alternative names that matched';


--
-- Name: COLUMN sanctions_screening.matched_documents; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.matched_documents IS 'Documents that matched';


--
-- Name: COLUMN sanctions_screening.date_of_birth_match; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.date_of_birth_match IS 'Date of birth matches';


--
-- Name: COLUMN sanctions_screening.risk_rating; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.risk_rating IS 'Overall risk rating';


--
-- Name: COLUMN sanctions_screening.requires_enhanced_due_diligence; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.requires_enhanced_due_diligence IS 'Whether EDD is required';


--
-- Name: COLUMN sanctions_screening.is_false_positive; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.is_false_positive IS 'Marked as false positive';


--
-- Name: COLUMN sanctions_screening.false_positive_reason; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.false_positive_reason IS 'Reason for false positive determination';


--
-- Name: COLUMN sanctions_screening.confirmed_by; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.confirmed_by IS 'User who confirmed false positive';


--
-- Name: COLUMN sanctions_screening.review_required; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.review_required IS 'Whether manual review is required';


--
-- Name: COLUMN sanctions_screening.reviewed_by; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.reviewed_by IS 'User who performed review';


--
-- Name: COLUMN sanctions_screening.review_date; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.review_date IS 'Date of review';


--
-- Name: COLUMN sanctions_screening.review_decision; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.review_decision IS 'Decision from review';


--
-- Name: COLUMN sanctions_screening.supporting_documents; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.supporting_documents IS 'Supporting documentation';


--
-- Name: COLUMN sanctions_screening.case_number; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.case_number IS 'Compliance case reference';


--
-- Name: COLUMN sanctions_screening.notes; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.notes IS 'Additional notes';


--
-- Name: COLUMN sanctions_screening.monitoring_frequency; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.monitoring_frequency IS 'How often to re-screen';


--
-- Name: COLUMN sanctions_screening.next_check_date; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.next_check_date IS 'Next scheduled screening';


--
-- Name: COLUMN sanctions_screening.auto_clear_date; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.auto_clear_date IS 'Date to auto-clear if no issues';


--
-- Name: COLUMN sanctions_screening.reported_to_compliance; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.reported_to_compliance IS 'Whether reported to compliance';


--
-- Name: COLUMN sanctions_screening.regulatory_filing_id; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.regulatory_filing_id IS 'Regulatory filing reference';


--
-- Name: COLUMN sanctions_screening.last_checked_at; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON COLUMN compliance.sanctions_screening.last_checked_at IS 'Last time screening was performed';


--
-- Name: sanctions_monitoring_summary; Type: VIEW; Schema: compliance; Owner: postgres
--

CREATE VIEW compliance.sanctions_monitoring_summary AS
 SELECT sanctions_screening.screening_status,
    count(*) AS total_screenings,
    count(*) FILTER (WHERE (sanctions_screening.created_at >= CURRENT_DATE)) AS today_screenings,
    count(*) FILTER (WHERE ((sanctions_screening.screening_type)::text = 'onboarding'::text)) AS onboarding_checks,
    count(*) FILTER (WHERE ((sanctions_screening.screening_type)::text = 'periodic'::text)) AS periodic_checks,
    count(*) FILTER (WHERE ((sanctions_screening.screening_type)::text = 'triggered'::text)) AS triggered_checks,
    count(*) FILTER (WHERE (sanctions_screening.is_false_positive = true)) AS false_positives,
    count(*) FILTER (WHERE ((sanctions_screening.review_required = true) AND (sanctions_screening.reviewed_by IS NULL))) AS pending_reviews,
    avg(sanctions_screening.match_score) FILTER (WHERE (sanctions_screening.match_score > (0)::numeric)) AS avg_match_score,
    max(sanctions_screening.match_score) AS max_match_score
   FROM compliance.sanctions_screening
  WHERE (sanctions_screening.created_at >= (CURRENT_DATE - '30 days'::interval))
  GROUP BY sanctions_screening.screening_status
  ORDER BY
        CASE sanctions_screening.screening_status
            WHEN 'confirmed_match'::text THEN 1
            WHEN 'potential_match'::text THEN 2
            WHEN 'pending'::text THEN 3
            WHEN 'clear'::text THEN 4
            ELSE NULL::integer
        END;



--
-- Name: VIEW sanctions_monitoring_summary; Type: COMMENT; Schema: compliance; Owner: postgres
--

COMMENT ON VIEW compliance.sanctions_monitoring_summary IS 'Summary view for sanctions screening monitoring';


--
-- Name: integration_mappings; Type: TABLE; Schema: integrations; Owner: postgres
--

CREATE TABLE integrations.integration_mappings (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    integration_id uuid,
    integration_name character varying(100) NOT NULL,
    mapping_name character varying(255) NOT NULL,
    mapping_version integer DEFAULT 1,
    is_active boolean DEFAULT true,
    source_entity character varying(100) NOT NULL,
    target_entity character varying(100) NOT NULL,
    sync_direction character varying(20) NOT NULL,
    field_mappings jsonb DEFAULT '[]'::jsonb NOT NULL,
    source_data_type character varying(50),
    target_data_type character varying(50),
    type_conversion character varying(100),
    transformation_function text,
    custom_script text,
    validation_rules jsonb DEFAULT '{}'::jsonb,
    default_value_type character varying(20),
    default_value text,
    null_handling character varying(20) DEFAULT 'preserve'::character varying,
    conditions jsonb DEFAULT '{}'::jsonb,
    conditional_mappings jsonb DEFAULT '{}'::jsonb,
    value_lookup_table jsonb DEFAULT '{}'::jsonb,
    enum_mappings jsonb DEFAULT '{}'::jsonb,
    required_fields text[] DEFAULT '{}'::text[],
    unique_fields text[] DEFAULT '{}'::text[],
    validation_errors_action character varying(20) DEFAULT 'skip'::character varying,
    date_format character varying(50),
    number_format character varying(50),
    timezone_handling character varying(20) DEFAULT 'preserve'::character varying,
    on_error_action character varying(20) DEFAULT 'skip'::character varying,
    error_notification boolean DEFAULT true,
    is_indexed boolean DEFAULT false,
    cache_lookups boolean DEFAULT true,
    batch_size integer DEFAULT 1000,
    test_data jsonb DEFAULT '{}'::jsonb,
    last_tested_at timestamp with time zone,
    test_results jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    created_by uuid,
    approved_by uuid,
    CONSTRAINT chk_batch_size CHECK (((batch_size > 0) AND (batch_size <= 10000))),
    CONSTRAINT chk_default_value_type CHECK (((default_value_type IS NULL) OR ((default_value_type)::text = ANY (ARRAY[('static'::character varying)::text, ('dynamic'::character varying)::text, ('null'::character varying)::text])))),
    CONSTRAINT chk_mapping_version CHECK ((mapping_version > 0)),
    CONSTRAINT chk_null_handling CHECK (((null_handling)::text = ANY (ARRAY[('preserve'::character varying)::text, ('skip'::character varying)::text, ('default'::character varying)::text, ('error'::character varying)::text]))),
    CONSTRAINT chk_on_error_action CHECK (((on_error_action)::text = ANY (ARRAY[('skip'::character varying)::text, ('fail'::character varying)::text, ('default'::character varying)::text]))),
    CONSTRAINT chk_sync_direction CHECK (((sync_direction)::text = ANY (ARRAY[('inbound'::character varying)::text, ('outbound'::character varying)::text, ('bidirectional'::character varying)::text]))),
    CONSTRAINT chk_timezone_handling CHECK (((timezone_handling)::text = ANY (ARRAY[('preserve'::character varying)::text, ('convert'::character varying)::text, ('utc'::character varying)::text]))),
    CONSTRAINT chk_validation_errors_action CHECK (((validation_errors_action)::text = ANY (ARRAY[('skip'::character varying)::text, ('fail'::character varying)::text, ('log'::character varying)::text])))
);



--
-- Name: TABLE integration_mappings; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON TABLE integrations.integration_mappings IS 'Field mapping configurations for data synchronization between systems';


--
-- Name: COLUMN integration_mappings.id; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.id IS 'Unique identifier for mapping configuration';


--
-- Name: COLUMN integration_mappings.integration_id; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.integration_id IS 'Reference to integration configuration';


--
-- Name: COLUMN integration_mappings.integration_name; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.integration_name IS 'Name of integration for easy querying';


--
-- Name: COLUMN integration_mappings.mapping_name; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.mapping_name IS 'Human-readable name for this mapping';


--
-- Name: COLUMN integration_mappings.mapping_version; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.mapping_version IS 'Version number for tracking changes';


--
-- Name: COLUMN integration_mappings.is_active; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.is_active IS 'Whether this mapping is currently in use';


--
-- Name: COLUMN integration_mappings.source_entity; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.source_entity IS 'Source table/entity name';


--
-- Name: COLUMN integration_mappings.target_entity; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.target_entity IS 'Target table/entity name';


--
-- Name: COLUMN integration_mappings.sync_direction; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.sync_direction IS 'Direction of data flow';


--
-- Name: COLUMN integration_mappings.field_mappings; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.field_mappings IS 'JSON array of field mapping definitions';


--
-- Name: COLUMN integration_mappings.source_data_type; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.source_data_type IS 'Overall data type in source system';


--
-- Name: COLUMN integration_mappings.target_data_type; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.target_data_type IS 'Overall data type in target system';


--
-- Name: COLUMN integration_mappings.type_conversion; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.type_conversion IS 'Strategy for type conversion';


--
-- Name: COLUMN integration_mappings.transformation_function; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.transformation_function IS 'Built-in transformation to apply';


--
-- Name: COLUMN integration_mappings.custom_script; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.custom_script IS 'Custom transformation logic';


--
-- Name: COLUMN integration_mappings.validation_rules; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.validation_rules IS 'Rules for validating data';


--
-- Name: COLUMN integration_mappings.default_value_type; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.default_value_type IS 'Type of default value';


--
-- Name: COLUMN integration_mappings.default_value; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.default_value IS 'Default value or expression';


--
-- Name: COLUMN integration_mappings.null_handling; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.null_handling IS 'How to handle null values';


--
-- Name: COLUMN integration_mappings.conditions; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.conditions IS 'Conditions for applying this mapping';


--
-- Name: COLUMN integration_mappings.conditional_mappings; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.conditional_mappings IS 'Alternative mappings based on conditions';


--
-- Name: COLUMN integration_mappings.value_lookup_table; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.value_lookup_table IS 'Direct value-to-value mappings';


--
-- Name: COLUMN integration_mappings.enum_mappings; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.enum_mappings IS 'Enumeration value mappings';


--
-- Name: COLUMN integration_mappings.required_fields; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.required_fields IS 'Fields that must have values';


--
-- Name: COLUMN integration_mappings.unique_fields; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.unique_fields IS 'Fields that must be unique';


--
-- Name: COLUMN integration_mappings.validation_errors_action; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.validation_errors_action IS 'Action on validation errors';


--
-- Name: COLUMN integration_mappings.date_format; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.date_format IS 'Format for date fields';


--
-- Name: COLUMN integration_mappings.number_format; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.number_format IS 'Format for number fields';


--
-- Name: COLUMN integration_mappings.timezone_handling; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.timezone_handling IS 'How to handle timezones';


--
-- Name: COLUMN integration_mappings.on_error_action; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.on_error_action IS 'Action to take on mapping errors';


--
-- Name: COLUMN integration_mappings.error_notification; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.error_notification IS 'Whether to send error notifications';


--
-- Name: COLUMN integration_mappings.is_indexed; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.is_indexed IS 'Whether to create indexes on mapped fields';


--
-- Name: COLUMN integration_mappings.cache_lookups; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.cache_lookups IS 'Whether to cache lookup values';


--
-- Name: COLUMN integration_mappings.batch_size; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.batch_size IS 'Number of records to process per batch';


--
-- Name: COLUMN integration_mappings.test_data; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.test_data IS 'Sample data for testing mappings';


--
-- Name: COLUMN integration_mappings.last_tested_at; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.last_tested_at IS 'When mapping was last tested';


--
-- Name: COLUMN integration_mappings.test_results; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.integration_mappings.test_results IS 'Results from last test run';


--
-- Name: active_integration_mappings; Type: VIEW; Schema: integrations; Owner: postgres
--

CREATE VIEW integrations.active_integration_mappings AS
 SELECT im.id,
    im.tenant_id,
    im.integration_id,
    im.integration_name,
    im.mapping_name,
    im.mapping_version,
    im.is_active,
    im.source_entity,
    im.target_entity,
    im.sync_direction,
    im.field_mappings,
    im.source_data_type,
    im.target_data_type,
    im.type_conversion,
    im.transformation_function,
    im.custom_script,
    im.validation_rules,
    im.default_value_type,
    im.default_value,
    im.null_handling,
    im.conditions,
    im.conditional_mappings,
    im.value_lookup_table,
    im.enum_mappings,
    im.required_fields,
    im.unique_fields,
    im.validation_errors_action,
    im.date_format,
    im.number_format,
    im.timezone_handling,
    im.on_error_action,
    im.error_notification,
    im.is_indexed,
    im.cache_lookups,
    im.batch_size,
    im.test_data,
    im.last_tested_at,
    im.test_results,
    im.created_at,
    im.updated_at,
    im.created_by,
    im.approved_by,
    jsonb_array_length(im.field_mappings) AS field_count,
        CASE
            WHEN (im.last_tested_at IS NULL) THEN 'never_tested'::text
            WHEN (im.last_tested_at < (CURRENT_TIMESTAMP - '30 days'::interval)) THEN 'needs_testing'::text
            ELSE 'recently_tested'::text
        END AS test_status
   FROM integrations.integration_mappings im
  WHERE (im.is_active = true)
  ORDER BY im.integration_name, im.source_entity, im.target_entity;



--
-- Name: VIEW active_integration_mappings; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON VIEW integrations.active_integration_mappings IS 'Currently active integration mappings with test status';


--
-- Name: api_credentials; Type: TABLE; Schema: integrations; Owner: postgres
--

CREATE TABLE integrations.api_credentials (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    provider_name character varying(100) NOT NULL,
    provider_type character varying(50) NOT NULL,
    account_name character varying(255) NOT NULL,
    account_id character varying(255),
    environment character varying(20) DEFAULT 'production'::character varying NOT NULL,
    api_key_encrypted bytea,
    api_secret_encrypted bytea,
    encryption_key_id uuid NOT NULL,
    oauth_token_encrypted bytea,
    oauth_refresh_token_encrypted bytea,
    oauth_expires_at timestamp with time zone,
    webhook_secret_encrypted bytea,
    signing_key_encrypted bytea,
    base_url character varying(500),
    webhook_url character varying(500),
    custom_endpoints jsonb DEFAULT '{}'::jsonb,
    rate_limit integer,
    rate_limit_window character varying(20) DEFAULT 'hour'::character varying,
    current_usage integer DEFAULT 0,
    permissions text[] DEFAULT '{}'::text[],
    scopes text[] DEFAULT '{}'::text[],
    capabilities jsonb DEFAULT '{}'::jsonb,
    is_active boolean DEFAULT true,
    last_verified_at timestamp with time zone,
    verification_status character varying(50) DEFAULT 'unverified'::character varying,
    last_error text,
    error_count integer DEFAULT 0,
    last_error_at timestamp with time zone,
    total_requests bigint DEFAULT 0,
    successful_requests bigint DEFAULT 0,
    failed_requests bigint DEFAULT 0,
    billing_plan character varying(100),
    monthly_cost numeric(10,2) DEFAULT 0,
    usage_based_cost boolean DEFAULT false,
    last_rotated_at timestamp with time zone,
    rotation_required boolean DEFAULT false,
    rotation_schedule character varying(50),
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    created_by uuid,
    modified_by uuid,
    CONSTRAINT chk_environment CHECK (((environment)::text = ANY (ARRAY[('production'::character varying)::text, ('sandbox'::character varying)::text]))),
    CONSTRAINT chk_monthly_cost CHECK ((monthly_cost >= (0)::numeric)),
    CONSTRAINT chk_provider_type CHECK (((provider_type)::text = ANY (ARRAY[('payment'::character varying)::text, ('email'::character varying)::text, ('sms'::character varying)::text, ('analytics'::character varying)::text, ('kyc'::character varying)::text]))),
    CONSTRAINT chk_rate_limit CHECK (((rate_limit IS NULL) OR (rate_limit > 0))),
    CONSTRAINT chk_rate_limit_window CHECK (((rate_limit_window)::text = ANY (ARRAY[('second'::character varying)::text, ('minute'::character varying)::text, ('hour'::character varying)::text, ('day'::character varying)::text]))),
    CONSTRAINT chk_rotation_schedule CHECK (((rotation_schedule IS NULL) OR ((rotation_schedule)::text = ANY (ARRAY[('monthly'::character varying)::text, ('quarterly'::character varying)::text, ('annually'::character varying)::text])))),
    CONSTRAINT chk_usage_metrics CHECK (((total_requests >= 0) AND (successful_requests >= 0) AND (failed_requests >= 0) AND ((successful_requests + failed_requests) <= total_requests))),
    CONSTRAINT chk_verification_status CHECK (((verification_status)::text = ANY (ARRAY[('unverified'::character varying)::text, ('verified'::character varying)::text, ('failed'::character varying)::text])))
);



--
-- Name: TABLE api_credentials; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON TABLE integrations.api_credentials IS 'Secure storage for third-party API credentials and OAuth tokens';


--
-- Name: COLUMN api_credentials.id; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.id IS 'Unique identifier for credential record';


--
-- Name: COLUMN api_credentials.provider_name; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.provider_name IS 'Name of the service provider (SendGrid, Stripe, etc.)';


--
-- Name: COLUMN api_credentials.provider_type; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.provider_type IS 'Category of service: payment, email, sms, analytics, kyc';


--
-- Name: COLUMN api_credentials.account_name; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.account_name IS 'Human-friendly name for this credential set';


--
-- Name: COLUMN api_credentials.account_id; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.account_id IS 'Provider-specific account identifier';


--
-- Name: COLUMN api_credentials.environment; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.environment IS 'Environment: production or sandbox';


--
-- Name: COLUMN api_credentials.api_key_encrypted; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.api_key_encrypted IS 'Encrypted API key using pgcrypto';


--
-- Name: COLUMN api_credentials.api_secret_encrypted; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.api_secret_encrypted IS 'Encrypted API secret/password';


--
-- Name: COLUMN api_credentials.encryption_key_id; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.encryption_key_id IS 'Reference to key used for encryption';


--
-- Name: COLUMN api_credentials.oauth_token_encrypted; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.oauth_token_encrypted IS 'Encrypted OAuth 2.0 access token';


--
-- Name: COLUMN api_credentials.oauth_refresh_token_encrypted; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.oauth_refresh_token_encrypted IS 'Encrypted OAuth 2.0 refresh token';


--
-- Name: COLUMN api_credentials.oauth_expires_at; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.oauth_expires_at IS 'OAuth token expiration timestamp';


--
-- Name: COLUMN api_credentials.webhook_secret_encrypted; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.webhook_secret_encrypted IS 'Secret for verifying webhook signatures';


--
-- Name: COLUMN api_credentials.signing_key_encrypted; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.signing_key_encrypted IS 'Key for signing outbound requests';


--
-- Name: COLUMN api_credentials.base_url; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.base_url IS 'Base URL for API requests';


--
-- Name: COLUMN api_credentials.webhook_url; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.webhook_url IS 'Our endpoint for receiving webhooks';


--
-- Name: COLUMN api_credentials.custom_endpoints; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.custom_endpoints IS 'Provider-specific endpoint configurations';


--
-- Name: COLUMN api_credentials.rate_limit; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.rate_limit IS 'Maximum requests per rate limit window';


--
-- Name: COLUMN api_credentials.rate_limit_window; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.rate_limit_window IS 'Time window for rate limiting';


--
-- Name: COLUMN api_credentials.current_usage; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.current_usage IS 'Current usage within rate limit window';


--
-- Name: COLUMN api_credentials.permissions; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.permissions IS 'Array of granted permissions';


--
-- Name: COLUMN api_credentials.scopes; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.scopes IS 'OAuth scopes for token';


--
-- Name: COLUMN api_credentials.capabilities; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.capabilities IS 'Provider-specific feature capabilities';


--
-- Name: COLUMN api_credentials.is_active; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.is_active IS 'Whether these credentials are currently active';


--
-- Name: COLUMN api_credentials.last_verified_at; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.last_verified_at IS 'Last successful credential verification';


--
-- Name: COLUMN api_credentials.verification_status; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.verification_status IS 'Current verification status';


--
-- Name: COLUMN api_credentials.last_error; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.last_error IS 'Most recent error message';


--
-- Name: COLUMN api_credentials.error_count; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.error_count IS 'Total number of errors encountered';


--
-- Name: COLUMN api_credentials.last_error_at; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.last_error_at IS 'Timestamp of most recent error';


--
-- Name: COLUMN api_credentials.total_requests; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.total_requests IS 'Total API requests made with these credentials';


--
-- Name: COLUMN api_credentials.successful_requests; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.successful_requests IS 'Count of successful API requests';


--
-- Name: COLUMN api_credentials.failed_requests; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.failed_requests IS 'Count of failed API requests';


--
-- Name: COLUMN api_credentials.billing_plan; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.billing_plan IS 'Current billing plan with provider';


--
-- Name: COLUMN api_credentials.monthly_cost; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.monthly_cost IS 'Monthly cost in USD';


--
-- Name: COLUMN api_credentials.usage_based_cost; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.usage_based_cost IS 'Whether billing is usage-based';


--
-- Name: COLUMN api_credentials.last_rotated_at; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.last_rotated_at IS 'When credentials were last rotated';


--
-- Name: COLUMN api_credentials.rotation_required; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.rotation_required IS 'Flag indicating rotation is needed';


--
-- Name: COLUMN api_credentials.rotation_schedule; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.api_credentials.rotation_schedule IS 'Credential rotation schedule';


--
-- Name: credential_status; Type: VIEW; Schema: integrations; Owner: postgres
--

CREATE VIEW integrations.credential_status AS
 SELECT api_credentials.id,
    api_credentials.provider_name,
    api_credentials.provider_type,
    api_credentials.environment,
    api_credentials.account_name,
    api_credentials.is_active,
    api_credentials.verification_status,
    api_credentials.last_verified_at,
        CASE
            WHEN ((api_credentials.oauth_expires_at IS NOT NULL) AND (api_credentials.oauth_expires_at < CURRENT_TIMESTAMP)) THEN 'expired'::text
            WHEN ((api_credentials.oauth_expires_at IS NOT NULL) AND (api_credentials.oauth_expires_at < (CURRENT_TIMESTAMP + '7 days'::interval))) THEN 'expiring_soon'::text
            ELSE 'valid'::text
        END AS oauth_status,
    api_credentials.rotation_required,
    api_credentials.last_rotated_at,
    api_credentials.error_count,
    api_credentials.last_error_at,
    round((((api_credentials.successful_requests)::numeric / (NULLIF(api_credentials.total_requests, 0))::numeric) * (100)::numeric), 2) AS success_rate
   FROM integrations.api_credentials;



--
-- Name: VIEW credential_status; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON VIEW integrations.credential_status IS 'Summary view of API credential health and status';


--
-- Name: external_references; Type: TABLE; Schema: integrations; Owner: postgres
--

CREATE TABLE integrations.external_references (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    internal_entity_type character varying(100) NOT NULL,
    internal_entity_id uuid NOT NULL,
    external_system character varying(100) NOT NULL,
    external_entity_type character varying(100) NOT NULL,
    external_entity_id character varying(255) NOT NULL,
    integration_id uuid,
    integration_name character varying(100),
    last_synced_at timestamp with time zone,
    sync_status character varying(20) DEFAULT 'active'::character varying,
    external_version character varying(50),
    internal_version integer DEFAULT 1,
    version_conflict boolean DEFAULT false,
    mapped_fields jsonb DEFAULT '{}'::jsonb,
    unmapped_fields jsonb DEFAULT '{}'::jsonb,
    custom_fields jsonb DEFAULT '{}'::jsonb,
    is_validated boolean DEFAULT false,
    validation_errors jsonb DEFAULT '[]'::jsonb,
    last_validated_at timestamp with time zone,
    conflict_strategy character varying(20) DEFAULT 'manual'::character varying,
    internal_updated_at timestamp with time zone,
    external_updated_at timestamp with time zone,
    needs_sync boolean DEFAULT false,
    parent_external_id character varying(255),
    child_external_ids text[] DEFAULT '{}'::text[],
    related_entities jsonb DEFAULT '{}'::jsonb,
    external_created_at timestamp with time zone,
    external_modified_at timestamp with time zone,
    external_created_by character varying(255),
    confidence_score numeric(3,2) DEFAULT 1.00,
    data_completeness numeric(3,2) DEFAULT 1.00,
    quality_issues jsonb DEFAULT '[]'::jsonb,
    external_url character varying(500),
    external_api_endpoint character varying(500),
    requires_auth boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    created_by uuid,
    CONSTRAINT chk_confidence_score CHECK (((confidence_score >= (0)::numeric) AND (confidence_score <= (1)::numeric))),
    CONSTRAINT chk_conflict_strategy CHECK (((conflict_strategy)::text = ANY (ARRAY[('internal_wins'::character varying)::text, ('external_wins'::character varying)::text, ('manual'::character varying)::text, ('newest_wins'::character varying)::text]))),
    CONSTRAINT chk_data_completeness CHECK (((data_completeness >= (0)::numeric) AND (data_completeness <= (1)::numeric))),
    CONSTRAINT chk_sync_status CHECK (((sync_status)::text = ANY (ARRAY[('active'::character varying)::text, ('deleted'::character varying)::text, ('archived'::character varying)::text, ('error'::character varying)::text])))
);



--
-- Name: TABLE external_references; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON TABLE integrations.external_references IS 'Maps internal entities to their corresponding external system identifiers';


--
-- Name: COLUMN external_references.id; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.id IS 'Unique identifier for reference mapping';


--
-- Name: COLUMN external_references.internal_entity_type; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.internal_entity_type IS 'Type of internal entity (user, event, ticket, etc.)';


--
-- Name: COLUMN external_references.internal_entity_id; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.internal_entity_id IS 'UUID of internal entity';


--
-- Name: COLUMN external_references.external_system; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.external_system IS 'Name of external system (Stripe, Eventbrite, etc.)';


--
-- Name: COLUMN external_references.external_entity_type; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.external_entity_type IS 'Entity type in external system';


--
-- Name: COLUMN external_references.external_entity_id; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.external_entity_id IS 'Unique identifier in external system';


--
-- Name: COLUMN external_references.integration_id; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.integration_id IS 'Reference to integration configuration';


--
-- Name: COLUMN external_references.integration_name; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.integration_name IS 'Name of integration (denormalized)';


--
-- Name: COLUMN external_references.last_synced_at; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.last_synced_at IS 'Last successful synchronization timestamp';


--
-- Name: COLUMN external_references.sync_status; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.sync_status IS 'Current sync status: active, deleted, archived, error';


--
-- Name: COLUMN external_references.external_version; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.external_version IS 'Version/revision number in external system';


--
-- Name: COLUMN external_references.internal_version; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.internal_version IS 'Version number in internal system';


--
-- Name: COLUMN external_references.version_conflict; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.version_conflict IS 'Flag indicating version mismatch';


--
-- Name: COLUMN external_references.mapped_fields; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.mapped_fields IS 'JSON object of successfully mapped fields';


--
-- Name: COLUMN external_references.unmapped_fields; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.unmapped_fields IS 'JSON object of fields that could not be mapped';


--
-- Name: COLUMN external_references.custom_fields; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.custom_fields IS 'JSON object of custom field mappings';


--
-- Name: COLUMN external_references.is_validated; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.is_validated IS 'Whether this mapping has been validated';


--
-- Name: COLUMN external_references.validation_errors; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.validation_errors IS 'Array of validation error details';


--
-- Name: COLUMN external_references.last_validated_at; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.last_validated_at IS 'Timestamp of last validation';


--
-- Name: COLUMN external_references.conflict_strategy; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.conflict_strategy IS 'How to resolve conflicts during sync';


--
-- Name: COLUMN external_references.internal_updated_at; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.internal_updated_at IS 'Last update timestamp for internal entity';


--
-- Name: COLUMN external_references.external_updated_at; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.external_updated_at IS 'Last update timestamp for external entity';


--
-- Name: COLUMN external_references.needs_sync; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.needs_sync IS 'Flag indicating sync is needed';


--
-- Name: COLUMN external_references.parent_external_id; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.parent_external_id IS 'Parent entity ID in external system';


--
-- Name: COLUMN external_references.child_external_ids; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.child_external_ids IS 'Array of child entity IDs in external system';


--
-- Name: COLUMN external_references.related_entities; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.related_entities IS 'JSON object of related entity mappings';


--
-- Name: COLUMN external_references.external_created_at; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.external_created_at IS 'Creation timestamp in external system';


--
-- Name: COLUMN external_references.external_modified_at; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.external_modified_at IS 'Last modification timestamp in external system';


--
-- Name: COLUMN external_references.external_created_by; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.external_created_by IS 'Creator identifier in external system';


--
-- Name: COLUMN external_references.confidence_score; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.confidence_score IS 'Confidence level in mapping accuracy (0-1)';


--
-- Name: COLUMN external_references.data_completeness; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.data_completeness IS 'Percentage of data completeness (0-1)';


--
-- Name: COLUMN external_references.quality_issues; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.quality_issues IS 'Array of identified data quality issues';


--
-- Name: COLUMN external_references.external_url; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.external_url IS 'Direct URL to entity in external system UI';


--
-- Name: COLUMN external_references.external_api_endpoint; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.external_api_endpoint IS 'API endpoint for accessing entity';


--
-- Name: COLUMN external_references.requires_auth; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.external_references.requires_auth IS 'Whether authentication is required for access';


--
-- Name: external_reference_sync_status; Type: VIEW; Schema: integrations; Owner: postgres
--

CREATE VIEW integrations.external_reference_sync_status AS
 SELECT external_references.external_system,
    external_references.internal_entity_type,
    external_references.sync_status,
    count(*) AS count,
    count(*) FILTER (WHERE (external_references.needs_sync = true)) AS needs_sync_count,
    count(*) FILTER (WHERE (external_references.version_conflict = true)) AS version_conflicts,
    avg(external_references.confidence_score) AS avg_confidence,
    avg(external_references.data_completeness) AS avg_completeness,
    max(external_references.last_synced_at) AS latest_sync
   FROM integrations.external_references
  GROUP BY external_references.external_system, external_references.internal_entity_type, external_references.sync_status
  ORDER BY external_references.external_system, external_references.internal_entity_type, external_references.sync_status;



--
-- Name: VIEW external_reference_sync_status; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON VIEW integrations.external_reference_sync_status IS 'Overview of external reference synchronization status';


--
-- Name: sync_logs; Type: TABLE; Schema: integrations; Owner: postgres
--

CREATE TABLE integrations.sync_logs (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    sync_id character varying(255) NOT NULL,
    sync_type character varying(20) NOT NULL,
    integration_name character varying(100) NOT NULL,
    integration_id uuid,
    direction character varying(20) NOT NULL,
    started_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    completed_at timestamp with time zone,
    duration_seconds integer,
    status character varying(20) DEFAULT 'running'::character varying NOT NULL,
    entity_type character varying(100),
    entity_count integer DEFAULT 0,
    date_range_start timestamp with time zone,
    date_range_end timestamp with time zone,
    records_processed integer DEFAULT 0,
    records_created integer DEFAULT 0,
    records_updated integer DEFAULT 0,
    records_deleted integer DEFAULT 0,
    records_skipped integer DEFAULT 0,
    errors_count integer DEFAULT 0,
    error_details jsonb DEFAULT '[]'::jsonb,
    first_error_at timestamp with time zone,
    records_per_second numeric(10,2),
    peak_memory_mb integer,
    api_calls_made integer DEFAULT 0,
    retry_attempt integer DEFAULT 0,
    retry_of_sync_id uuid,
    max_retries integer DEFAULT 3,
    last_checkpoint jsonb,
    checkpoint_data jsonb DEFAULT '{}'::jsonb,
    resume_token character varying(500),
    validation_errors integer DEFAULT 0,
    validation_warnings integer DEFAULT 0,
    validation_report jsonb DEFAULT '{}'::jsonb,
    api_credits_used integer DEFAULT 0,
    estimated_cost numeric(10,4) DEFAULT 0,
    notification_sent boolean DEFAULT false,
    notification_recipients text[] DEFAULT '{}'::text[],
    tags text[] DEFAULT '{}'::text[],
    context jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_api_credits CHECK ((api_credits_used >= 0)),
    CONSTRAINT chk_date_range CHECK ((((date_range_start IS NULL) AND (date_range_end IS NULL)) OR ((date_range_start IS NOT NULL) AND (date_range_end IS NOT NULL) AND (date_range_end >= date_range_start)))),
    CONSTRAINT chk_direction CHECK (((direction)::text = ANY (ARRAY[('inbound'::character varying)::text, ('outbound'::character varying)::text, ('bidirectional'::character varying)::text]))),
    CONSTRAINT chk_errors_count CHECK ((errors_count >= 0)),
    CONSTRAINT chk_estimated_cost CHECK ((estimated_cost >= (0)::numeric)),
    CONSTRAINT chk_max_retries CHECK (((max_retries >= 0) AND (max_retries <= 10))),
    CONSTRAINT chk_records CHECK (((records_processed >= 0) AND (records_created >= 0) AND (records_updated >= 0) AND (records_deleted >= 0) AND (records_skipped >= 0) AND ((((records_created + records_updated) + records_deleted) + records_skipped) <= records_processed))),
    CONSTRAINT chk_retry_attempt CHECK ((retry_attempt >= 0)),
    CONSTRAINT chk_status CHECK (((status)::text = ANY (ARRAY[('running'::character varying)::text, ('completed'::character varying)::text, ('failed'::character varying)::text, ('partial'::character varying)::text, ('cancelled'::character varying)::text]))),
    CONSTRAINT chk_sync_type CHECK (((sync_type)::text = ANY (ARRAY[('full'::character varying)::text, ('incremental'::character varying)::text, ('real_time'::character varying)::text]))),
    CONSTRAINT chk_validation CHECK (((validation_errors >= 0) AND (validation_warnings >= 0)))
);



--
-- Name: TABLE sync_logs; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON TABLE integrations.sync_logs IS 'Detailed logs of all data synchronization operations';


--
-- Name: COLUMN sync_logs.id; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.id IS 'Unique identifier for sync log entry';


--
-- Name: COLUMN sync_logs.sync_id; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.sync_id IS 'Business identifier for sync operation';


--
-- Name: COLUMN sync_logs.sync_type; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.sync_type IS 'Type of sync: full, incremental, or real_time';


--
-- Name: COLUMN sync_logs.integration_name; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.integration_name IS 'Name of the integration being synced';


--
-- Name: COLUMN sync_logs.integration_id; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.integration_id IS 'Reference to integration configuration';


--
-- Name: COLUMN sync_logs.direction; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.direction IS 'Data flow direction: inbound, outbound, or bidirectional';


--
-- Name: COLUMN sync_logs.started_at; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.started_at IS 'When the sync operation started';


--
-- Name: COLUMN sync_logs.completed_at; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.completed_at IS 'When the sync operation completed';


--
-- Name: COLUMN sync_logs.duration_seconds; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.duration_seconds IS 'Total time taken in seconds';


--
-- Name: COLUMN sync_logs.status; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.status IS 'Current status of sync operation';


--
-- Name: COLUMN sync_logs.entity_type; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.entity_type IS 'Type of entities being synchronized';


--
-- Name: COLUMN sync_logs.entity_count; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.entity_count IS 'Total number of entities to sync';


--
-- Name: COLUMN sync_logs.date_range_start; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.date_range_start IS 'Start date for incremental sync';


--
-- Name: COLUMN sync_logs.date_range_end; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.date_range_end IS 'End date for incremental sync';


--
-- Name: COLUMN sync_logs.records_processed; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.records_processed IS 'Total records processed';


--
-- Name: COLUMN sync_logs.records_created; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.records_created IS 'New records created';


--
-- Name: COLUMN sync_logs.records_updated; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.records_updated IS 'Existing records updated';


--
-- Name: COLUMN sync_logs.records_deleted; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.records_deleted IS 'Records deleted';


--
-- Name: COLUMN sync_logs.records_skipped; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.records_skipped IS 'Records skipped due to rules or errors';


--
-- Name: COLUMN sync_logs.errors_count; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.errors_count IS 'Total number of errors encountered';


--
-- Name: COLUMN sync_logs.error_details; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.error_details IS 'Array of detailed error information';


--
-- Name: COLUMN sync_logs.first_error_at; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.first_error_at IS 'Timestamp of first error';


--
-- Name: COLUMN sync_logs.records_per_second; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.records_per_second IS 'Processing throughput';


--
-- Name: COLUMN sync_logs.peak_memory_mb; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.peak_memory_mb IS 'Maximum memory used in MB';


--
-- Name: COLUMN sync_logs.api_calls_made; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.api_calls_made IS 'Number of external API calls';


--
-- Name: COLUMN sync_logs.retry_attempt; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.retry_attempt IS 'Which retry attempt this is';


--
-- Name: COLUMN sync_logs.retry_of_sync_id; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.retry_of_sync_id IS 'Original sync being retried';


--
-- Name: COLUMN sync_logs.max_retries; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.max_retries IS 'Maximum retries allowed';


--
-- Name: COLUMN sync_logs.last_checkpoint; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.last_checkpoint IS 'Last successful checkpoint state';


--
-- Name: COLUMN sync_logs.checkpoint_data; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.checkpoint_data IS 'Data needed to resume sync';


--
-- Name: COLUMN sync_logs.resume_token; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.resume_token IS 'Token for resuming interrupted sync';


--
-- Name: COLUMN sync_logs.validation_errors; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.validation_errors IS 'Count of data validation errors';


--
-- Name: COLUMN sync_logs.validation_warnings; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.validation_warnings IS 'Count of data validation warnings';


--
-- Name: COLUMN sync_logs.validation_report; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.validation_report IS 'Detailed validation findings';


--
-- Name: COLUMN sync_logs.api_credits_used; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.api_credits_used IS 'API credits consumed by sync';


--
-- Name: COLUMN sync_logs.estimated_cost; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.estimated_cost IS 'Estimated cost in dollars';


--
-- Name: COLUMN sync_logs.notification_sent; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.notification_sent IS 'Whether completion notifications were sent';


--
-- Name: COLUMN sync_logs.notification_recipients; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.notification_recipients IS 'Array of notification recipients';


--
-- Name: COLUMN sync_logs.tags; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.tags IS 'Tags for filtering and categorization';


--
-- Name: COLUMN sync_logs.context; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.sync_logs.context IS 'Additional context and metadata';


--
-- Name: sync_statistics; Type: VIEW; Schema: integrations; Owner: postgres
--

CREATE VIEW integrations.sync_statistics AS
 SELECT sync_logs.integration_name,
    sync_logs.sync_type,
    sync_logs.direction,
    count(*) AS total_syncs,
    count(*) FILTER (WHERE ((sync_logs.status)::text = 'completed'::text)) AS successful_syncs,
    count(*) FILTER (WHERE ((sync_logs.status)::text = 'failed'::text)) AS failed_syncs,
    count(*) FILTER (WHERE ((sync_logs.status)::text = 'running'::text)) AS running_syncs,
    avg(sync_logs.duration_seconds) FILTER (WHERE ((sync_logs.status)::text = 'completed'::text)) AS avg_duration_seconds,
    avg(sync_logs.records_per_second) FILTER (WHERE ((sync_logs.status)::text = 'completed'::text)) AS avg_records_per_second,
    sum(sync_logs.records_processed) AS total_records_processed,
    sum(sync_logs.api_credits_used) AS total_api_credits,
    sum(sync_logs.estimated_cost) AS total_estimated_cost,
    max(sync_logs.started_at) AS last_sync_at
   FROM integrations.sync_logs
  WHERE (sync_logs.created_at >= (CURRENT_DATE - '30 days'::interval))
  GROUP BY sync_logs.integration_name, sync_logs.sync_type, sync_logs.direction;



--
-- Name: VIEW sync_statistics; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON VIEW integrations.sync_statistics IS 'Aggregated sync statistics for the last 30 days';


--
-- Name: webhook_endpoints; Type: TABLE; Schema: integrations; Owner: postgres
--

CREATE TABLE integrations.webhook_endpoints (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    url character varying(1000) NOT NULL,
    name character varying(255) NOT NULL,
    description text,
    event_types text[] DEFAULT '{}'::text[],
    all_events boolean DEFAULT false,
    auth_type character varying(20) DEFAULT 'none'::character varying,
    auth_credentials_encrypted bytea,
    custom_headers jsonb DEFAULT '{}'::jsonb,
    content_type character varying(50) DEFAULT 'application/json'::character varying,
    max_retries integer DEFAULT 3,
    retry_delay_seconds integer DEFAULT 60,
    failure_threshold integer DEFAULT 5,
    success_threshold integer DEFAULT 2,
    timeout_seconds integer DEFAULT 30,
    is_active boolean DEFAULT true,
    is_paused boolean DEFAULT false,
    paused_until timestamp with time zone,
    last_success_at timestamp with time zone,
    last_failure_at timestamp with time zone,
    consecutive_failures integer DEFAULT 0,
    total_calls bigint DEFAULT 0,
    successful_calls bigint DEFAULT 0,
    average_response_time_ms integer DEFAULT 0,
    include_full_payload boolean DEFAULT true,
    payload_template jsonb,
    filter_rules jsonb DEFAULT '{}'::jsonb,
    transformation_rules jsonb DEFAULT '{}'::jsonb,
    rate_limit_per_minute integer DEFAULT 60,
    current_minute_calls integer DEFAULT 0,
    verify_ssl boolean DEFAULT true,
    ssl_certificate_fingerprint character varying(64),
    api_version character varying(20) DEFAULT 'v1'::character varying,
    supported_versions text[] DEFAULT '{v1}'::text[],
    tags text[] DEFAULT '{}'::text[],
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    created_by uuid,
    CONSTRAINT chk_auth_type CHECK (((auth_type)::text = ANY (ARRAY[('none'::character varying)::text, ('basic'::character varying)::text, ('bearer'::character varying)::text, ('hmac'::character varying)::text]))),
    CONSTRAINT chk_consecutive_failures CHECK ((consecutive_failures >= 0)),
    CONSTRAINT chk_failure_threshold CHECK (((failure_threshold >= 1) AND (failure_threshold <= 100))),
    CONSTRAINT chk_max_retries CHECK (((max_retries >= 0) AND (max_retries <= 10))),
    CONSTRAINT chk_metrics CHECK (((total_calls >= 0) AND (successful_calls >= 0) AND (successful_calls <= total_calls) AND (average_response_time_ms >= 0))),
    CONSTRAINT chk_rate_limit CHECK (((rate_limit_per_minute >= 0) AND (rate_limit_per_minute <= 1000))),
    CONSTRAINT chk_retry_delay CHECK (((retry_delay_seconds >= 0) AND (retry_delay_seconds <= 3600))),
    CONSTRAINT chk_success_threshold CHECK (((success_threshold >= 1) AND (success_threshold <= 10))),
    CONSTRAINT chk_timeout_seconds CHECK (((timeout_seconds >= 1) AND (timeout_seconds <= 300))),
    CONSTRAINT chk_url_format CHECK (((url)::text ~ '^https?://.*'::text))
);



--
-- Name: TABLE webhook_endpoints; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON TABLE integrations.webhook_endpoints IS 'Configuration for webhook endpoints to deliver events to external systems';


--
-- Name: COLUMN webhook_endpoints.id; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.id IS 'Unique identifier for webhook endpoint';


--
-- Name: COLUMN webhook_endpoints.url; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.url IS 'HTTPS URL to send webhook events to';


--
-- Name: COLUMN webhook_endpoints.name; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.name IS 'Human-friendly name for this endpoint';


--
-- Name: COLUMN webhook_endpoints.description; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.description IS 'Detailed description of endpoint purpose';


--
-- Name: COLUMN webhook_endpoints.event_types; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.event_types IS 'Array of specific event types to send';


--
-- Name: COLUMN webhook_endpoints.all_events; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.all_events IS 'Whether to send all event types';


--
-- Name: COLUMN webhook_endpoints.auth_type; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.auth_type IS 'Authentication method: none, basic, bearer, hmac';


--
-- Name: COLUMN webhook_endpoints.auth_credentials_encrypted; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.auth_credentials_encrypted IS 'Encrypted authentication credentials';


--
-- Name: COLUMN webhook_endpoints.custom_headers; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.custom_headers IS 'Additional HTTP headers to include';


--
-- Name: COLUMN webhook_endpoints.content_type; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.content_type IS 'Content-Type header for requests';


--
-- Name: COLUMN webhook_endpoints.max_retries; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.max_retries IS 'Maximum number of retry attempts';


--
-- Name: COLUMN webhook_endpoints.retry_delay_seconds; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.retry_delay_seconds IS 'Seconds to wait between retries';


--
-- Name: COLUMN webhook_endpoints.failure_threshold; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.failure_threshold IS 'Consecutive failures before circuit opens';


--
-- Name: COLUMN webhook_endpoints.success_threshold; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.success_threshold IS 'Consecutive successes to close circuit';


--
-- Name: COLUMN webhook_endpoints.timeout_seconds; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.timeout_seconds IS 'HTTP request timeout in seconds';


--
-- Name: COLUMN webhook_endpoints.is_active; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.is_active IS 'Whether endpoint is currently active';


--
-- Name: COLUMN webhook_endpoints.is_paused; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.is_paused IS 'Whether endpoint is temporarily paused';


--
-- Name: COLUMN webhook_endpoints.paused_until; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.paused_until IS 'Automatic resume timestamp';


--
-- Name: COLUMN webhook_endpoints.last_success_at; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.last_success_at IS 'Timestamp of last successful delivery';


--
-- Name: COLUMN webhook_endpoints.last_failure_at; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.last_failure_at IS 'Timestamp of last failed delivery';


--
-- Name: COLUMN webhook_endpoints.consecutive_failures; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.consecutive_failures IS 'Current consecutive failure count';


--
-- Name: COLUMN webhook_endpoints.total_calls; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.total_calls IS 'Total number of webhook calls made';


--
-- Name: COLUMN webhook_endpoints.successful_calls; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.successful_calls IS 'Number of successful deliveries';


--
-- Name: COLUMN webhook_endpoints.average_response_time_ms; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.average_response_time_ms IS 'Average response time in milliseconds';


--
-- Name: COLUMN webhook_endpoints.include_full_payload; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.include_full_payload IS 'Whether to include complete event data';


--
-- Name: COLUMN webhook_endpoints.payload_template; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.payload_template IS 'Custom template for payload structure';


--
-- Name: COLUMN webhook_endpoints.filter_rules; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.filter_rules IS 'JSON rules for filtering events';


--
-- Name: COLUMN webhook_endpoints.transformation_rules; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.transformation_rules IS 'JSON rules for transforming payloads';


--
-- Name: COLUMN webhook_endpoints.rate_limit_per_minute; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.rate_limit_per_minute IS 'Maximum calls allowed per minute';


--
-- Name: COLUMN webhook_endpoints.current_minute_calls; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.current_minute_calls IS 'Calls made in current minute window';


--
-- Name: COLUMN webhook_endpoints.verify_ssl; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.verify_ssl IS 'Whether to verify SSL certificates';


--
-- Name: COLUMN webhook_endpoints.ssl_certificate_fingerprint; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.ssl_certificate_fingerprint IS 'Expected SSL certificate fingerprint';


--
-- Name: COLUMN webhook_endpoints.api_version; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.api_version IS 'API version to use for this endpoint';


--
-- Name: COLUMN webhook_endpoints.supported_versions; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.supported_versions IS 'Array of supported API versions';


--
-- Name: COLUMN webhook_endpoints.tags; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.tags IS 'Tags for organizing and filtering endpoints';


--
-- Name: COLUMN webhook_endpoints.metadata; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON COLUMN integrations.webhook_endpoints.metadata IS 'Additional flexible metadata';


--
-- Name: webhook_health; Type: VIEW; Schema: integrations; Owner: postgres
--

CREATE VIEW integrations.webhook_health AS
 SELECT webhook_endpoints.id,
    webhook_endpoints.name,
    webhook_endpoints.url,
    webhook_endpoints.is_active,
    webhook_endpoints.is_paused,
        CASE
            WHEN webhook_endpoints.is_paused THEN 'circuit_open'::text
            WHEN (webhook_endpoints.consecutive_failures > 0) THEN 'degraded'::text
            WHEN (webhook_endpoints.last_success_at > (CURRENT_TIMESTAMP - '01:00:00'::interval)) THEN 'healthy'::text
            ELSE 'unknown'::text
        END AS health_status,
    webhook_endpoints.consecutive_failures,
    webhook_endpoints.failure_threshold,
    round((((webhook_endpoints.successful_calls)::numeric / (NULLIF(webhook_endpoints.total_calls, 0))::numeric) * (100)::numeric), 2) AS success_rate,
    webhook_endpoints.average_response_time_ms,
    webhook_endpoints.last_success_at,
    webhook_endpoints.last_failure_at
   FROM integrations.webhook_endpoints;



--
-- Name: VIEW webhook_health; Type: COMMENT; Schema: integrations; Owner: postgres
--

COMMENT ON VIEW integrations.webhook_health IS 'Real-time health status of webhook endpoints';


--
-- Name: royalty_settlements; Type: TABLE; Schema: marketplace; Owner: postgres
--

CREATE TABLE marketplace.royalty_settlements (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    venue_id uuid NOT NULL,
    settlement_period_start date NOT NULL,
    settlement_period_end date NOT NULL,
    total_royalties numeric(15,2) NOT NULL,
    total_transactions integer NOT NULL,
    status character varying(50) DEFAULT 'pending'::character varying NOT NULL,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    processed_at timestamp with time zone,
    CONSTRAINT chk_settlement_period CHECK ((settlement_period_end >= settlement_period_start)),
    CONSTRAINT royalty_settlements_total_royalties_check CHECK ((total_royalties >= (0)::numeric)),
    CONSTRAINT royalty_settlements_total_transactions_check CHECK ((total_transactions > 0))
);



--
-- Name: campaigns; Type: TABLE; Schema: notifications; Owner: postgres
--

CREATE TABLE notifications.campaigns (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    name character varying(255) NOT NULL,
    slug character varying(255) NOT NULL,
    description text,
    type character varying(50) DEFAULT 'email'::character varying NOT NULL,
    status character varying(50) DEFAULT 'draft'::character varying NOT NULL,
    audience_segment_ids uuid[] DEFAULT '{}'::uuid[],
    audience_count integer DEFAULT 0,
    audience_criteria jsonb DEFAULT '{}'::jsonb,
    scheduled_at timestamp with time zone,
    started_at timestamp with time zone,
    completed_at timestamp with time zone,
    template_id uuid,
    subject_line character varying(500),
    preview_text character varying(200),
    is_ab_test boolean DEFAULT false,
    variants jsonb DEFAULT '{}'::jsonb,
    winning_variant_id uuid,
    goal_type character varying(50),
    goal_target integer,
    goal_achieved integer DEFAULT 0,
    budget_amount numeric(10,2) DEFAULT 0,
    spent_amount numeric(10,2) DEFAULT 0,
    cost_per_send numeric(10,4) DEFAULT 0,
    sends_count integer DEFAULT 0,
    opens_count integer DEFAULT 0,
    clicks_count integer DEFAULT 0,
    conversions_count integer DEFAULT 0,
    revenue_generated numeric(12,2) DEFAULT 0,
    suppression_list_ids uuid[] DEFAULT '{}'::uuid[],
    excluded_count integer DEFAULT 0,
    requires_approval boolean DEFAULT false,
    approved_by uuid,
    approved_at timestamp with time zone,
    tags text[] DEFAULT '{}'::text[],
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    created_by uuid,
    CONSTRAINT chk_approval_required CHECK (((requires_approval = false) OR ((requires_approval = true) AND (approved_by IS NOT NULL) AND (approved_at IS NOT NULL)) OR ((requires_approval = true) AND ((status)::text = 'draft'::text)))),
    CONSTRAINT chk_audience_count CHECK ((audience_count >= 0)),
    CONSTRAINT chk_budget_amount CHECK ((budget_amount >= (0)::numeric)),
    CONSTRAINT chk_campaign_status CHECK (((status)::text = ANY (ARRAY[('draft'::character varying)::text, ('scheduled'::character varying)::text, ('active'::character varying)::text, ('paused'::character varying)::text, ('completed'::character varying)::text, ('cancelled'::character varying)::text]))),
    CONSTRAINT chk_campaign_type CHECK (((type)::text = ANY (ARRAY[('email'::character varying)::text, ('sms'::character varying)::text, ('push'::character varying)::text, ('multi_channel'::character varying)::text]))),
    CONSTRAINT chk_clicks_count CHECK ((clicks_count >= 0)),
    CONSTRAINT chk_conversions_count CHECK ((conversions_count >= 0)),
    CONSTRAINT chk_cost_per_send CHECK ((cost_per_send >= (0)::numeric)),
    CONSTRAINT chk_excluded_count CHECK ((excluded_count >= 0)),
    CONSTRAINT chk_goal_type CHECK (((goal_type IS NULL) OR ((goal_type)::text = ANY (ARRAY[('clicks'::character varying)::text, ('conversions'::character varying)::text, ('revenue'::character varying)::text, ('engagement'::character varying)::text, ('opens'::character varying)::text])))),
    CONSTRAINT chk_opens_count CHECK ((opens_count >= 0)),
    CONSTRAINT chk_revenue_generated CHECK ((revenue_generated >= (0)::numeric)),
    CONSTRAINT chk_sends_count CHECK ((sends_count >= 0)),
    CONSTRAINT chk_slug_format CHECK (((slug)::text ~ '^[a-z0-9-]+$'::text)),
    CONSTRAINT chk_spent_amount CHECK ((spent_amount >= (0)::numeric))
);



--
-- Name: TABLE campaigns; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON TABLE notifications.campaigns IS 'Marketing campaigns for multi-channel customer communication';


--
-- Name: COLUMN campaigns.id; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.id IS 'Unique identifier for the campaign';


--
-- Name: COLUMN campaigns.name; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.name IS 'Human-readable campaign name for internal use';


--
-- Name: COLUMN campaigns.slug; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.slug IS 'URL-friendly unique identifier for API and routing';


--
-- Name: COLUMN campaigns.description; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.description IS 'Detailed description of campaign purpose and goals';


--
-- Name: COLUMN campaigns.type; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.type IS 'Campaign channel type: email, sms, push, or multi_channel';


--
-- Name: COLUMN campaigns.status; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.status IS 'Current campaign status in lifecycle';


--
-- Name: COLUMN campaigns.audience_segment_ids; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.audience_segment_ids IS 'Array of audience segment IDs to target';


--
-- Name: COLUMN campaigns.audience_count; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.audience_count IS 'Total number of recipients in target audience';


--
-- Name: COLUMN campaigns.audience_criteria; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.audience_criteria IS 'Dynamic criteria for audience selection (filters, rules)';


--
-- Name: COLUMN campaigns.scheduled_at; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.scheduled_at IS 'Planned start time for the campaign';


--
-- Name: COLUMN campaigns.started_at; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.started_at IS 'Actual start time when campaign began sending';


--
-- Name: COLUMN campaigns.completed_at; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.completed_at IS 'Time when campaign finished sending';


--
-- Name: COLUMN campaigns.template_id; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.template_id IS 'Reference to notification template to use';


--
-- Name: COLUMN campaigns.subject_line; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.subject_line IS 'Email subject or push notification title';


--
-- Name: COLUMN campaigns.preview_text; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.preview_text IS 'Preview text shown in email clients';


--
-- Name: COLUMN campaigns.is_ab_test; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.is_ab_test IS 'Whether campaign is running A/B test variants';


--
-- Name: COLUMN campaigns.variants; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.variants IS 'Configuration for each A/B test variant';


--
-- Name: COLUMN campaigns.winning_variant_id; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.winning_variant_id IS 'ID of variant that won A/B test';


--
-- Name: COLUMN campaigns.goal_type; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.goal_type IS 'Primary goal metric: clicks, conversions, revenue, engagement';


--
-- Name: COLUMN campaigns.goal_target; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.goal_target IS 'Target value for the primary goal';


--
-- Name: COLUMN campaigns.goal_achieved; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.goal_achieved IS 'Actual value achieved for the goal';


--
-- Name: COLUMN campaigns.budget_amount; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.budget_amount IS 'Total budget allocated for campaign';


--
-- Name: COLUMN campaigns.spent_amount; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.spent_amount IS 'Amount spent so far on campaign';


--
-- Name: COLUMN campaigns.cost_per_send; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.cost_per_send IS 'Average cost per notification sent';


--
-- Name: COLUMN campaigns.sends_count; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.sends_count IS 'Total number of notifications sent';


--
-- Name: COLUMN campaigns.opens_count; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.opens_count IS 'Total number of opens/views tracked';


--
-- Name: COLUMN campaigns.clicks_count; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.clicks_count IS 'Total number of clicks tracked';


--
-- Name: COLUMN campaigns.conversions_count; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.conversions_count IS 'Total conversions attributed to campaign';


--
-- Name: COLUMN campaigns.revenue_generated; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.revenue_generated IS 'Total revenue attributed to campaign';


--
-- Name: COLUMN campaigns.suppression_list_ids; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.suppression_list_ids IS 'IDs of suppression lists to exclude recipients';


--
-- Name: COLUMN campaigns.excluded_count; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.excluded_count IS 'Number of recipients excluded by suppression';


--
-- Name: COLUMN campaigns.requires_approval; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.requires_approval IS 'Whether campaign must be approved before sending';


--
-- Name: COLUMN campaigns.approved_by; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.approved_by IS 'User who approved the campaign';


--
-- Name: COLUMN campaigns.approved_at; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.approved_at IS 'Timestamp of approval';


--
-- Name: COLUMN campaigns.tags; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.tags IS 'Tags for categorizing and filtering campaigns';


--
-- Name: COLUMN campaigns.metadata; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.metadata IS 'Additional flexible data specific to campaign';


--
-- Name: COLUMN campaigns.created_by; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.campaigns.created_by IS 'User who created the campaign';


--
-- Name: active_campaigns; Type: VIEW; Schema: notifications; Owner: postgres
--

CREATE VIEW notifications.active_campaigns AS
 SELECT c.id,
    c.tenant_id,
    c.name,
    c.slug,
    c.description,
    c.type,
    c.status,
    c.audience_segment_ids,
    c.audience_count,
    c.audience_criteria,
    c.scheduled_at,
    c.started_at,
    c.completed_at,
    c.template_id,
    c.subject_line,
    c.preview_text,
    c.is_ab_test,
    c.variants,
    c.winning_variant_id,
    c.goal_type,
    c.goal_target,
    c.goal_achieved,
    c.budget_amount,
    c.spent_amount,
    c.cost_per_send,
    c.sends_count,
    c.opens_count,
    c.clicks_count,
    c.conversions_count,
    c.revenue_generated,
    c.suppression_list_ids,
    c.excluded_count,
    c.requires_approval,
    c.approved_by,
    c.approved_at,
    c.tags,
    c.metadata,
    c.created_at,
    c.updated_at,
    c.created_by,
        CASE
            WHEN (c.sends_count > 0) THEN round((((c.opens_count)::numeric / (c.sends_count)::numeric) * (100)::numeric), 2)
            ELSE (0)::numeric
        END AS open_rate,
        CASE
            WHEN (c.opens_count > 0) THEN round((((c.clicks_count)::numeric / (c.opens_count)::numeric) * (100)::numeric), 2)
            ELSE (0)::numeric
        END AS click_rate,
        CASE
            WHEN (c.budget_amount > (0)::numeric) THEN round(((c.spent_amount / c.budget_amount) * (100)::numeric), 2)
            ELSE (0)::numeric
        END AS budget_used_percentage
   FROM notifications.campaigns c
  WHERE ((c.status)::text = ANY (ARRAY[('scheduled'::character varying)::text, ('active'::character varying)::text]))
  ORDER BY c.scheduled_at;



--
-- Name: VIEW active_campaigns; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON VIEW notifications.active_campaigns IS 'View of currently active and scheduled campaigns with calculated metrics';


--
-- Name: notification_preferences; Type: TABLE; Schema: notifications; Owner: postgres
--

CREATE TABLE notifications.notification_preferences (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    customer_profile_id uuid NOT NULL,
    all_notifications_enabled boolean DEFAULT true,
    pause_until timestamp with time zone,
    email_enabled boolean DEFAULT true,
    sms_enabled boolean DEFAULT false,
    push_enabled boolean DEFAULT true,
    in_app_enabled boolean DEFAULT true,
    marketing_enabled boolean DEFAULT true,
    transactional_enabled boolean DEFAULT true,
    reminders_enabled boolean DEFAULT true,
    price_drops boolean DEFAULT true,
    new_events boolean DEFAULT true,
    artist_updates boolean DEFAULT true,
    venue_updates boolean DEFAULT true,
    max_emails_per_day integer DEFAULT 10,
    max_sms_per_week integer DEFAULT 5,
    quiet_hours_enabled boolean DEFAULT false,
    quiet_start time without time zone DEFAULT '22:00:00'::time without time zone,
    quiet_end time without time zone DEFAULT '08:00:00'::time without time zone,
    timezone character varying(50) DEFAULT 'America/New_York'::character varying,
    unsubscribed_all boolean DEFAULT false,
    unsubscribe_token character varying(255),
    sms_country_code character varying(5) DEFAULT '+1'::character varying,
    push_sound_enabled boolean DEFAULT true,
    notification_language character varying(10) DEFAULT 'en'::character varying,
    batch_notifications boolean DEFAULT false,
    instant_notifications boolean DEFAULT true,
    last_email_open timestamp with time zone,
    last_sms_click timestamp with time zone,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    last_modified_by uuid,
    CONSTRAINT chk_delivery_preference CHECK ((NOT ((batch_notifications = true) AND (instant_notifications = true)))),
    CONSTRAINT chk_max_emails_per_day CHECK (((max_emails_per_day >= 0) AND (max_emails_per_day <= 100))),
    CONSTRAINT chk_max_sms_per_week CHECK (((max_sms_per_week >= 0) AND (max_sms_per_week <= 50))),
    CONSTRAINT chk_notification_language CHECK (((notification_language)::text ~ '^[a-z]{2}(-[A-Z]{2})?$'::text)),
    CONSTRAINT chk_quiet_hours CHECK (((quiet_hours_enabled = false) OR ((quiet_hours_enabled = true) AND (quiet_start IS NOT NULL) AND (quiet_end IS NOT NULL)))),
    CONSTRAINT chk_sms_country_code CHECK (((sms_country_code)::text ~ '^\+[0-9]{1,4}$'::text)),
    CONSTRAINT chk_timezone CHECK (((timezone)::text = ANY (ARRAY[('UTC'::character varying)::text, ('America/New_York'::character varying)::text, ('America/Chicago'::character varying)::text, ('America/Denver'::character varying)::text, ('America/Los_Angeles'::character varying)::text, ('America/Phoenix'::character varying)::text, ('America/Anchorage'::character varying)::text, ('Pacific/Honolulu'::character varying)::text, ('Europe/London'::character varying)::text, ('Europe/Paris'::character varying)::text, ('Europe/Berlin'::character varying)::text, ('Asia/Tokyo'::character varying)::text, ('Asia/Shanghai'::character varying)::text, ('Australia/Sydney'::character varying)::text, ('America/Toronto'::character varying)::text, ('America/Mexico_City'::character varying)::text, ('America/Sao_Paulo'::character varying)::text, ('Asia/Dubai'::character varying)::text, ('Asia/Singapore'::character varying)::text, ('Pacific/Auckland'::character varying)::text])))
);



--
-- Name: TABLE notification_preferences; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON TABLE notifications.notification_preferences IS 'Customer preferences for notification delivery and content';


--
-- Name: COLUMN notification_preferences.id; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.id IS 'Unique identifier for preference record';


--
-- Name: COLUMN notification_preferences.customer_profile_id; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.customer_profile_id IS 'Reference to customer who owns these preferences';


--
-- Name: COLUMN notification_preferences.all_notifications_enabled; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.all_notifications_enabled IS 'Master switch to enable/disable all notifications';


--
-- Name: COLUMN notification_preferences.pause_until; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.pause_until IS 'Temporarily pause notifications until this timestamp';


--
-- Name: COLUMN notification_preferences.email_enabled; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.email_enabled IS 'Whether customer accepts email notifications';


--
-- Name: COLUMN notification_preferences.sms_enabled; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.sms_enabled IS 'Whether customer accepts SMS notifications (requires opt-in)';


--
-- Name: COLUMN notification_preferences.push_enabled; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.push_enabled IS 'Whether customer accepts push notifications';


--
-- Name: COLUMN notification_preferences.in_app_enabled; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.in_app_enabled IS 'Whether customer accepts in-app notifications';


--
-- Name: COLUMN notification_preferences.marketing_enabled; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.marketing_enabled IS 'Receive marketing and promotional notifications';


--
-- Name: COLUMN notification_preferences.transactional_enabled; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.transactional_enabled IS 'Receive transactional notifications (orders, confirmations)';


--
-- Name: COLUMN notification_preferences.reminders_enabled; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.reminders_enabled IS 'Receive reminder notifications (events, abandoned carts)';


--
-- Name: COLUMN notification_preferences.price_drops; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.price_drops IS 'Notify when tracked ticket prices decrease';


--
-- Name: COLUMN notification_preferences.new_events; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.new_events IS 'Notify about new events from followed artists/venues';


--
-- Name: COLUMN notification_preferences.artist_updates; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.artist_updates IS 'Receive updates from followed artists';


--
-- Name: COLUMN notification_preferences.venue_updates; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.venue_updates IS 'Receive updates from followed venues';


--
-- Name: COLUMN notification_preferences.max_emails_per_day; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.max_emails_per_day IS 'Maximum number of emails to send per day';


--
-- Name: COLUMN notification_preferences.max_sms_per_week; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.max_sms_per_week IS 'Maximum number of SMS messages to send per week';


--
-- Name: COLUMN notification_preferences.quiet_hours_enabled; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.quiet_hours_enabled IS 'Whether to respect quiet hours for non-urgent notifications';


--
-- Name: COLUMN notification_preferences.quiet_start; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.quiet_start IS 'Start time for quiet hours in customer timezone';


--
-- Name: COLUMN notification_preferences.quiet_end; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.quiet_end IS 'End time for quiet hours in customer timezone';


--
-- Name: COLUMN notification_preferences.timezone; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.timezone IS 'Customer timezone for calculating quiet hours';


--
-- Name: COLUMN notification_preferences.unsubscribed_all; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.unsubscribed_all IS 'Customer has unsubscribed from all communications';


--
-- Name: COLUMN notification_preferences.unsubscribe_token; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.unsubscribe_token IS 'Unique token for one-click unsubscribe links';


--
-- Name: COLUMN notification_preferences.sms_country_code; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.sms_country_code IS 'Country code for SMS delivery';


--
-- Name: COLUMN notification_preferences.push_sound_enabled; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.push_sound_enabled IS 'Whether push notifications should play sound';


--
-- Name: COLUMN notification_preferences.notification_language; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.notification_language IS 'Preferred language for notification content (ISO 639-1)';


--
-- Name: COLUMN notification_preferences.batch_notifications; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.batch_notifications IS 'Batch similar notifications together for digest delivery';


--
-- Name: COLUMN notification_preferences.instant_notifications; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.instant_notifications IS 'Send notifications immediately as they occur';


--
-- Name: COLUMN notification_preferences.last_email_open; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.last_email_open IS 'Timestamp of last email open for engagement tracking';


--
-- Name: COLUMN notification_preferences.last_sms_click; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.last_sms_click IS 'Timestamp of last SMS link click for engagement tracking';


--
-- Name: COLUMN notification_preferences.last_modified_by; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_preferences.last_modified_by IS 'User or system that last updated these preferences';


--
-- Name: active_notification_preferences; Type: VIEW; Schema: notifications; Owner: postgres
--

CREATE VIEW notifications.active_notification_preferences AS
 SELECT np.id,
    np.tenant_id,
    np.customer_profile_id,
    np.all_notifications_enabled,
    np.pause_until,
    np.email_enabled,
    np.sms_enabled,
    np.push_enabled,
    np.in_app_enabled,
    np.marketing_enabled,
    np.transactional_enabled,
    np.reminders_enabled,
    np.price_drops,
    np.new_events,
    np.artist_updates,
    np.venue_updates,
    np.max_emails_per_day,
    np.max_sms_per_week,
    np.quiet_hours_enabled,
    np.quiet_start,
    np.quiet_end,
    np.timezone,
    np.unsubscribed_all,
    np.unsubscribe_token,
    np.sms_country_code,
    np.push_sound_enabled,
    np.notification_language,
    np.batch_notifications,
    np.instant_notifications,
    np.last_email_open,
    np.last_sms_click,
    np.created_at,
    np.updated_at,
    np.last_modified_by,
        CASE
            WHEN ((np.pause_until IS NOT NULL) AND (np.pause_until > CURRENT_TIMESTAMP)) THEN true
            ELSE false
        END AS currently_paused,
        CASE
            WHEN (np.quiet_hours_enabled AND (((CURRENT_TIME AT TIME ZONE np.timezone) >= (np.quiet_start)::time with time zone) AND ((CURRENT_TIME AT TIME ZONE np.timezone) <= (np.quiet_end)::time with time zone))) THEN true
            ELSE false
        END AS in_quiet_hours
   FROM notifications.notification_preferences np
  WHERE ((np.all_notifications_enabled = true) AND (np.unsubscribed_all = false));



--
-- Name: VIEW active_notification_preferences; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON VIEW notifications.active_notification_preferences IS 'View of active notification preferences with computed pause and quiet hour status';


--
-- Name: delivery_tracking; Type: TABLE; Schema: notifications; Owner: postgres
--

CREATE TABLE notifications.delivery_tracking (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    notification_history_id uuid NOT NULL,
    campaign_id uuid,
    provider_name character varying(50) NOT NULL,
    provider_account character varying(100),
    message_id character varying(255) NOT NULL,
    batch_id character varying(255),
    queued_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    sent_to_provider_at timestamp with time zone,
    accepted_at timestamp with time zone,
    delivered_at timestamp with time zone,
    status character varying(50) DEFAULT 'queued'::character varying NOT NULL,
    provider_events jsonb DEFAULT '[]'::jsonb,
    bounce_type character varying(20),
    bounce_subtype character varying(50),
    failure_reason text,
    is_retryable boolean DEFAULT true,
    retry_after timestamp with time zone,
    smtp_response text,
    spam_score numeric(4,2),
    spam_report jsonb,
    carrier character varying(100),
    segment_count integer DEFAULT 1,
    encoding character varying(20),
    platform character varying(20),
    device_type character varying(50),
    app_version character varying(20),
    sender_ip inet,
    recipient_ip inet,
    recipient_country character varying(2),
    provider_credits_used integer DEFAULT 0,
    actual_cost numeric(10,4) DEFAULT 0,
    webhook_received_at timestamp with time zone,
    webhook_data jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_actual_cost CHECK ((actual_cost >= (0)::numeric)),
    CONSTRAINT chk_bounce_type CHECK (((bounce_type IS NULL) OR ((bounce_type)::text = ANY (ARRAY[('soft'::character varying)::text, ('hard'::character varying)::text, ('block'::character varying)::text])))),
    CONSTRAINT chk_platform CHECK (((platform IS NULL) OR ((platform)::text = ANY (ARRAY[('ios'::character varying)::text, ('android'::character varying)::text, ('web'::character varying)::text, ('sms'::character varying)::text, ('email'::character varying)::text])))),
    CONSTRAINT chk_provider_credits CHECK ((provider_credits_used >= 0)),
    CONSTRAINT chk_segment_count CHECK ((segment_count >= 1)),
    CONSTRAINT chk_spam_score CHECK (((spam_score IS NULL) OR ((spam_score >= (0)::numeric) AND (spam_score <= (10)::numeric)))),
    CONSTRAINT chk_status CHECK (((status)::text = ANY (ARRAY[('queued'::character varying)::text, ('sending'::character varying)::text, ('sent'::character varying)::text, ('delivered'::character varying)::text, ('failed'::character varying)::text, ('bounced'::character varying)::text])))
);



--
-- Name: TABLE delivery_tracking; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON TABLE notifications.delivery_tracking IS 'Detailed tracking of notification delivery through external providers';


--
-- Name: COLUMN delivery_tracking.id; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.id IS 'Unique identifier for delivery tracking record';


--
-- Name: COLUMN delivery_tracking.notification_history_id; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.notification_history_id IS 'Reference to the notification being tracked';


--
-- Name: COLUMN delivery_tracking.campaign_id; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.campaign_id IS 'Optional reference to campaign if part of one';


--
-- Name: COLUMN delivery_tracking.provider_name; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.provider_name IS 'External provider used (SendGrid, Twilio, FCM, etc.)';


--
-- Name: COLUMN delivery_tracking.provider_account; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.provider_account IS 'Specific account or subaccount identifier';


--
-- Name: COLUMN delivery_tracking.message_id; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.message_id IS 'Our unique message identifier for tracking';


--
-- Name: COLUMN delivery_tracking.batch_id; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.batch_id IS 'Batch identifier for grouped sends';


--
-- Name: COLUMN delivery_tracking.queued_at; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.queued_at IS 'When notification was queued for delivery';


--
-- Name: COLUMN delivery_tracking.sent_to_provider_at; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.sent_to_provider_at IS 'When we sent to external provider';


--
-- Name: COLUMN delivery_tracking.accepted_at; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.accepted_at IS 'When provider accepted the message';


--
-- Name: COLUMN delivery_tracking.delivered_at; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.delivered_at IS 'When final delivery was confirmed';


--
-- Name: COLUMN delivery_tracking.status; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.status IS 'Current delivery status';


--
-- Name: COLUMN delivery_tracking.provider_events; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.provider_events IS 'Array of all webhook events from provider';


--
-- Name: COLUMN delivery_tracking.bounce_type; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.bounce_type IS 'Type of bounce: soft (temporary), hard (permanent), block';


--
-- Name: COLUMN delivery_tracking.bounce_subtype; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.bounce_subtype IS 'Specific bounce reason from provider';


--
-- Name: COLUMN delivery_tracking.failure_reason; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.failure_reason IS 'Detailed explanation of delivery failure';


--
-- Name: COLUMN delivery_tracking.is_retryable; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.is_retryable IS 'Whether this failure can be retried';


--
-- Name: COLUMN delivery_tracking.retry_after; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.retry_after IS 'Earliest time to retry delivery';


--
-- Name: COLUMN delivery_tracking.smtp_response; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.smtp_response IS 'SMTP server response for email';


--
-- Name: COLUMN delivery_tracking.spam_score; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.spam_score IS 'Spam score from provider (0-10)';


--
-- Name: COLUMN delivery_tracking.spam_report; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.spam_report IS 'Detailed spam analysis from provider';


--
-- Name: COLUMN delivery_tracking.carrier; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.carrier IS 'Mobile carrier for SMS delivery';


--
-- Name: COLUMN delivery_tracking.segment_count; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.segment_count IS 'Number of SMS segments sent';


--
-- Name: COLUMN delivery_tracking.encoding; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.encoding IS 'Character encoding used for SMS';


--
-- Name: COLUMN delivery_tracking.platform; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.platform IS 'Platform for push notifications';


--
-- Name: COLUMN delivery_tracking.device_type; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.device_type IS 'Specific device model';


--
-- Name: COLUMN delivery_tracking.app_version; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.app_version IS 'App version for compatibility tracking';


--
-- Name: COLUMN delivery_tracking.sender_ip; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.sender_ip IS 'IP address message was sent from';


--
-- Name: COLUMN delivery_tracking.recipient_ip; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.recipient_ip IS 'Recipient IP if available';


--
-- Name: COLUMN delivery_tracking.recipient_country; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.recipient_country IS 'Recipient country from IP or provider';


--
-- Name: COLUMN delivery_tracking.provider_credits_used; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.provider_credits_used IS 'Provider-specific credits consumed';


--
-- Name: COLUMN delivery_tracking.actual_cost; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.actual_cost IS 'Monetary cost of delivery';


--
-- Name: COLUMN delivery_tracking.webhook_received_at; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.webhook_received_at IS 'When delivery webhook was received';


--
-- Name: COLUMN delivery_tracking.webhook_data; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.delivery_tracking.webhook_data IS 'Raw webhook payload for debugging';


--
-- Name: delivery_metrics; Type: VIEW; Schema: notifications; Owner: postgres
--

CREATE VIEW notifications.delivery_metrics AS
 SELECT dt.provider_name,
    dt.status,
    count(*) AS count,
    avg(EXTRACT(epoch FROM (dt.delivered_at - dt.queued_at))) AS avg_delivery_time_seconds,
    sum(dt.actual_cost) AS total_cost,
    sum(dt.provider_credits_used) AS total_credits,
    count(*) FILTER (WHERE (dt.bounce_type IS NOT NULL)) AS bounce_count,
    count(*) FILTER (WHERE ((dt.bounce_type)::text = 'hard'::text)) AS hard_bounce_count,
    count(*) FILTER (WHERE (dt.spam_score > (5)::numeric)) AS high_spam_count
   FROM notifications.delivery_tracking dt
  WHERE (dt.created_at >= (CURRENT_DATE - '30 days'::interval))
  GROUP BY dt.provider_name, dt.status;



--
-- Name: VIEW delivery_metrics; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON VIEW notifications.delivery_metrics IS 'Aggregated delivery metrics by provider and status for the last 30 days';


--
-- Name: notification_history; Type: TABLE; Schema: notifications; Owner: postgres
--

CREATE TABLE notifications.notification_history (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    customer_profile_id uuid NOT NULL,
    template_id uuid,
    campaign_id uuid,
    channel character varying(50) NOT NULL,
    subject character varying(500),
    preview_text character varying(200),
    recipient_email character varying(255),
    recipient_phone character varying(50),
    device_token character varying(500),
    rendered_content text,
    variables_used jsonb DEFAULT '{}'::jsonb,
    status character varying(50) DEFAULT 'pending'::character varying NOT NULL,
    queued_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    sent_at timestamp with time zone,
    delivered_at timestamp with time zone,
    failed_at timestamp with time zone,
    provider character varying(100),
    provider_message_id character varying(255),
    provider_response jsonb DEFAULT '{}'::jsonb,
    opened_at timestamp with time zone,
    clicked_at timestamp with time zone,
    click_count integer DEFAULT 0,
    bounce_type character varying(50),
    bounce_reason text,
    is_permanent_failure boolean DEFAULT false,
    provider_cost numeric(10,4) DEFAULT 0,
    credits_used integer DEFAULT 0,
    retry_count integer DEFAULT 0,
    next_retry_at timestamp with time zone,
    tags text[] DEFAULT '{}'::text[],
    context jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_bounce_type CHECK (((bounce_type IS NULL) OR ((bounce_type)::text = ANY (ARRAY[('hard'::character varying)::text, ('soft'::character varying)::text, ('blocked'::character varying)::text, ('complaint'::character varying)::text, ('other'::character varying)::text])))),
    CONSTRAINT chk_channel CHECK (((channel)::text = ANY (ARRAY[('email'::character varying)::text, ('sms'::character varying)::text, ('push'::character varying)::text, ('in_app'::character varying)::text, ('webhook'::character varying)::text]))),
    CONSTRAINT chk_click_count CHECK ((click_count >= 0)),
    CONSTRAINT chk_credits_used CHECK ((credits_used >= 0)),
    CONSTRAINT chk_provider_cost CHECK ((provider_cost >= (0)::numeric)),
    CONSTRAINT chk_retry_count CHECK ((retry_count >= 0)),
    CONSTRAINT chk_status CHECK (((status)::text = ANY (ARRAY[('pending'::character varying)::text, ('sent'::character varying)::text, ('delivered'::character varying)::text, ('failed'::character varying)::text, ('bounced'::character varying)::text])))
);



--
-- Name: TABLE notification_history; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON TABLE notifications.notification_history IS 'Complete history of all notifications sent through the system';


--
-- Name: COLUMN notification_history.id; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.id IS 'Unique identifier for each notification record';


--
-- Name: COLUMN notification_history.customer_profile_id; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.customer_profile_id IS 'Reference to the customer who received this notification';


--
-- Name: COLUMN notification_history.template_id; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.template_id IS 'Reference to the template used (nullable for custom notifications)';


--
-- Name: COLUMN notification_history.campaign_id; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.campaign_id IS 'Reference to campaign if this notification is part of a campaign';


--
-- Name: COLUMN notification_history.channel; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.channel IS 'Communication channel used: email, sms, push, in_app, webhook';


--
-- Name: COLUMN notification_history.subject; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.subject IS 'Subject line for emails or title for other notification types';


--
-- Name: COLUMN notification_history.preview_text; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.preview_text IS 'Preview text shown in email clients or notification centers';


--
-- Name: COLUMN notification_history.recipient_email; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.recipient_email IS 'Email address for email notifications';


--
-- Name: COLUMN notification_history.recipient_phone; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.recipient_phone IS 'Phone number for SMS notifications';


--
-- Name: COLUMN notification_history.device_token; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.device_token IS 'Device token for push notifications';


--
-- Name: COLUMN notification_history.rendered_content; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.rendered_content IS 'Final HTML/text content that was sent';


--
-- Name: COLUMN notification_history.variables_used; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.variables_used IS 'Template variables and their values used for rendering';


--
-- Name: COLUMN notification_history.status; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.status IS 'Current delivery status: pending, sent, delivered, failed, bounced';


--
-- Name: COLUMN notification_history.queued_at; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.queued_at IS 'Timestamp when notification was queued for sending';


--
-- Name: COLUMN notification_history.sent_at; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.sent_at IS 'Timestamp when notification was sent to provider';


--
-- Name: COLUMN notification_history.delivered_at; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.delivered_at IS 'Timestamp when provider confirmed delivery';


--
-- Name: COLUMN notification_history.failed_at; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.failed_at IS 'Timestamp when notification failed';


--
-- Name: COLUMN notification_history.provider; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.provider IS 'External provider used (SendGrid, Twilio, Firebase, etc.)';


--
-- Name: COLUMN notification_history.provider_message_id; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.provider_message_id IS 'Unique message ID from the provider';


--
-- Name: COLUMN notification_history.provider_response; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.provider_response IS 'Complete response data from provider';


--
-- Name: COLUMN notification_history.opened_at; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.opened_at IS 'Timestamp when recipient opened the notification';


--
-- Name: COLUMN notification_history.clicked_at; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.clicked_at IS 'Timestamp of first click on any link';


--
-- Name: COLUMN notification_history.click_count; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.click_count IS 'Total number of clicks on links';


--
-- Name: COLUMN notification_history.bounce_type; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.bounce_type IS 'Type of bounce: hard, soft, blocked, complaint';


--
-- Name: COLUMN notification_history.bounce_reason; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.bounce_reason IS 'Detailed explanation of bounce or failure';


--
-- Name: COLUMN notification_history.is_permanent_failure; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.is_permanent_failure IS 'Whether this recipient should be blacklisted';


--
-- Name: COLUMN notification_history.provider_cost; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.provider_cost IS 'Cost in dollars charged by the provider';


--
-- Name: COLUMN notification_history.credits_used; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.credits_used IS 'Internal credits consumed for this notification';


--
-- Name: COLUMN notification_history.retry_count; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.retry_count IS 'Number of times this notification has been retried';


--
-- Name: COLUMN notification_history.next_retry_at; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.next_retry_at IS 'Scheduled time for next retry attempt';


--
-- Name: COLUMN notification_history.tags; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.tags IS 'Array of tags for filtering and categorization';


--
-- Name: COLUMN notification_history.context; Type: COMMENT; Schema: notifications; Owner: postgres
--

COMMENT ON COLUMN notifications.notification_history.context IS 'Additional context data (order ID, event type, etc.)';


--
-- Name: agreements; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.agreements (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    agreement_type character varying(100),
    parties jsonb,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: alerts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.alerts (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    alert_name character varying(255),
    alert_type character varying(100),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: aml_checks; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.aml_checks (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    user_id uuid,
    status character varying(50),
    risk_score integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: analytics_events; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.analytics_events (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    event_name character varying(255),
    event_data jsonb,
    user_id uuid,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: analytics_jobs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.analytics_jobs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    job_type character varying(100) NOT NULL,
    status character varying(50) DEFAULT 'pending'::character varying,
    started_at timestamp without time zone,
    completed_at timestamp without time zone,
    result jsonb,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: api_credentials; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.api_credentials (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    api_key_id uuid,
    secret_hash character varying(255),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: api_keys; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.api_keys (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    user_id uuid,
    key_hash character varying(255),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: audit_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.audit_log (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    action character varying(255),
    user_id uuid,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: audit_log_alerts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.audit_log_alerts (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    alert_name character varying(200) NOT NULL,
    alert_description text,
    category_filter public.audit_category[],
    severity_filter public.audit_severity[],
    entity_type_filter character varying(100)[],
    action_filter public.audit_action[],
    threshold_count integer,
    threshold_period interval,
    risk_score_threshold integer,
    conditions jsonb,
    is_active boolean DEFAULT true NOT NULL,
    notification_channels text[],
    escalation_rules jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by_user_id uuid,
    last_triggered_at timestamp with time zone,
    trigger_count integer DEFAULT 0 NOT NULL,
    CONSTRAINT audit_alerts_valid_risk_threshold CHECK (((risk_score_threshold IS NULL) OR ((risk_score_threshold >= 0) AND (risk_score_threshold <= 100)))),
    CONSTRAINT audit_alerts_valid_threshold CHECK (((threshold_count IS NULL) OR (threshold_count > 0)))
);



--
-- Name: TABLE audit_log_alerts; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.audit_log_alerts IS 'Alert rules and notifications for suspicious audit events';


--
-- Name: audit_log_entries; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.audit_log_entries (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    log_id uuid,
    entry_data jsonb,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: audit_log_summaries; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.audit_log_summaries (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    summary_date date NOT NULL,
    summary_type character varying(50) NOT NULL,
    authentication_events integer DEFAULT 0 NOT NULL,
    authorization_events integer DEFAULT 0 NOT NULL,
    data_modification_events integer DEFAULT 0 NOT NULL,
    financial_events integer DEFAULT 0 NOT NULL,
    security_events integer DEFAULT 0 NOT NULL,
    system_events integer DEFAULT 0 NOT NULL,
    privacy_events integer DEFAULT 0 NOT NULL,
    compliance_events integer DEFAULT 0 NOT NULL,
    info_events integer DEFAULT 0 NOT NULL,
    warning_events integer DEFAULT 0 NOT NULL,
    error_events integer DEFAULT 0 NOT NULL,
    critical_events integer DEFAULT 0 NOT NULL,
    total_events integer DEFAULT 0 NOT NULL,
    unique_users integer DEFAULT 0 NOT NULL,
    unique_ip_addresses integer DEFAULT 0 NOT NULL,
    anomalous_events integer DEFAULT 0 NOT NULL,
    high_risk_events integer DEFAULT 0 NOT NULL,
    gdpr_relevant_events integer DEFAULT 0 NOT NULL,
    pci_relevant_events integer DEFAULT 0 NOT NULL,
    hipaa_relevant_events integer DEFAULT 0 NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);



--
-- Name: TABLE audit_log_summaries; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.audit_log_summaries IS 'Aggregated audit data for reporting and compliance analytics';


--
-- Name: audit_logs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.audit_logs (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    table_name character varying(50) NOT NULL,
    record_id uuid NOT NULL,
    action character varying(10) NOT NULL,
    old_data jsonb,
    new_data jsonb,
    changed_fields text[],
    user_id uuid,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: TABLE audit_logs; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.audit_logs IS 'Comprehensive audit trail system for compliance, security, and change tracking';


--
-- Name: COLUMN audit_logs.changed_fields; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.audit_logs.changed_fields IS 'Changed fields: array of field names that were modified';


--
-- Name: background_jobs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.background_jobs (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    job_type character varying(100),
    status character varying(50),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: blockchain_transactions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.blockchain_transactions (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    transaction_signature character varying(88) NOT NULL,
    type character varying(50) NOT NULL,
    status character varying(20) DEFAULT 'PENDING'::character varying NOT NULL,
    ticket_id uuid NOT NULL,
    from_wallet character varying(44),
    to_wallet character varying(44),
    slot_number bigint,
    block_time timestamp with time zone,
    fee_lamports bigint,
    error_message text,
    retry_count integer DEFAULT 0,
    metadata jsonb DEFAULT '{}'::jsonb,
    confirmations integer,
    finalized boolean DEFAULT false,
    program_id character varying(44),
    instruction_data text,
    priority_fee_lamports bigint,
    compute_units_used integer,
    associated_token_account character varying(44),
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_status CHECK (((status)::text = ANY (ARRAY[('PENDING'::character varying)::text, ('CONFIRMED'::character varying)::text, ('FAILED'::character varying)::text, ('EXPIRED'::character varying)::text]))),
    CONSTRAINT valid_transaction_type CHECK (((type)::text = ANY (ARRAY[('MINT_NFT'::character varying)::text, ('TRANSFER_NFT'::character varying)::text, ('BURN_NFT'::character varying)::text, ('LIST_NFT'::character varying)::text, ('DELIST_NFT'::character varying)::text, ('UPDATE_METADATA'::character varying)::text, ('FREEZE_NFT'::character varying)::text, ('THAW_NFT'::character varying)::text])))
);



--
-- Name: TABLE blockchain_transactions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.blockchain_transactions IS 'Tracks all Solana blockchain transactions related to ticket NFTs';


--
-- Name: COLUMN blockchain_transactions.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.blockchain_transactions.id IS 'Unique identifier for the transaction record';


--
-- Name: COLUMN blockchain_transactions.transaction_signature; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.blockchain_transactions.transaction_signature IS 'Solana transaction signature (base58 encoded, 88 characters)';


--
-- Name: COLUMN blockchain_transactions.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.blockchain_transactions.type IS 'Type of blockchain operation performed';


--
-- Name: COLUMN blockchain_transactions.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.blockchain_transactions.status IS 'Current status of the transaction';


--
-- Name: COLUMN blockchain_transactions.ticket_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.blockchain_transactions.ticket_id IS 'Reference to the ticket NFT involved in the transaction';


--
-- Name: COLUMN blockchain_transactions.from_wallet; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.blockchain_transactions.from_wallet IS 'Solana wallet address of the sender';


--
-- Name: COLUMN blockchain_transactions.to_wallet; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.blockchain_transactions.to_wallet IS 'Solana wallet address of the receiver';


--
-- Name: COLUMN blockchain_transactions.slot_number; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.blockchain_transactions.slot_number IS 'Solana slot number where transaction was included';


--
-- Name: COLUMN blockchain_transactions.block_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.blockchain_transactions.block_time IS 'Timestamp when the block containing this transaction was produced';


--
-- Name: COLUMN blockchain_transactions.fee_lamports; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.blockchain_transactions.fee_lamports IS 'Transaction fee paid in lamports';


--
-- Name: COLUMN blockchain_transactions.error_message; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.blockchain_transactions.error_message IS 'Error message if the transaction failed';


--
-- Name: COLUMN blockchain_transactions.retry_count; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.blockchain_transactions.retry_count IS 'Number of times this transaction has been retried';


--
-- Name: COLUMN blockchain_transactions.metadata; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.blockchain_transactions.metadata IS 'Additional transaction data in JSON format';


--
-- Name: COLUMN blockchain_transactions.confirmations; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.blockchain_transactions.confirmations IS 'Number of confirmations received for this transaction';


--
-- Name: COLUMN blockchain_transactions.finalized; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.blockchain_transactions.finalized IS 'Whether the transaction has reached finalized status on Solana';


--
-- Name: COLUMN blockchain_transactions.program_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.blockchain_transactions.program_id IS 'Solana program that processed this transaction';


--
-- Name: COLUMN blockchain_transactions.instruction_data; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.blockchain_transactions.instruction_data IS 'Base64 encoded instruction data sent to the program';


--
-- Name: COLUMN blockchain_transactions.priority_fee_lamports; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.blockchain_transactions.priority_fee_lamports IS 'Additional priority fee for faster processing';


--
-- Name: COLUMN blockchain_transactions.compute_units_used; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.blockchain_transactions.compute_units_used IS 'Compute units consumed by this transaction';


--
-- Name: COLUMN blockchain_transactions.associated_token_account; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.blockchain_transactions.associated_token_account IS 'Associated token account address if applicable';


--
-- Name: COLUMN blockchain_transactions.created_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.blockchain_transactions.created_at IS 'Timestamp when this record was created';


--
-- Name: COLUMN blockchain_transactions.updated_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.blockchain_transactions.updated_at IS 'Timestamp when this record was last updated';


--
-- Name: campaigns; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.campaigns (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    campaign_name character varying(255),
    status character varying(50),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: commissions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.commissions (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    amount numeric(10,2),
    user_id uuid,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: communications_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.communications_log (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    message_id character varying(255),
    recipient_email character varying(255) NOT NULL,
    message_type character varying(50) NOT NULL,
    subject text,
    sent_at timestamp without time zone,
    delivered_at timestamp without time zone,
    opened_at timestamp without time zone,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: compliance_inspections; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.compliance_inspections (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    venue_id uuid NOT NULL,
    compliance_id uuid,
    inspection_number character varying(100),
    inspection_type character varying(100) NOT NULL,
    inspection_purpose character varying(200),
    inspection_date date NOT NULL,
    scheduled_date date,
    inspection_time_start time without time zone,
    inspection_time_end time without time zone,
    duration_minutes integer,
    lead_inspector_name character varying(200) NOT NULL,
    inspector_badge_number character varying(100),
    inspection_team jsonb DEFAULT '[]'::jsonb,
    inspection_scope text,
    areas_inspected text[],
    inspection_checklist jsonb DEFAULT '{}'::jsonb,
    inspection_method character varying(100),
    overall_result character varying(50) NOT NULL,
    passed_items integer DEFAULT 0,
    failed_items integer DEFAULT 0,
    conditional_items integer DEFAULT 0,
    not_applicable_items integer DEFAULT 0,
    findings_summary text,
    positive_findings text,
    areas_for_improvement text,
    safety_concerns text,
    violations_found integer DEFAULT 0,
    critical_violations integer DEFAULT 0,
    violation_ids uuid[],
    corrective_actions_required text,
    corrective_action_deadline date,
    follow_up_inspection_required boolean DEFAULT false NOT NULL,
    follow_up_date date,
    inspection_report_url text,
    photos jsonb DEFAULT '[]'::jsonb,
    evidence_collected jsonb DEFAULT '[]'::jsonb,
    inspection_notes text,
    certificate_issued boolean DEFAULT false NOT NULL,
    certificate_number character varying(100),
    certificate_expiry_date date,
    conditional_approval boolean DEFAULT false NOT NULL,
    conditions_for_approval text,
    venue_representative character varying(200),
    venue_signature_collected boolean DEFAULT false NOT NULL,
    report_delivered_date date,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by_user_id uuid,
    CONSTRAINT compliance_inspections_valid_items CHECK (((passed_items >= 0) AND (failed_items >= 0) AND (conditional_items >= 0) AND (not_applicable_items >= 0))),
    CONSTRAINT compliance_inspections_valid_times CHECK (((inspection_time_end IS NULL) OR (inspection_time_start IS NULL) OR (inspection_time_end > inspection_time_start))),
    CONSTRAINT compliance_inspections_valid_violations CHECK (((violations_found >= 0) AND (critical_violations >= 0) AND (critical_violations <= violations_found)))
);



--
-- Name: TABLE compliance_inspections; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.compliance_inspections IS 'Compliance inspections and audit activities with detailed findings';


--
-- Name: COLUMN compliance_inspections.overall_result; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.compliance_inspections.overall_result IS 'Inspection outcome: pass, fail, conditional pass, or requires follow-up';


--
-- Name: COLUMN compliance_inspections.violations_found; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.compliance_inspections.violations_found IS 'Violations count: number of violations identified during inspection';


--
-- Name: COLUMN compliance_inspections.follow_up_inspection_required; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.compliance_inspections.follow_up_inspection_required IS 'Follow-up required: whether additional inspection is needed';


--
-- Name: compliance_reminders; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.compliance_reminders (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    compliance_id uuid NOT NULL,
    venue_id uuid NOT NULL,
    reminder_type character varying(100) NOT NULL,
    reminder_title character varying(200) NOT NULL,
    reminder_message text NOT NULL,
    reminder_date date NOT NULL,
    days_before_expiry integer NOT NULL,
    is_urgent boolean DEFAULT false NOT NULL,
    is_sent boolean DEFAULT false NOT NULL,
    sent_at timestamp with time zone,
    delivery_method character varying(50),
    recipient_emails text[],
    recipient_phones text[],
    recipient_users uuid[],
    acknowledged boolean DEFAULT false NOT NULL,
    acknowledged_by_user_id uuid,
    acknowledged_at timestamp with time zone,
    action_taken text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT compliance_reminders_valid_days CHECK ((days_before_expiry >= 0))
);



--
-- Name: TABLE compliance_reminders; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.compliance_reminders IS 'Automated reminder system for compliance renewals and deadlines';


--
-- Name: compliance_violations; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.compliance_violations (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    venue_id uuid NOT NULL,
    compliance_id uuid,
    violation_number character varying(100),
    violation_type character varying(100) NOT NULL,
    violation_title character varying(300) NOT NULL,
    violation_description text NOT NULL,
    severity public.violation_severity NOT NULL,
    violation_status public.violation_status DEFAULT 'open'::public.violation_status NOT NULL,
    regulatory_code character varying(100),
    issuing_authority character varying(200) NOT NULL,
    inspector_name character varying(200),
    inspection_date date NOT NULL,
    discovery_method character varying(100),
    violation_date date NOT NULL,
    citation_date date,
    location_details text,
    photographic_evidence jsonb DEFAULT '[]'::jsonb,
    fine_amount numeric(10,2),
    penalty_amount numeric(10,2),
    remediation_cost numeric(10,2),
    lost_revenue numeric(10,2),
    required_actions text NOT NULL,
    remediation_deadline date,
    remediation_plan text,
    remediation_status character varying(50) DEFAULT 'not_started'::character varying,
    resolution_date date,
    resolution_method character varying(100),
    resolution_evidence jsonb DEFAULT '[]'::jsonb,
    resolved_by_user_id uuid,
    follow_up_required boolean DEFAULT true NOT NULL,
    follow_up_date date,
    verification_inspector character varying(200),
    verification_date date,
    appeal_filed boolean DEFAULT false NOT NULL,
    appeal_date date,
    appeal_status character varying(50),
    appeal_outcome character varying(100),
    appeal_notes text,
    correspondence_log jsonb DEFAULT '[]'::jsonb,
    next_communication_date date,
    operational_impact character varying(100),
    public_safety_risk boolean DEFAULT false NOT NULL,
    media_exposure_risk character varying(20) DEFAULT 'low'::character varying,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by_user_id uuid,
    CONSTRAINT compliance_violations_valid_amounts CHECK ((((fine_amount IS NULL) OR (fine_amount >= (0)::numeric)) AND ((penalty_amount IS NULL) OR (penalty_amount >= (0)::numeric)) AND ((remediation_cost IS NULL) OR (remediation_cost >= (0)::numeric)) AND ((lost_revenue IS NULL) OR (lost_revenue >= (0)::numeric)))),
    CONSTRAINT compliance_violations_valid_dates CHECK (((violation_date <= COALESCE(citation_date, violation_date)) AND ((resolution_date IS NULL) OR (resolution_date >= violation_date)) AND ((remediation_deadline IS NULL) OR (remediation_deadline >= violation_date))))
);



--
-- Name: TABLE compliance_violations; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.compliance_violations IS 'Compliance violations tracking with remediation and resolution management';


--
-- Name: COLUMN compliance_violations.severity; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.compliance_violations.severity IS 'Violation severity: impact level requiring different response urgency';


--
-- Name: COLUMN compliance_violations.required_actions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.compliance_violations.required_actions IS 'Remediation requirements: specific actions needed to resolve violation';


--
-- Name: COLUMN compliance_violations.remediation_deadline; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.compliance_violations.remediation_deadline IS 'Compliance deadline: date by which violation must be resolved';


--
-- Name: COLUMN compliance_violations.appeal_filed; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.compliance_violations.appeal_filed IS 'Appeal status: whether violation is being disputed through official channels';


--
-- Name: critical_jobs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.critical_jobs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    job_type character varying(100) NOT NULL,
    payload jsonb NOT NULL,
    status character varying(50) DEFAULT 'pending'::character varying,
    priority integer DEFAULT 0,
    scheduled_at timestamp without time zone,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: customer_analytics; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.customer_analytics (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    user_id uuid,
    metric_name character varying(100),
    metric_value numeric,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: customer_feedback; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.customer_feedback (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    customer_profile_id uuid NOT NULL,
    event_id uuid,
    venue_id uuid,
    order_id uuid,
    type character varying(30) NOT NULL,
    overall_rating integer,
    venue_rating integer,
    event_rating integer,
    platform_rating integer,
    title character varying(200),
    comment text,
    suggestions text,
    sound_quality integer,
    seating_comfort integer,
    venue_cleanliness integer,
    staff_friendliness integer,
    value_for_money integer,
    status character varying(20) DEFAULT 'pending'::character varying,
    moderation_status character varying(20) DEFAULT 'pending'::character varying,
    venue_response text,
    venue_responded_at timestamp with time zone,
    response_helpful_count integer DEFAULT 0,
    is_verified_purchase boolean DEFAULT false,
    purchase_verified_at timestamp with time zone,
    helpful_count integer DEFAULT 0,
    not_helpful_count integer DEFAULT 0,
    reported_count integer DEFAULT 0,
    is_featured boolean DEFAULT false,
    display_order integer,
    is_anonymous boolean DEFAULT false,
    display_name character varying(100),
    photo_urls text[] DEFAULT '{}'::text[],
    has_photos boolean DEFAULT false,
    device_type character varying(50),
    app_version character varying(20),
    survey_id uuid,
    tags text[] DEFAULT '{}'::text[],
    sentiment_score numeric(3,2),
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    moderated_at timestamp with time zone,
    moderated_by uuid,
    CONSTRAINT chk_feedback_reference CHECK (((((type)::text = 'event_review'::text) AND (event_id IS NOT NULL)) OR (((type)::text = 'venue_review'::text) AND (venue_id IS NOT NULL)) OR ((type)::text = ANY (ARRAY[('platform_feedback'::character varying)::text, ('support_ticket'::character varying)::text])))),
    CONSTRAINT chk_feedback_type CHECK (((type)::text = ANY (ARRAY[('event_review'::character varying)::text, ('venue_review'::character varying)::text, ('platform_feedback'::character varying)::text, ('support_ticket'::character varying)::text]))),
    CONSTRAINT chk_helpful_counts CHECK (((helpful_count >= 0) AND (not_helpful_count >= 0) AND (reported_count >= 0))),
    CONSTRAINT chk_moderation_status CHECK (((moderation_status)::text = ANY (ARRAY[('pending'::character varying)::text, ('approved'::character varying)::text, ('rejected'::character varying)::text, ('requires_review'::character varying)::text]))),
    CONSTRAINT chk_status CHECK (((status)::text = ANY (ARRAY[('pending'::character varying)::text, ('published'::character varying)::text, ('hidden'::character varying)::text, ('flagged'::character varying)::text]))),
    CONSTRAINT customer_feedback_event_rating_check CHECK (((event_rating >= 1) AND (event_rating <= 5))),
    CONSTRAINT customer_feedback_overall_rating_check CHECK (((overall_rating >= 1) AND (overall_rating <= 5))),
    CONSTRAINT customer_feedback_platform_rating_check CHECK (((platform_rating >= 1) AND (platform_rating <= 5))),
    CONSTRAINT customer_feedback_seating_comfort_check CHECK (((seating_comfort >= 1) AND (seating_comfort <= 5))),
    CONSTRAINT customer_feedback_sentiment_score_check CHECK (((sentiment_score >= ('-1'::integer)::numeric) AND (sentiment_score <= (1)::numeric))),
    CONSTRAINT customer_feedback_sound_quality_check CHECK (((sound_quality >= 1) AND (sound_quality <= 5))),
    CONSTRAINT customer_feedback_staff_friendliness_check CHECK (((staff_friendliness >= 1) AND (staff_friendliness <= 5))),
    CONSTRAINT customer_feedback_value_for_money_check CHECK (((value_for_money >= 1) AND (value_for_money <= 5))),
    CONSTRAINT customer_feedback_venue_cleanliness_check CHECK (((venue_cleanliness >= 1) AND (venue_cleanliness <= 5))),
    CONSTRAINT customer_feedback_venue_rating_check CHECK (((venue_rating >= 1) AND (venue_rating <= 5)))
);



--
-- Name: TABLE customer_feedback; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.customer_feedback IS 'Customer feedback, reviews, and ratings for events, venues, and platform';


--
-- Name: COLUMN customer_feedback.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.id IS 'Unique identifier for feedback';


--
-- Name: COLUMN customer_feedback.customer_profile_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.customer_profile_id IS 'Customer who provided feedback';


--
-- Name: COLUMN customer_feedback.event_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.event_id IS 'Event being reviewed (if applicable)';


--
-- Name: COLUMN customer_feedback.venue_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.venue_id IS 'Venue being reviewed (if applicable)';


--
-- Name: COLUMN customer_feedback.order_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.order_id IS 'Related order for purchase verification';


--
-- Name: COLUMN customer_feedback.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.type IS 'Type of feedback: event_review, venue_review, platform_feedback, support_ticket';


--
-- Name: COLUMN customer_feedback.overall_rating; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.overall_rating IS 'Overall rating (1-5 stars)';


--
-- Name: COLUMN customer_feedback.venue_rating; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.venue_rating IS 'Venue-specific rating (1-5)';


--
-- Name: COLUMN customer_feedback.event_rating; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.event_rating IS 'Event-specific rating (1-5)';


--
-- Name: COLUMN customer_feedback.platform_rating; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.platform_rating IS 'Platform experience rating (1-5)';


--
-- Name: COLUMN customer_feedback.title; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.title IS 'Review title or subject';


--
-- Name: COLUMN customer_feedback.comment; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.comment IS 'Main feedback text';


--
-- Name: COLUMN customer_feedback.suggestions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.suggestions IS 'Suggestions for improvement';


--
-- Name: COLUMN customer_feedback.sound_quality; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.sound_quality IS 'Sound quality rating (1-5)';


--
-- Name: COLUMN customer_feedback.seating_comfort; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.seating_comfort IS 'Seating comfort rating (1-5)';


--
-- Name: COLUMN customer_feedback.venue_cleanliness; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.venue_cleanliness IS 'Venue cleanliness rating (1-5)';


--
-- Name: COLUMN customer_feedback.staff_friendliness; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.staff_friendliness IS 'Staff friendliness rating (1-5)';


--
-- Name: COLUMN customer_feedback.value_for_money; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.value_for_money IS 'Value for money rating (1-5)';


--
-- Name: COLUMN customer_feedback.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.status IS 'Publication status';


--
-- Name: COLUMN customer_feedback.moderation_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.moderation_status IS 'Content moderation status';


--
-- Name: COLUMN customer_feedback.venue_response; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.venue_response IS 'Response from venue (deprecated - use feedback_responses)';


--
-- Name: COLUMN customer_feedback.venue_responded_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.venue_responded_at IS 'When venue responded';


--
-- Name: COLUMN customer_feedback.response_helpful_count; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.response_helpful_count IS 'Number who found response helpful';


--
-- Name: COLUMN customer_feedback.is_verified_purchase; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.is_verified_purchase IS 'Whether reviewer purchased tickets';


--
-- Name: COLUMN customer_feedback.purchase_verified_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.purchase_verified_at IS 'When purchase was verified';


--
-- Name: COLUMN customer_feedback.helpful_count; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.helpful_count IS 'Number of helpful votes';


--
-- Name: COLUMN customer_feedback.not_helpful_count; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.not_helpful_count IS 'Number of not helpful votes';


--
-- Name: COLUMN customer_feedback.reported_count; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.reported_count IS 'Number of times reported';


--
-- Name: COLUMN customer_feedback.is_featured; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.is_featured IS 'Whether review is featured';


--
-- Name: COLUMN customer_feedback.display_order; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.display_order IS 'Custom sort order';


--
-- Name: COLUMN customer_feedback.is_anonymous; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.is_anonymous IS 'Whether posted anonymously';


--
-- Name: COLUMN customer_feedback.display_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.display_name IS 'Override name for display';


--
-- Name: COLUMN customer_feedback.photo_urls; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.photo_urls IS 'Array of photo URLs';


--
-- Name: COLUMN customer_feedback.has_photos; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.has_photos IS 'Quick check for photo existence';


--
-- Name: COLUMN customer_feedback.device_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.device_type IS 'Device used to submit';


--
-- Name: COLUMN customer_feedback.app_version; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.app_version IS 'App version at submission';


--
-- Name: COLUMN customer_feedback.survey_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.survey_id IS 'Link to survey if applicable';


--
-- Name: COLUMN customer_feedback.tags; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.tags IS 'Categorization tags';


--
-- Name: COLUMN customer_feedback.sentiment_score; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_feedback.sentiment_score IS 'Sentiment analysis score (-1 to 1)';


--
-- Name: customer_feedback_summary; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.customer_feedback_summary AS
 SELECT customer_feedback.type,
    count(*) AS total_feedback,
    count(*) FILTER (WHERE ((customer_feedback.status)::text = 'published'::text)) AS published_count,
    count(*) FILTER (WHERE ((customer_feedback.status)::text = 'pending'::text)) AS pending_count,
    count(*) FILTER (WHERE customer_feedback.is_verified_purchase) AS verified_count,
    avg(customer_feedback.overall_rating) FILTER (WHERE (customer_feedback.overall_rating IS NOT NULL)) AS avg_rating,
    count(*) FILTER (WHERE (customer_feedback.overall_rating >= 4)) AS positive_count,
    count(*) FILTER (WHERE (customer_feedback.overall_rating <= 2)) AS negative_count,
    count(*) FILTER (WHERE (customer_feedback.created_at >= (CURRENT_DATE - '7 days'::interval))) AS recent_count
   FROM public.customer_feedback
  GROUP BY customer_feedback.type;



--
-- Name: VIEW customer_feedback_summary; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON VIEW public.customer_feedback_summary IS 'Summary statistics for customer feedback by type';


--
-- Name: customer_ltv; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.customer_ltv (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    customer_id uuid,
    lifetime_value numeric(10,2),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: customer_preferences; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.customer_preferences (
    customer_id character varying(255) NOT NULL,
    marketing_emails boolean DEFAULT true,
    sms_notifications boolean DEFAULT false,
    push_notifications boolean DEFAULT true,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: TABLE customer_preferences; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.customer_preferences IS 'Stores all customer preference settings including notifications, privacy, accessibility, and display preferences';


--
-- Name: COLUMN customer_preferences.marketing_emails; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_preferences.marketing_emails IS 'Opt-in consent for marketing email communications';


--
-- Name: COLUMN customer_preferences.sms_notifications; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_preferences.sms_notifications IS 'Global toggle for all SMS notifications';


--
-- Name: COLUMN customer_preferences.push_notifications; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_preferences.push_notifications IS 'Global toggle for all push notifications';


--
-- Name: COLUMN customer_preferences.created_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_preferences.created_at IS 'When the preference record was created';


--
-- Name: customer_profiles; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.customer_profiles (
    customer_id character varying(255) NOT NULL,
    email character varying(255),
    name character varying(255),
    phone character varying(50),
    address text,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: TABLE customer_profiles; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.customer_profiles IS 'Stores detailed customer profile information including personal details, KYC status, and customer metrics';


--
-- Name: COLUMN customer_profiles.email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_profiles.email IS 'Primary email address - must be unique';


--
-- Name: COLUMN customer_profiles.phone; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_profiles.phone IS 'Phone number in international format';


--
-- Name: COLUMN customer_profiles.created_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_profiles.created_at IS 'When the record was created';


--
-- Name: COLUMN customer_profiles.updated_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customer_profiles.updated_at IS 'When the record was last updated';


--
-- Name: customer_segments; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.customer_segments (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    segment_name character varying(100),
    criteria jsonb,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: customer_tax_records; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.customer_tax_records (
    id integer NOT NULL,
    customer_id character varying(255) NOT NULL,
    year integer NOT NULL,
    transaction_type character varying(50) NOT NULL,
    amount numeric(10,2) NOT NULL,
    ticket_id character varying(255),
    asset_type character varying(50),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: customer_tax_records_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.customer_tax_records_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;



--
-- Name: customer_tax_records_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.customer_tax_records_id_seq OWNED BY public.customer_tax_records.id;


--
-- Name: data_breach_notifications; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.data_breach_notifications (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    breach_date date,
    affected_users integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: data_deletion_requests; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.data_deletion_requests (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    user_id uuid,
    status character varying(50),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: data_export_requests; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.data_export_requests (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    user_id uuid,
    status character varying(50),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: data_retention; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.data_retention (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    data_type character varying(100),
    retention_days integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: data_retention_policies; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.data_retention_policies (
    id integer NOT NULL,
    data_type character varying(100) NOT NULL,
    retention_days integer NOT NULL,
    legal_basis text,
    can_delete boolean DEFAULT false,
    last_enforcement timestamp without time zone,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: data_retention_policies_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.data_retention_policies_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;



--
-- Name: data_retention_policies_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.data_retention_policies_id_seq OWNED BY public.data_retention_policies.id;


--
-- Name: dead_letter_jobs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dead_letter_jobs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    original_job_id uuid,
    job_type character varying(100),
    payload jsonb,
    error_message text,
    retry_count integer DEFAULT 0,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: dead_letter_queue; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dead_letter_queue (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    message jsonb,
    error_message text,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: delivery_tracking; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.delivery_tracking (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    notification_id uuid,
    status character varying(50),
    delivered_at timestamp without time zone
);



--
-- Name: dispute_evidence_packs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dispute_evidence_packs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    dispute_id character varying(255) NOT NULL,
    order_id uuid,
    evidence_data jsonb NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: dispute_messages; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dispute_messages (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    dispute_id uuid,
    message text,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: dispute_resolution; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dispute_resolution (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    marketplace_transaction_id uuid NOT NULL,
    escrow_id uuid,
    initiator_id uuid NOT NULL,
    respondent_id uuid NOT NULL,
    dispute_type character varying(50) NOT NULL,
    status character varying(50) DEFAULT 'OPEN'::character varying NOT NULL,
    priority character varying(20) DEFAULT 'NORMAL'::character varying,
    reason character varying(100) NOT NULL,
    description text NOT NULL,
    evidence jsonb DEFAULT '[]'::jsonb,
    resolution_type character varying(50),
    resolution_decision text,
    resolved_by uuid,
    resolution_amount numeric(10,2),
    buyer_refund_amount numeric(10,2),
    seller_payout_amount numeric(10,2),
    messages jsonb DEFAULT '[]'::jsonb,
    last_message_at timestamp with time zone,
    is_escalated boolean DEFAULT false,
    escalated_at timestamp with time zone,
    escalation_level integer DEFAULT 1,
    response_deadline timestamp with time zone,
    resolution_deadline timestamp with time zone,
    metadata jsonb DEFAULT '{}'::jsonb,
    opened_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    resolved_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_dispute_status CHECK (((status)::text = ANY (ARRAY[('OPEN'::character varying)::text, ('AWAITING_RESPONSE'::character varying)::text, ('UNDER_REVIEW'::character varying)::text, ('RESOLVED'::character varying)::text, ('CLOSED'::character varying)::text, ('ESCALATED'::character varying)::text]))),
    CONSTRAINT valid_dispute_type CHECK (((dispute_type)::text = ANY (ARRAY[('NON_DELIVERY'::character varying)::text, ('NOT_AS_DESCRIBED'::character varying)::text, ('FRAUDULENT'::character varying)::text, ('DUPLICATE_CHARGE'::character varying)::text, ('TRANSFER_ISSUE'::character varying)::text, ('AUTHENTICATION'::character varying)::text, ('OTHER'::character varying)::text]))),
    CONSTRAINT valid_resolution_type CHECK (((resolution_type IS NULL) OR ((resolution_type)::text = ANY (ARRAY[('FULL_REFUND'::character varying)::text, ('PARTIAL_REFUND'::character varying)::text, ('NO_REFUND'::character varying)::text, ('REPLACEMENT'::character varying)::text, ('SPLIT'::character varying)::text]))))
);



--
-- Name: escrow; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.escrow (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    marketplace_transaction_id uuid NOT NULL,
    payment_transaction_id uuid,
    buyer_id uuid NOT NULL,
    seller_id uuid NOT NULL,
    amount numeric(10,2) NOT NULL,
    currency character varying(10) DEFAULT 'USD'::character varying,
    status character varying(50) DEFAULT 'HELD'::character varying NOT NULL,
    release_type character varying(50) DEFAULT 'AUTOMATIC'::character varying,
    auto_release_at timestamp with time zone,
    release_conditions jsonb DEFAULT '{}'::jsonb,
    buyer_approved boolean DEFAULT false,
    seller_approved boolean DEFAULT false,
    admin_approved boolean DEFAULT false,
    buyer_approved_at timestamp with time zone,
    seller_approved_at timestamp with time zone,
    admin_approved_at timestamp with time zone,
    is_disputed boolean DEFAULT false,
    dispute_id uuid,
    released_at timestamp with time zone,
    released_to character varying(50),
    release_transaction_id uuid,
    hold_reason text,
    release_notes text,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_escrow_status CHECK (((status)::text = ANY (ARRAY[('HELD'::character varying)::text, ('PENDING_RELEASE'::character varying)::text, ('RELEASED'::character varying)::text, ('REFUNDED'::character varying)::text, ('DISPUTED'::character varying)::text, ('EXPIRED'::character varying)::text]))),
    CONSTRAINT valid_release_type CHECK (((release_type)::text = ANY (ARRAY[('AUTOMATIC'::character varying)::text, ('MANUAL'::character varying)::text, ('CONDITIONAL'::character varying)::text, ('DISPUTE_RESOLUTION'::character varying)::text])))
);



--
-- Name: event_analytics; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_analytics (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    event_id uuid,
    date date NOT NULL,
    views integer DEFAULT 0,
    ticket_sales integer DEFAULT 0,
    revenue numeric(10,2) DEFAULT 0,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: event_analytics_tracking; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_analytics_tracking (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_id uuid NOT NULL,
    analytics_provider character varying(30) NOT NULL,
    tracking_id character varying(100) NOT NULL,
    tracking_code text,
    measurement_id character varying(100),
    config_parameters jsonb,
    event_goals jsonb,
    custom_dimensions jsonb,
    custom_metrics jsonb,
    ecommerce_tracking boolean DEFAULT false,
    enhanced_ecommerce boolean DEFAULT false,
    cross_domain_tracking boolean DEFAULT false,
    data_retention_days integer DEFAULT 365,
    sampling_rate numeric(3,2) DEFAULT 100,
    debug_mode boolean DEFAULT false,
    consent_required boolean DEFAULT true,
    consent_categories text[],
    is_active boolean DEFAULT true,
    created_by uuid,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT event_analytics_tracking_analytics_provider_check CHECK (((analytics_provider)::text = ANY (ARRAY[('GOOGLE_ANALYTICS'::character varying)::text, ('FACEBOOK_PIXEL'::character varying)::text, ('GOOGLE_TAG_MANAGER'::character varying)::text, ('MIXPANEL'::character varying)::text, ('AMPLITUDE'::character varying)::text, ('HOTJAR'::character varying)::text, ('CUSTOM'::character varying)::text]))),
    CONSTRAINT event_analytics_tracking_sampling_rate_check CHECK (((sampling_rate >= (0)::numeric) AND (sampling_rate <= (100)::numeric)))
);



--
-- Name: TABLE event_analytics_tracking; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_analytics_tracking IS 'Analytics tracking codes and configuration';


--
-- Name: event_capacity; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_capacity (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    event_id uuid NOT NULL,
    schedule_id uuid,
    section_name character varying(100) NOT NULL,
    section_code character varying(20),
    tier character varying(50),
    total_capacity integer NOT NULL,
    available_capacity integer NOT NULL,
    reserved_capacity integer DEFAULT 0,
    buffer_capacity integer DEFAULT 0,
    sold_count integer DEFAULT 0,
    pending_count integer DEFAULT 0,
    row_config jsonb,
    seat_map jsonb,
    is_active boolean DEFAULT true,
    is_visible boolean DEFAULT true,
    minimum_purchase integer DEFAULT 1,
    maximum_purchase integer,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_capacity CHECK (((total_capacity >= 0) AND (available_capacity >= 0) AND (available_capacity <= total_capacity)))
);



--
-- Name: TABLE event_capacity; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_capacity IS 'Master table for event capacity management and tracking';


--
-- Name: event_capacity_alerts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_capacity_alerts (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_capacity_id uuid NOT NULL,
    alert_type character varying(30) NOT NULL,
    threshold_percentage numeric(5,2),
    threshold_absolute integer,
    current_value numeric(10,2) NOT NULL,
    alert_level character varying(20) DEFAULT 'INFO'::character varying,
    message text NOT NULL,
    is_acknowledged boolean DEFAULT false,
    acknowledged_by uuid,
    acknowledged_at timestamp with time zone,
    auto_resolve boolean DEFAULT true,
    resolved_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT event_capacity_alerts_alert_level_check CHECK (((alert_level)::text = ANY (ARRAY[('INFO'::character varying)::text, ('WARNING'::character varying)::text, ('CRITICAL'::character varying)::text]))),
    CONSTRAINT event_capacity_alerts_alert_type_check CHECK (((alert_type)::text = ANY (ARRAY[('LOW_CAPACITY'::character varying)::text, ('OVERSOLD'::character varying)::text, ('RAPID_SALES'::character varying)::text, ('HOLD_EXPIRING'::character varying)::text, ('THRESHOLD_REACHED'::character varying)::text])))
);



--
-- Name: TABLE event_capacity_alerts; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_capacity_alerts IS 'Capacity warnings and threshold alerts';


--
-- Name: event_capacity_by_tier; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_capacity_by_tier (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_capacity_id uuid NOT NULL,
    pricing_tier character varying(50) NOT NULL,
    tier_priority integer NOT NULL,
    allocated_capacity integer NOT NULL,
    sold_capacity integer DEFAULT 0,
    available_capacity integer NOT NULL,
    min_price numeric(10,2),
    max_price numeric(10,2),
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT event_capacity_by_tier_allocated_capacity_check CHECK ((allocated_capacity >= 0)),
    CONSTRAINT event_capacity_by_tier_available_capacity_check CHECK ((available_capacity >= 0)),
    CONSTRAINT event_capacity_by_tier_sold_capacity_check CHECK ((sold_capacity >= 0))
);



--
-- Name: TABLE event_capacity_by_tier; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_capacity_by_tier IS 'Capacity allocation and tracking by pricing tier';


--
-- Name: event_capacity_by_type; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_capacity_by_type (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_capacity_id uuid NOT NULL,
    ticket_type_id uuid NOT NULL,
    allocated_capacity integer NOT NULL,
    sold_capacity integer DEFAULT 0,
    available_capacity integer NOT NULL,
    hold_capacity integer DEFAULT 0,
    min_capacity integer DEFAULT 0,
    max_capacity integer,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_type_capacity_logic CHECK ((((sold_capacity + available_capacity) + hold_capacity) <= allocated_capacity)),
    CONSTRAINT event_capacity_by_type_allocated_capacity_check CHECK ((allocated_capacity >= 0)),
    CONSTRAINT event_capacity_by_type_available_capacity_check CHECK ((available_capacity >= 0)),
    CONSTRAINT event_capacity_by_type_hold_capacity_check CHECK ((hold_capacity >= 0)),
    CONSTRAINT event_capacity_by_type_sold_capacity_check CHECK ((sold_capacity >= 0))
);



--
-- Name: TABLE event_capacity_by_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_capacity_by_type IS 'Capacity allocation and tracking by ticket type';


--
-- Name: event_capacity_holds; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_capacity_holds (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_capacity_id uuid NOT NULL,
    hold_type character varying(20) NOT NULL,
    quantity integer NOT NULL,
    ticket_type_id uuid,
    hold_reference character varying(100),
    status character varying(20) DEFAULT 'ACTIVE'::character varying,
    expires_at timestamp with time zone NOT NULL,
    created_by uuid,
    released_by uuid,
    released_at timestamp with time zone,
    notes text,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT event_capacity_holds_hold_type_check CHECK (((hold_type)::text = ANY (ARRAY[('PRESALE'::character varying)::text, ('GROUP'::character varying)::text, ('CORPORATE'::character varying)::text, ('MANUAL'::character varying)::text, ('SYSTEM'::character varying)::text]))),
    CONSTRAINT event_capacity_holds_quantity_check CHECK ((quantity > 0)),
    CONSTRAINT event_capacity_holds_status_check CHECK (((status)::text = ANY (ARRAY[('ACTIVE'::character varying)::text, ('RELEASED'::character varying)::text, ('EXPIRED'::character varying)::text, ('CONVERTED'::character varying)::text])))
);



--
-- Name: TABLE event_capacity_holds; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_capacity_holds IS 'Temporary capacity holds for presales, groups, etc.';


--
-- Name: event_capacity_oversell_policies; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_capacity_oversell_policies (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_capacity_id uuid NOT NULL,
    policy_name character varying(100) NOT NULL,
    oversell_percentage numeric(5,2),
    oversell_absolute integer,
    applies_to_ticket_types uuid[],
    min_advance_days integer DEFAULT 0,
    auto_upgrade_enabled boolean DEFAULT false,
    waitlist_enabled boolean DEFAULT true,
    notification_thresholds integer[] DEFAULT ARRAY[95, 100, 105],
    created_by uuid,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_oversell_policy_values CHECK (((oversell_percentage IS NOT NULL) OR (oversell_absolute IS NOT NULL))),
    CONSTRAINT event_capacity_oversell_policies_oversell_absolute_check CHECK ((oversell_absolute >= 0)),
    CONSTRAINT event_capacity_oversell_policies_oversell_percentage_check CHECK (((oversell_percentage >= (0)::numeric) AND (oversell_percentage <= (100)::numeric)))
);



--
-- Name: TABLE event_capacity_oversell_policies; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_capacity_oversell_policies IS 'Overselling policies and rules';


--
-- Name: event_capacity_reservations; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_capacity_reservations (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_capacity_id uuid NOT NULL,
    reservation_type character varying(20) NOT NULL,
    allocated_quantity integer NOT NULL,
    used_quantity integer DEFAULT 0,
    available_quantity integer NOT NULL,
    priority_level integer DEFAULT 1,
    description text,
    expires_at timestamp with time zone,
    created_by uuid,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_reservation_quantities CHECK (((used_quantity + available_quantity) <= allocated_quantity)),
    CONSTRAINT event_capacity_reservations_allocated_quantity_check CHECK ((allocated_quantity > 0)),
    CONSTRAINT event_capacity_reservations_available_quantity_check CHECK ((available_quantity >= 0)),
    CONSTRAINT event_capacity_reservations_reservation_type_check CHECK (((reservation_type)::text = ANY (ARRAY[('STAFF'::character varying)::text, ('PRESS'::character varying)::text, ('COMP'::character varying)::text, ('VIP'::character varying)::text, ('SPONSOR'::character varying)::text, ('ACCESSIBILITY'::character varying)::text]))),
    CONSTRAINT event_capacity_reservations_used_quantity_check CHECK ((used_quantity >= 0))
);



--
-- Name: TABLE event_capacity_reservations; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_capacity_reservations IS 'Reserved capacity for staff, press, comps, etc.';


--
-- Name: event_capacity_snapshots; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_capacity_snapshots (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_capacity_id uuid NOT NULL,
    snapshot_timestamp timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    total_capacity integer NOT NULL,
    sold_capacity integer NOT NULL,
    available_capacity integer NOT NULL,
    hold_capacity integer NOT NULL,
    reserved_capacity integer NOT NULL,
    utilization_percentage numeric(5,2) NOT NULL,
    sales_velocity_per_hour numeric(8,2),
    projected_sellout_time timestamp with time zone,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: TABLE event_capacity_snapshots; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_capacity_snapshots IS 'Real-time capacity tracking snapshots';


--
-- Name: event_capacity_utilization_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_capacity_utilization_history (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_capacity_id uuid NOT NULL,
    date_recorded date NOT NULL,
    hour_of_day integer,
    tickets_sold_count integer DEFAULT 0,
    tickets_sold_revenue numeric(12,2) DEFAULT 0,
    capacity_utilization numeric(5,2) NOT NULL,
    sales_channel character varying(50),
    ticket_type_breakdown jsonb,
    pricing_tier_breakdown jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT event_capacity_utilization_history_hour_of_day_check CHECK (((hour_of_day >= 0) AND (hour_of_day <= 23)))
);



--
-- Name: TABLE event_capacity_utilization_history; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_capacity_utilization_history IS 'Historical capacity utilization data';


--
-- Name: event_categories; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_categories (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    parent_id uuid,
    name character varying(100) NOT NULL,
    slug character varying(100) NOT NULL,
    description text,
    icon character varying(50),
    color character varying(7),
    display_order integer DEFAULT 0,
    is_active boolean DEFAULT true,
    is_featured boolean DEFAULT false,
    meta_title character varying(70),
    meta_description character varying(160),
    event_count integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: TABLE event_categories; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_categories IS 'Master table for event categories with hierarchical structure';


--
-- Name: event_category_analytics; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_category_analytics (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    category_id uuid NOT NULL,
    analytics_date date NOT NULL,
    event_count integer DEFAULT 0,
    tickets_sold integer DEFAULT 0,
    revenue numeric(12,2) DEFAULT 0,
    unique_buyers integer DEFAULT 0,
    avg_ticket_price numeric(10,2) DEFAULT 0,
    search_impressions integer DEFAULT 0,
    category_clicks integer DEFAULT 0,
    click_through_rate numeric(5,4) DEFAULT 0,
    conversion_rate numeric(5,4) DEFAULT 0,
    bounce_rate numeric(5,4) DEFAULT 0,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: TABLE event_category_analytics; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_category_analytics IS 'Daily analytics data for category performance tracking';


--
-- Name: event_category_attributes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_category_attributes (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    category_id uuid NOT NULL,
    attribute_type character varying(50) NOT NULL,
    attribute_name character varying(100) NOT NULL,
    attribute_value character varying(200) NOT NULL,
    attribute_data jsonb,
    is_primary boolean DEFAULT false,
    display_order integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: TABLE event_category_attributes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_category_attributes IS 'Genre-specific attributes for categories (music genres, sports leagues, etc.)';


--
-- Name: event_category_mappings; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_category_mappings (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_id uuid NOT NULL,
    category_id uuid NOT NULL,
    is_primary_category boolean DEFAULT false,
    mapping_confidence numeric(3,2) DEFAULT 1.00,
    assigned_by character varying(20) DEFAULT 'MANUAL'::character varying,
    assigned_by_user uuid,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT event_category_mappings_assigned_by_check CHECK (((assigned_by)::text = ANY (ARRAY[('MANUAL'::character varying)::text, ('AUTO'::character varying)::text, ('ML_SUGGESTED'::character varying)::text, ('USER_GENERATED'::character varying)::text]))),
    CONSTRAINT event_category_mappings_mapping_confidence_check CHECK (((mapping_confidence >= (0)::numeric) AND (mapping_confidence <= (1)::numeric)))
);



--
-- Name: TABLE event_category_mappings; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_category_mappings IS 'Many-to-many mapping between events and categories';


--
-- Name: event_category_search_suggestions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_category_search_suggestions (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    category_id uuid NOT NULL,
    suggestion_text character varying(200) NOT NULL,
    suggestion_type character varying(20) DEFAULT 'AUTO_COMPLETE'::character varying,
    search_count integer DEFAULT 0,
    success_rate numeric(5,4) DEFAULT 0,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    last_used timestamp with time zone,
    CONSTRAINT event_category_search_suggestions_suggestion_type_check CHECK (((suggestion_type)::text = ANY (ARRAY[('AUTO_COMPLETE'::character varying)::text, ('RELATED'::character varying)::text, ('POPULAR'::character varying)::text, ('TRENDING'::character varying)::text])))
);



--
-- Name: TABLE event_category_search_suggestions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_category_search_suggestions IS 'Auto-complete and search suggestions for categories';


--
-- Name: event_category_tags; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_category_tags (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    category_id uuid NOT NULL,
    tag_name character varying(50) NOT NULL,
    tag_type character varying(20) DEFAULT 'GENERAL'::character varying,
    search_weight numeric(3,2) DEFAULT 1.00,
    is_featured boolean DEFAULT false,
    usage_count integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT event_category_tags_search_weight_check CHECK ((search_weight >= (0)::numeric)),
    CONSTRAINT event_category_tags_tag_type_check CHECK (((tag_type)::text = ANY (ARRAY[('GENERAL'::character varying)::text, ('GENRE'::character varying)::text, ('MOOD'::character varying)::text, ('AUDIENCE'::character varying)::text, ('OCCASION'::character varying)::text, ('LOCATION'::character varying)::text])))
);



--
-- Name: TABLE event_category_tags; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_category_tags IS 'Search tags and keywords for category discovery';


--
-- Name: event_category_trending; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_category_trending (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    category_id uuid NOT NULL,
    trending_period character varying(20) NOT NULL,
    period_start timestamp with time zone NOT NULL,
    period_end timestamp with time zone NOT NULL,
    search_volume integer DEFAULT 0,
    event_creation_rate numeric(8,4) DEFAULT 0,
    ticket_sales_velocity numeric(8,4) DEFAULT 0,
    social_mentions integer DEFAULT 0,
    trending_score numeric(8,4) DEFAULT 0,
    trend_direction character varying(10),
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT event_category_trending_trend_direction_check CHECK (((trend_direction)::text = ANY (ARRAY[('UP'::character varying)::text, ('DOWN'::character varying)::text, ('STABLE'::character varying)::text]))),
    CONSTRAINT event_category_trending_trending_period_check CHECK (((trending_period)::text = ANY (ARRAY[('HOURLY'::character varying)::text, ('DAILY'::character varying)::text, ('WEEKLY'::character varying)::text, ('MONTHLY'::character varying)::text])))
);



--
-- Name: TABLE event_category_trending; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_category_trending IS 'Trending metrics for categories across different time periods';


--
-- Name: event_custom_attributes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_custom_attributes (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_id uuid NOT NULL,
    attribute_name character varying(100) NOT NULL,
    attribute_label character varying(200),
    attribute_value text,
    attribute_json jsonb,
    data_type character varying(20) DEFAULT 'STRING'::character varying,
    input_type character varying(30) DEFAULT 'TEXT'::character varying,
    validation_rules jsonb,
    default_value text,
    allowed_values text[],
    is_required boolean DEFAULT false,
    is_public boolean DEFAULT true,
    is_searchable boolean DEFAULT false,
    display_group character varying(50),
    display_order integer DEFAULT 0,
    help_text text,
    created_by uuid,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_custom_attribute_value CHECK (((attribute_value IS NOT NULL) OR (attribute_json IS NOT NULL))),
    CONSTRAINT event_custom_attributes_data_type_check CHECK (((data_type)::text = ANY (ARRAY[('STRING'::character varying)::text, ('NUMBER'::character varying)::text, ('BOOLEAN'::character varying)::text, ('DATE'::character varying)::text, ('JSON'::character varying)::text, ('ARRAY'::character varying)::text, ('FILE'::character varying)::text, ('COLOR'::character varying)::text, ('COORDINATES'::character varying)::text]))),
    CONSTRAINT event_custom_attributes_input_type_check CHECK (((input_type)::text = ANY (ARRAY[('TEXT'::character varying)::text, ('TEXTAREA'::character varying)::text, ('SELECT'::character varying)::text, ('MULTISELECT'::character varying)::text, ('CHECKBOX'::character varying)::text, ('RADIO'::character varying)::text, ('DATE'::character varying)::text, ('TIME'::character varying)::text, ('DATETIME'::character varying)::text, ('NUMBER'::character varying)::text, ('FILE'::character varying)::text, ('COLOR'::character varying)::text, ('URL'::character varying)::text, ('EMAIL'::character varying)::text])))
);



--
-- Name: TABLE event_custom_attributes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_custom_attributes IS 'Custom event attributes with flexible data types';


--
-- Name: event_marketing_campaigns; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_marketing_campaigns (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_id uuid NOT NULL,
    campaign_name character varying(100) NOT NULL,
    campaign_type character varying(30) NOT NULL,
    campaign_source character varying(50),
    campaign_medium character varying(50),
    campaign_content character varying(100),
    campaign_term character varying(100),
    utm_source character varying(100),
    utm_medium character varying(100),
    utm_campaign character varying(100),
    utm_content character varying(100),
    utm_term character varying(100),
    start_date timestamp with time zone,
    end_date timestamp with time zone,
    budget numeric(12,2),
    spend numeric(12,2) DEFAULT 0,
    target_audience jsonb,
    creative_assets jsonb,
    performance_metrics jsonb,
    roi numeric(8,4),
    attribution_model character varying(30) DEFAULT 'LAST_CLICK'::character varying,
    conversion_window_days integer DEFAULT 30,
    is_active boolean DEFAULT true,
    created_by uuid,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_marketing_dates CHECK (((end_date IS NULL) OR (end_date >= start_date))),
    CONSTRAINT event_marketing_campaigns_campaign_type_check CHECK (((campaign_type)::text = ANY (ARRAY[('EMAIL'::character varying)::text, ('SOCIAL_MEDIA'::character varying)::text, ('PAID_SEARCH'::character varying)::text, ('DISPLAY'::character varying)::text, ('AFFILIATE'::character varying)::text, ('INFLUENCER'::character varying)::text, ('PRINT'::character varying)::text, ('RADIO'::character varying)::text, ('TV'::character varying)::text, ('OUTDOOR'::character varying)::text, ('PARTNERSHIP'::character varying)::text])))
);



--
-- Name: TABLE event_marketing_campaigns; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_marketing_campaigns IS 'Marketing campaign associations and UTM tracking';


--
-- Name: event_metadata; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_metadata (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    event_id uuid NOT NULL,
    performers jsonb DEFAULT '[]'::jsonb,
    headliner character varying(200),
    supporting_acts text[],
    production_company character varying(200),
    technical_requirements jsonb DEFAULT '{}'::jsonb,
    stage_setup_time_hours integer,
    sponsors jsonb DEFAULT '[]'::jsonb,
    primary_sponsor character varying(200),
    performance_rights_org character varying(100),
    licensing_requirements text[],
    insurance_requirements jsonb DEFAULT '{}'::jsonb,
    press_release text,
    marketing_copy jsonb DEFAULT '{}'::jsonb,
    social_media_copy jsonb DEFAULT '{}'::jsonb,
    sound_requirements jsonb DEFAULT '{}'::jsonb,
    lighting_requirements jsonb DEFAULT '{}'::jsonb,
    video_requirements jsonb DEFAULT '{}'::jsonb,
    catering_requirements jsonb DEFAULT '{}'::jsonb,
    rider_requirements jsonb DEFAULT '{}'::jsonb,
    production_budget numeric(12,2),
    marketing_budget numeric(12,2),
    projected_revenue numeric(12,2),
    break_even_capacity integer,
    previous_events jsonb DEFAULT '[]'::jsonb,
    custom_fields jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: TABLE event_metadata; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_metadata IS 'Master table for all event metadata with versioning support';


--
-- Name: event_metadata_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_metadata_history (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    metadata_id uuid NOT NULL,
    event_id uuid NOT NULL,
    metadata_type character varying(30) NOT NULL,
    metadata_key character varying(100) NOT NULL,
    old_value text,
    new_value text,
    old_json jsonb,
    new_json jsonb,
    change_type character varying(20) NOT NULL,
    change_reason character varying(500),
    changed_by uuid,
    changed_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT event_metadata_history_change_type_check CHECK (((change_type)::text = ANY (ARRAY[('CREATE'::character varying)::text, ('UPDATE'::character varying)::text, ('DELETE'::character varying)::text, ('RESTORE'::character varying)::text])))
);



--
-- Name: TABLE event_metadata_history; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_metadata_history IS 'Complete history of all metadata changes';


--
-- Name: event_metadata_templates; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_metadata_templates (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    template_name character varying(100) NOT NULL,
    template_description text,
    category_id uuid,
    venue_id uuid,
    template_data jsonb NOT NULL,
    default_values jsonb,
    required_fields text[],
    optional_fields text[],
    validation_schema jsonb,
    is_global boolean DEFAULT false,
    is_active boolean DEFAULT true,
    usage_count integer DEFAULT 0,
    created_by uuid,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: TABLE event_metadata_templates; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_metadata_templates IS 'Reusable metadata templates for events';


--
-- Name: event_performance; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_performance (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    event_id uuid,
    metric_name character varying(100),
    metric_value numeric,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: event_performers; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_performers (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_id uuid NOT NULL,
    performer_name character varying(200) NOT NULL,
    performer_type public.performer_type NOT NULL,
    stage_name character varying(200),
    performer_description text,
    performer_genre character varying(100),
    performer_website text,
    performer_social_media jsonb DEFAULT '{}'::jsonb,
    performance_order integer DEFAULT 1 NOT NULL,
    set_duration interval,
    scheduled_start_time time without time zone,
    scheduled_end_time time without time zone,
    song_list text[],
    special_notes text,
    technical_rider_url text,
    hospitality_rider_url text,
    performer_image_url text,
    promotional_images jsonb DEFAULT '[]'::jsonb,
    confirmed boolean DEFAULT false NOT NULL,
    featured boolean DEFAULT false NOT NULL,
    headliner boolean DEFAULT false NOT NULL,
    performance_fee numeric(10,2),
    expense_budget numeric(10,2),
    payment_terms text,
    contract_signed boolean DEFAULT false NOT NULL,
    contact_name character varying(200),
    contact_email character varying(320),
    contact_phone character varying(20),
    agent_name character varying(200),
    agent_contact character varying(320),
    equipment_requirements text,
    backstage_requirements text,
    catering_requirements text,
    transportation_needs text,
    accommodation_needs text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by_user_id uuid,
    CONSTRAINT event_performers_valid_fees CHECK ((((performance_fee IS NULL) OR (performance_fee >= (0)::numeric)) AND ((expense_budget IS NULL) OR (expense_budget >= (0)::numeric)))),
    CONSTRAINT event_performers_valid_order CHECK ((performance_order > 0)),
    CONSTRAINT event_performers_valid_times CHECK (((scheduled_end_time IS NULL) OR (scheduled_start_time IS NULL) OR (scheduled_end_time > scheduled_start_time)))
);



--
-- Name: TABLE event_performers; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_performers IS 'Event performer and artist lineup management with contract details';


--
-- Name: COLUMN event_performers.performance_order; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.event_performers.performance_order IS 'Lineup order: performance sequence (1 = first, higher = later)';


--
-- Name: COLUMN event_performers.technical_rider_url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.event_performers.technical_rider_url IS 'Technical requirements: link to technical rider document';


--
-- Name: COLUMN event_performers.hospitality_rider_url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.event_performers.hospitality_rider_url IS 'Hospitality requirements: link to hospitality rider document';


--
-- Name: COLUMN event_performers.contract_signed; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.event_performers.contract_signed IS 'Contract status: whether performance contract is executed';


--
-- Name: event_pricing; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_pricing (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    event_id uuid NOT NULL,
    schedule_id uuid,
    capacity_id uuid,
    name character varying(100) NOT NULL,
    description text,
    tier character varying(50),
    base_price numeric(10,2) NOT NULL,
    service_fee numeric(10,2) DEFAULT 0,
    facility_fee numeric(10,2) DEFAULT 0,
    tax_rate numeric(5,4) DEFAULT 0,
    is_dynamic boolean DEFAULT false,
    min_price numeric(10,2),
    max_price numeric(10,2),
    price_adjustment_rules jsonb DEFAULT '{}'::jsonb,
    current_price numeric(10,2),
    early_bird_price numeric(10,2),
    early_bird_ends_at timestamp with time zone,
    last_minute_price numeric(10,2),
    last_minute_starts_at timestamp with time zone,
    group_size_min integer,
    group_discount_percentage numeric(5,2),
    currency character varying(3) DEFAULT 'USD'::character varying,
    sales_start_at timestamp with time zone,
    sales_end_at timestamp with time zone,
    max_per_order integer,
    max_per_customer integer,
    is_active boolean DEFAULT true,
    is_visible boolean DEFAULT true,
    display_order integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_base_price CHECK ((base_price >= (0)::numeric)),
    CONSTRAINT valid_dynamic_range CHECK (((is_dynamic = false) OR ((min_price IS NOT NULL) AND (max_price IS NOT NULL) AND (min_price <= max_price)))),
    CONSTRAINT valid_early_bird CHECK (((early_bird_price IS NULL) OR ((early_bird_price < base_price) AND (early_bird_ends_at IS NOT NULL))))
);



--
-- Name: TABLE event_pricing; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_pricing IS 'Master table for event pricing strategies and configuration';


--
-- Name: event_pricing_demand_factors; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_pricing_demand_factors (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_pricing_id uuid NOT NULL,
    factor_name character varying(100) NOT NULL,
    factor_type character varying(30) NOT NULL,
    threshold_value numeric(10,4) NOT NULL,
    comparison_operator character varying(10) NOT NULL,
    price_multiplier numeric(6,4) DEFAULT 1.0000,
    max_price_increase numeric(10,2),
    max_price_decrease numeric(10,2),
    evaluation_frequency interval DEFAULT '00:05:00'::interval,
    is_active boolean DEFAULT true,
    last_evaluated timestamp with time zone,
    last_triggered timestamp with time zone,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT event_pricing_demand_factors_comparison_operator_check CHECK (((comparison_operator)::text = ANY (ARRAY[('>'::character varying)::text, ('>='::character varying)::text, ('<'::character varying)::text, ('<='::character varying)::text, ('='::character varying)::text, ('!='::character varying)::text]))),
    CONSTRAINT event_pricing_demand_factors_factor_type_check CHECK (((factor_type)::text = ANY (ARRAY[('SALES_VELOCITY'::character varying)::text, ('CAPACITY_UTILIZATION'::character varying)::text, ('TIME_TO_EVENT'::character varying)::text, ('EXTERNAL_DEMAND'::character varying)::text, ('COMPETITOR_PRICING'::character varying)::text])))
);



--
-- Name: TABLE event_pricing_demand_factors; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_pricing_demand_factors IS 'Demand-based pricing adjustment factors';


--
-- Name: event_pricing_dynamic_rules; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_pricing_dynamic_rules (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_pricing_id uuid NOT NULL,
    rule_name character varying(100) NOT NULL,
    rule_type character varying(30) NOT NULL,
    trigger_condition jsonb NOT NULL,
    price_adjustment_type character varying(20) NOT NULL,
    adjustment_value numeric(10,4) NOT NULL,
    min_adjustment numeric(10,2),
    max_adjustment numeric(10,2),
    priority_order integer DEFAULT 1,
    is_active boolean DEFAULT true,
    applies_to_tiers uuid[],
    cooldown_period interval DEFAULT '00:15:00'::interval,
    last_applied timestamp with time zone,
    created_by uuid,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT event_pricing_dynamic_rules_price_adjustment_type_check CHECK (((price_adjustment_type)::text = ANY (ARRAY[('PERCENTAGE'::character varying)::text, ('FIXED_AMOUNT'::character varying)::text, ('MULTIPLIER'::character varying)::text, ('SET_PRICE'::character varying)::text]))),
    CONSTRAINT event_pricing_dynamic_rules_rule_type_check CHECK (((rule_type)::text = ANY (ARRAY[('DEMAND_BASED'::character varying)::text, ('TIME_BASED'::character varying)::text, ('CAPACITY_BASED'::character varying)::text, ('VELOCITY_BASED'::character varying)::text, ('EXTERNAL_FACTOR'::character varying)::text])))
);



--
-- Name: TABLE event_pricing_dynamic_rules; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_pricing_dynamic_rules IS 'Dynamic pricing rules and triggers';


--
-- Name: event_pricing_group_discounts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_pricing_group_discounts (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_pricing_id uuid NOT NULL,
    discount_name character varying(100) NOT NULL,
    min_quantity integer NOT NULL,
    max_quantity integer,
    discount_type character varying(20) NOT NULL,
    discount_value numeric(10,4) NOT NULL,
    max_discount_amount numeric(10,2),
    applies_to_tiers uuid[],
    requires_approval boolean DEFAULT false,
    approval_threshold numeric(10,2),
    valid_from timestamp with time zone,
    valid_until timestamp with time zone,
    usage_limit integer,
    times_used integer DEFAULT 0,
    is_active boolean DEFAULT true,
    created_by uuid,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_group_discount_dates CHECK (((valid_until IS NULL) OR (valid_until > valid_from))),
    CONSTRAINT chk_group_usage_limit CHECK (((usage_limit IS NULL) OR (times_used <= usage_limit))),
    CONSTRAINT event_pricing_group_discounts_check CHECK ((max_quantity >= min_quantity)),
    CONSTRAINT event_pricing_group_discounts_discount_type_check CHECK (((discount_type)::text = ANY (ARRAY[('PERCENTAGE'::character varying)::text, ('FIXED_AMOUNT'::character varying)::text, ('TIERED'::character varying)::text]))),
    CONSTRAINT event_pricing_group_discounts_min_quantity_check CHECK ((min_quantity > 1))
);



--
-- Name: TABLE event_pricing_group_discounts; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_pricing_group_discounts IS 'Group discounts and bulk pricing';


--
-- Name: event_pricing_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_pricing_history (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_pricing_id uuid NOT NULL,
    tier_id uuid,
    change_type character varying(30) NOT NULL,
    old_price numeric(10,2),
    new_price numeric(10,2) NOT NULL,
    price_change numeric(10,2),
    percentage_change numeric(8,4),
    reason character varying(500),
    triggered_by character varying(100),
    applied_by uuid,
    effective_from timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    effective_until timestamp with time zone,
    is_active boolean DEFAULT true,
    metadata jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT event_pricing_history_change_type_check CHECK (((change_type)::text = ANY (ARRAY[('PRICE_UPDATE'::character varying)::text, ('DYNAMIC_ADJUSTMENT'::character varying)::text, ('SURGE_APPLIED'::character varying)::text, ('SURGE_REMOVED'::character varying)::text, ('SCHEDULE_APPLIED'::character varying)::text, ('MANUAL_OVERRIDE'::character varying)::text])))
);



--
-- Name: TABLE event_pricing_history; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_pricing_history IS 'Complete history of all pricing changes';


--
-- Name: event_pricing_promo_codes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_pricing_promo_codes (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_pricing_id uuid NOT NULL,
    promo_code character varying(50) NOT NULL,
    discount_type character varying(20) NOT NULL,
    discount_value numeric(10,4) NOT NULL,
    max_discount_amount numeric(10,2),
    min_purchase_amount numeric(10,2),
    applies_to_tiers uuid[],
    usage_limit integer,
    usage_limit_per_customer integer,
    times_used integer DEFAULT 0,
    valid_from timestamp with time zone,
    valid_until timestamp with time zone,
    is_active boolean DEFAULT true,
    is_stackable boolean DEFAULT false,
    requires_minimum_quantity integer DEFAULT 1,
    created_by uuid,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_promo_code_dates CHECK (((valid_until IS NULL) OR (valid_until > valid_from))),
    CONSTRAINT chk_promo_usage_limit CHECK (((usage_limit IS NULL) OR (times_used <= usage_limit))),
    CONSTRAINT event_pricing_promo_codes_discount_type_check CHECK (((discount_type)::text = ANY (ARRAY[('PERCENTAGE'::character varying)::text, ('FIXED_AMOUNT'::character varying)::text, ('FREE_SHIPPING'::character varying)::text, ('BUY_X_GET_Y'::character varying)::text])))
);



--
-- Name: TABLE event_pricing_promo_codes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_pricing_promo_codes IS 'Promotional codes and discount coupons';


--
-- Name: event_pricing_schedules; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_pricing_schedules (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_pricing_id uuid NOT NULL,
    tier_id uuid,
    schedule_name character varying(100) NOT NULL,
    effective_from timestamp with time zone NOT NULL,
    effective_until timestamp with time zone,
    price_change_type character varying(20) NOT NULL,
    change_value numeric(10,4) NOT NULL,
    new_price numeric(10,2),
    reason character varying(200),
    auto_apply boolean DEFAULT true,
    is_applied boolean DEFAULT false,
    applied_at timestamp with time zone,
    created_by uuid,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_schedule_dates CHECK (((effective_until IS NULL) OR (effective_until > effective_from))),
    CONSTRAINT event_pricing_schedules_price_change_type_check CHECK (((price_change_type)::text = ANY (ARRAY[('PERCENTAGE'::character varying)::text, ('FIXED_AMOUNT'::character varying)::text, ('SET_PRICE'::character varying)::text])))
);



--
-- Name: TABLE event_pricing_schedules; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_pricing_schedules IS 'Scheduled price changes based on time';


--
-- Name: event_pricing_surge_thresholds; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_pricing_surge_thresholds (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_pricing_id uuid NOT NULL,
    threshold_name character varying(100) NOT NULL,
    capacity_threshold_percentage numeric(5,2),
    time_threshold_hours integer,
    velocity_threshold_per_hour numeric(8,2),
    surge_multiplier numeric(6,4) NOT NULL,
    max_surge_price numeric(10,2),
    surge_duration interval DEFAULT '01:00:00'::interval,
    cooldown_period interval DEFAULT '00:30:00'::interval,
    applies_to_tiers uuid[],
    is_active boolean DEFAULT true,
    last_triggered timestamp with time zone,
    trigger_count integer DEFAULT 0,
    created_by uuid,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT event_pricing_surge_threshol_capacity_threshold_percentag_check CHECK (((capacity_threshold_percentage >= (0)::numeric) AND (capacity_threshold_percentage <= (100)::numeric))),
    CONSTRAINT event_pricing_surge_threshold_velocity_threshold_per_hour_check CHECK ((velocity_threshold_per_hour >= (0)::numeric)),
    CONSTRAINT event_pricing_surge_thresholds_surge_multiplier_check CHECK ((surge_multiplier >= 1.0000)),
    CONSTRAINT event_pricing_surge_thresholds_time_threshold_hours_check CHECK ((time_threshold_hours >= 0))
);



--
-- Name: TABLE event_pricing_surge_thresholds; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_pricing_surge_thresholds IS 'Surge pricing triggers and thresholds';


--
-- Name: event_pricing_tiers; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_pricing_tiers (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_pricing_id uuid NOT NULL,
    tier_name character varying(50) NOT NULL,
    tier_priority integer DEFAULT 1 NOT NULL,
    tier_description text,
    base_price numeric(10,2) NOT NULL,
    min_price numeric(10,2),
    max_price numeric(10,2),
    capacity_allocation integer,
    tickets_sold integer DEFAULT 0,
    early_bird_price numeric(10,2),
    early_bird_cutoff timestamp with time zone,
    late_price numeric(10,2),
    late_price_start timestamp with time zone,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_tier_early_bird CHECK (((early_bird_cutoff IS NULL) OR (early_bird_price IS NOT NULL))),
    CONSTRAINT chk_tier_late_price CHECK (((late_price_start IS NULL) OR (late_price IS NOT NULL))),
    CONSTRAINT event_pricing_tiers_base_price_check CHECK ((base_price >= (0)::numeric)),
    CONSTRAINT event_pricing_tiers_capacity_allocation_check CHECK ((capacity_allocation > 0)),
    CONSTRAINT event_pricing_tiers_check CHECK ((max_price >= min_price)),
    CONSTRAINT event_pricing_tiers_min_price_check CHECK ((min_price >= (0)::numeric)),
    CONSTRAINT event_pricing_tiers_tickets_sold_check CHECK ((tickets_sold >= 0))
);



--
-- Name: TABLE event_pricing_tiers; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_pricing_tiers IS 'Pricing tiers with different price points and allocations';


--
-- Name: event_production_schedules; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_production_schedules (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_id uuid NOT NULL,
    schedule_name character varying(200) NOT NULL,
    schedule_type character varying(100) NOT NULL,
    schedule_description text,
    scheduled_date date NOT NULL,
    start_time time without time zone NOT NULL,
    end_time time without time zone,
    estimated_duration interval,
    assigned_to character varying(200),
    crew_required integer,
    equipment_needed text[],
    is_critical boolean DEFAULT false NOT NULL,
    completion_status character varying(50) DEFAULT 'pending'::character varying,
    notes text,
    depends_on uuid[],
    blocks uuid[],
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by_user_id uuid,
    CONSTRAINT event_production_valid_crew CHECK (((crew_required IS NULL) OR (crew_required >= 0))),
    CONSTRAINT event_production_valid_times CHECK (((end_time IS NULL) OR (end_time > start_time)))
);



--
-- Name: TABLE event_production_schedules; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_production_schedules IS 'Production timeline and crew scheduling for events';


--
-- Name: event_schedules; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_schedules (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    event_id uuid NOT NULL,
    starts_at timestamp with time zone NOT NULL,
    ends_at timestamp with time zone NOT NULL,
    doors_open_at timestamp with time zone,
    is_recurring boolean DEFAULT false,
    recurrence_rule text,
    recurrence_end_date date,
    occurrence_number integer,
    timezone character varying(50) NOT NULL,
    utc_offset integer,
    status character varying(20) DEFAULT 'SCHEDULED'::character varying,
    status_reason text,
    capacity_override integer,
    check_in_opens_at timestamp with time zone,
    check_in_closes_at timestamp with time zone,
    notes text,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_doors_open CHECK (((doors_open_at IS NULL) OR (doors_open_at <= starts_at))),
    CONSTRAINT valid_schedule_dates CHECK ((ends_at > starts_at)),
    CONSTRAINT valid_schedule_status CHECK (((status)::text = ANY (ARRAY[('SCHEDULED'::character varying)::text, ('CONFIRMED'::character varying)::text, ('IN_PROGRESS'::character varying)::text, ('COMPLETED'::character varying)::text, ('CANCELLED'::character varying)::text, ('POSTPONED'::character varying)::text, ('RESCHEDULED'::character varying)::text])))
);



--
-- Name: TABLE event_schedules; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_schedules IS 'Comprehensive event scheduling with recurring patterns and timing management';


--
-- Name: event_seo_metadata; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_seo_metadata (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_id uuid NOT NULL,
    meta_title character varying(60),
    meta_description character varying(160),
    meta_keywords text,
    canonical_url character varying(500),
    og_title character varying(95),
    og_description character varying(300),
    og_image_url character varying(500),
    og_image_alt text,
    og_type character varying(20) DEFAULT 'event'::character varying,
    twitter_card character varying(20) DEFAULT 'summary_large_image'::character varying,
    twitter_title character varying(70),
    twitter_description character varying(200),
    twitter_image_url character varying(500),
    schema_markup jsonb,
    robots_meta character varying(100) DEFAULT 'index,follow'::character varying,
    lang_code character varying(5) DEFAULT 'en-US'::character varying,
    geo_region character varying(50),
    geo_placename character varying(100),
    geo_position character varying(50),
    priority numeric(2,1) DEFAULT 0.5,
    change_frequency character varying(20) DEFAULT 'weekly'::character varying,
    last_modified timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT event_seo_metadata_change_frequency_check CHECK (((change_frequency)::text = ANY (ARRAY[('always'::character varying)::text, ('hourly'::character varying)::text, ('daily'::character varying)::text, ('weekly'::character varying)::text, ('monthly'::character varying)::text, ('yearly'::character varying)::text, ('never'::character varying)::text]))),
    CONSTRAINT event_seo_metadata_priority_check CHECK (((priority >= 0.0) AND (priority <= 1.0)))
);



--
-- Name: TABLE event_seo_metadata; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_seo_metadata IS 'SEO-specific metadata including meta tags, Open Graph, and schema markup';


--
-- Name: event_sessions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_sessions (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_id uuid NOT NULL,
    session_name character varying(200) NOT NULL,
    session_description text,
    session_type character varying(100),
    session_track character varying(100),
    session_date date NOT NULL,
    start_time time without time zone NOT NULL,
    end_time time without time zone NOT NULL,
    duration interval,
    room_name character varying(100),
    room_capacity integer,
    room_location text,
    learning_objectives text[],
    session_materials jsonb DEFAULT '[]'::jsonb,
    presentation_url text,
    recording_url text,
    equipment_needed text[],
    special_setup text,
    accessibility_notes text,
    is_keynote boolean DEFAULT false NOT NULL,
    requires_registration boolean DEFAULT false NOT NULL,
    max_attendees integer,
    current_registrations integer DEFAULT 0,
    average_rating numeric(3,2),
    total_ratings integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by_user_id uuid,
    CONSTRAINT event_sessions_valid_capacity CHECK (((room_capacity IS NULL) OR (room_capacity > 0))),
    CONSTRAINT event_sessions_valid_rating CHECK (((average_rating IS NULL) OR ((average_rating >= (0)::numeric) AND (average_rating <= (5)::numeric)))),
    CONSTRAINT event_sessions_valid_registrations CHECK (((current_registrations >= 0) AND ((max_attendees IS NULL) OR (current_registrations <= max_attendees)))),
    CONSTRAINT event_sessions_valid_times CHECK ((end_time > start_time))
);



--
-- Name: TABLE event_sessions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_sessions IS 'Multi-session event support for conferences, festivals, and workshops';


--
-- Name: COLUMN event_sessions.session_track; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.event_sessions.session_track IS 'Session grouping: thematic track or category for conferences';


--
-- Name: COLUMN event_sessions.learning_objectives; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.event_sessions.learning_objectives IS 'Educational goals: array of learning outcomes for session';


--
-- Name: COLUMN event_sessions.requires_registration; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.event_sessions.requires_registration IS 'Registration required: separate registration beyond event ticket';


--
-- Name: event_social_media; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_social_media (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    event_id uuid NOT NULL,
    platform character varying(30) NOT NULL,
    platform_event_id character varying(100),
    platform_url character varying(500),
    hashtags text[],
    mentions text[],
    share_count integer DEFAULT 0,
    like_count integer DEFAULT 0,
    comment_count integer DEFAULT 0,
    engagement_rate numeric(5,4) DEFAULT 0,
    reach integer DEFAULT 0,
    impressions integer DEFAULT 0,
    click_through_rate numeric(5,4) DEFAULT 0,
    conversion_rate numeric(5,4) DEFAULT 0,
    campaign_id character varying(100),
    ad_spend numeric(10,2) DEFAULT 0,
    ad_impressions integer DEFAULT 0,
    ad_clicks integer DEFAULT 0,
    pixel_id character varying(100),
    tracking_parameters jsonb,
    auto_post boolean DEFAULT false,
    post_schedule timestamp with time zone,
    last_sync timestamp with time zone,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT event_social_media_platform_check CHECK (((platform)::text = ANY (ARRAY[('FACEBOOK'::character varying)::text, ('TWITTER'::character varying)::text, ('INSTAGRAM'::character varying)::text, ('LINKEDIN'::character varying)::text, ('YOUTUBE'::character varying)::text, ('TIKTOK'::character varying)::text, ('SNAPCHAT'::character varying)::text, ('PINTEREST'::character varying)::text])))
);



--
-- Name: TABLE event_social_media; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_social_media IS 'Social media platform integration data and analytics';


--
-- Name: event_tiers; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_tiers (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    event_id uuid,
    tier_name character varying(100),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: events; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.events (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    venue_id uuid,
    name character varying(255) NOT NULL,
    description text,
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    status public.event_status DEFAULT 'DRAFT'::public.event_status,
    created_by uuid,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    total_tickets integer DEFAULT 0,
    available_tickets integer DEFAULT 0
);



--
-- Name: TABLE events; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.events IS 'Master events table with comprehensive event information and scheduling';


--
-- Name: external_references; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.external_references (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    external_system character varying(100),
    external_id character varying(255),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: failed_login_attempts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.failed_login_attempts (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    user_id uuid,
    ip_address inet,
    attempt_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: feature_flags; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.feature_flags (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    flag_name character varying(100),
    enabled boolean DEFAULT false,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: feedback_responses; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.feedback_responses (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    feedback_id uuid NOT NULL,
    responder_id uuid NOT NULL,
    responder_type character varying(20) NOT NULL,
    responder_name character varying(255),
    response_text text NOT NULL,
    status character varying(20) DEFAULT 'published'::character varying,
    is_official boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_responder_type CHECK (((responder_type)::text = ANY (ARRAY[('venue'::character varying)::text, ('platform'::character varying)::text, ('support'::character varying)::text]))),
    CONSTRAINT chk_response_status CHECK (((status)::text = ANY (ARRAY[('draft'::character varying)::text, ('published'::character varying)::text, ('hidden'::character varying)::text])))
);



--
-- Name: TABLE feedback_responses; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.feedback_responses IS 'Official responses to customer feedback';


--
-- Name: COLUMN feedback_responses.feedback_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.feedback_responses.feedback_id IS 'Feedback being responded to';


--
-- Name: COLUMN feedback_responses.responder_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.feedback_responses.responder_type IS 'Type of responder: venue, platform, support';


--
-- Name: file_access_logs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.file_access_logs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    file_id uuid,
    user_id uuid,
    access_type character varying(50),
    accessed_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: file_versions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.file_versions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    file_id uuid,
    version_number integer NOT NULL,
    storage_path text NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: files; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.files (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    filename character varying(255) NOT NULL,
    size_bytes bigint NOT NULL,
    mime_type character varying(100),
    storage_path text NOT NULL,
    uploader_id uuid,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: financial_reports; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.financial_reports (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    report_type character varying(50) NOT NULL,
    report_period character varying(20) NOT NULL,
    period_start date NOT NULL,
    period_end date NOT NULL,
    gross_revenue bigint DEFAULT 0 NOT NULL,
    refund_amount bigint DEFAULT 0 NOT NULL,
    net_revenue bigint DEFAULT 0 NOT NULL,
    total_transactions integer DEFAULT 0 NOT NULL,
    successful_transactions integer DEFAULT 0 NOT NULL,
    failed_transactions integer DEFAULT 0 NOT NULL,
    platform_fees bigint DEFAULT 0 NOT NULL,
    processing_fees bigint DEFAULT 0 NOT NULL,
    network_fees bigint DEFAULT 0 NOT NULL,
    total_fees bigint GENERATED ALWAYS AS (((platform_fees + processing_fees) + network_fees)) STORED,
    revenue_by_method jsonb DEFAULT '{}'::jsonb,
    transactions_by_method jsonb DEFAULT '{}'::jsonb,
    revenue_by_currency jsonb DEFAULT '{}'::jsonb,
    average_transaction_value bigint,
    average_fee_percentage numeric(5,4),
    new_subscriptions integer DEFAULT 0,
    cancelled_subscriptions integer DEFAULT 0,
    mrr bigint DEFAULT 0,
    arr bigint DEFAULT 0,
    status character varying(50) DEFAULT 'pending'::character varying NOT NULL,
    generated_at timestamp with time zone,
    report_url text,
    report_data jsonb DEFAULT '{}'::jsonb,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_report_period CHECK (((report_period)::text = ANY (ARRAY[('daily'::character varying)::text, ('weekly'::character varying)::text, ('monthly'::character varying)::text, ('quarterly'::character varying)::text, ('yearly'::character varying)::text, ('custom'::character varying)::text]))),
    CONSTRAINT valid_report_status CHECK (((status)::text = ANY (ARRAY[('pending'::character varying)::text, ('generating'::character varying)::text, ('completed'::character varying)::text, ('failed'::character varying)::text]))),
    CONSTRAINT valid_report_type CHECK (((report_type)::text = ANY (ARRAY[('revenue'::character varying)::text, ('transaction'::character varying)::text, ('settlement'::character varying)::text, ('tax'::character varying)::text, ('subscription'::character varying)::text, ('chargeback'::character varying)::text, ('comprehensive'::character varying)::text])))
);



--
-- Name: TABLE financial_reports; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.financial_reports IS 'Comprehensive financial reporting system supporting various report types, periods, and formats. Handles report generation, storage, access control, and distribution with full audit trails.';


--
-- Name: COLUMN financial_reports.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.financial_reports.id IS 'Unique report identifier (UUID)';


--
-- Name: COLUMN financial_reports.report_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.financial_reports.report_type IS 'Frequency/type of report';


--
-- Name: fraud_prevention_rules; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.fraud_prevention_rules (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    rule_name character varying(100) NOT NULL,
    rule_type character varying(50) NOT NULL,
    is_active boolean DEFAULT true,
    severity character varying(20) DEFAULT 'MEDIUM'::character varying,
    conditions jsonb NOT NULL,
    action character varying(50) NOT NULL,
    action_parameters jsonb DEFAULT '{}'::jsonb,
    triggers_count integer DEFAULT 0,
    false_positive_count integer DEFAULT 0,
    last_triggered_at timestamp with time zone,
    description text,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_action CHECK (((action)::text = ANY (ARRAY[('BLOCK'::character varying)::text, ('FLAG_REVIEW'::character varying)::text, ('REQUIRE_VERIFICATION'::character varying)::text, ('LIMIT_FEATURES'::character varying)::text, ('NOTIFY_ADMIN'::character varying)::text, ('AUTO_DELIST'::character varying)::text]))),
    CONSTRAINT valid_rule_type CHECK (((rule_type)::text = ANY (ARRAY[('PRICE_MANIPULATION'::character varying)::text, ('VELOCITY'::character varying)::text, ('GEOGRAPHIC'::character varying)::text, ('PAYMENT'::character varying)::text, ('USER_BEHAVIOR'::character varying)::text, ('LISTING_PATTERN'::character varying)::text, ('TRANSACTION_PATTERN'::character varying)::text]))),
    CONSTRAINT valid_severity CHECK (((severity)::text = ANY (ARRAY[('LOW'::character varying)::text, ('MEDIUM'::character varying)::text, ('HIGH'::character varying)::text, ('CRITICAL'::character varying)::text])))
);



--
-- Name: gas_fee_tracking; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.gas_fee_tracking (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    transaction_id uuid NOT NULL,
    base_fee_lamports bigint DEFAULT 5000 NOT NULL,
    priority_fee_lamports bigint DEFAULT 0,
    total_fee_lamports bigint NOT NULL,
    compute_units_requested integer,
    compute_units_consumed integer,
    compute_unit_price bigint,
    estimated_fee bigint,
    actual_fee bigint NOT NULL,
    fee_difference bigint GENERATED ALWAYS AS ((actual_fee - estimated_fee)) STORED,
    network_congestion_level character varying(20) DEFAULT 'NORMAL'::character varying,
    slot_average_fee bigint,
    percentile_rank integer,
    fee_payer_wallet character varying(44),
    subsidized boolean DEFAULT false,
    subsidy_amount bigint DEFAULT 0,
    transaction_size_bytes integer,
    accounts_count integer,
    instructions_count integer,
    priority character varying(20) DEFAULT 'MEDIUM'::character varying,
    custom_priority_rate bigint,
    optimized boolean DEFAULT false,
    optimization_savings bigint DEFAULT 0,
    optimization_method character varying(50),
    failed_attempts integer DEFAULT 0,
    total_failed_fees bigint DEFAULT 0,
    confirmation_time_ms integer,
    blocks_to_confirm integer,
    hourly_average bigint,
    daily_average bigint,
    weekly_average bigint,
    reimbursable boolean DEFAULT false,
    reimbursed boolean DEFAULT false,
    reimbursement_tx character varying(88),
    cost_per_ticket numeric(20,8),
    roi_percentage numeric(6,2),
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_congestion CHECK (((network_congestion_level)::text = ANY (ARRAY[('LOW'::character varying)::text, ('NORMAL'::character varying)::text, ('HIGH'::character varying)::text, ('CRITICAL'::character varying)::text]))),
    CONSTRAINT valid_priority CHECK (((priority)::text = ANY (ARRAY[('LOW'::character varying)::text, ('MEDIUM'::character varying)::text, ('HIGH'::character varying)::text, ('TURBO'::character varying)::text])))
);



--
-- Name: TABLE gas_fee_tracking; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.gas_fee_tracking IS 'Tracks all transaction fees on Solana with detailed analytics for optimization';


--
-- Name: COLUMN gas_fee_tracking.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.id IS 'Unique identifier for the fee record';


--
-- Name: COLUMN gas_fee_tracking.transaction_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.transaction_id IS 'Reference to the blockchain transaction';


--
-- Name: COLUMN gas_fee_tracking.base_fee_lamports; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.base_fee_lamports IS 'Base transaction fee in lamports (usually 5000)';


--
-- Name: COLUMN gas_fee_tracking.priority_fee_lamports; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.priority_fee_lamports IS 'Additional priority fee paid';


--
-- Name: COLUMN gas_fee_tracking.total_fee_lamports; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.total_fee_lamports IS 'Total fee paid (base + priority)';


--
-- Name: COLUMN gas_fee_tracking.compute_units_requested; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.compute_units_requested IS 'Compute units requested for the transaction';


--
-- Name: COLUMN gas_fee_tracking.compute_units_consumed; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.compute_units_consumed IS 'Actual compute units consumed';


--
-- Name: COLUMN gas_fee_tracking.compute_unit_price; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.compute_unit_price IS 'Price per compute unit in micro-lamports';


--
-- Name: COLUMN gas_fee_tracking.estimated_fee; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.estimated_fee IS 'Fee estimated before submission';


--
-- Name: COLUMN gas_fee_tracking.actual_fee; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.actual_fee IS 'Actual fee charged by the network';


--
-- Name: COLUMN gas_fee_tracking.fee_difference; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.fee_difference IS 'Difference between actual and estimated (computed)';


--
-- Name: COLUMN gas_fee_tracking.network_congestion_level; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.network_congestion_level IS 'Network congestion state at transaction time';


--
-- Name: COLUMN gas_fee_tracking.slot_average_fee; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.slot_average_fee IS 'Average fee in the slot when transaction was processed';


--
-- Name: COLUMN gas_fee_tracking.percentile_rank; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.percentile_rank IS 'Fee percentile ranking (0-100)';


--
-- Name: COLUMN gas_fee_tracking.fee_payer_wallet; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.fee_payer_wallet IS 'Wallet address that paid the transaction fee';


--
-- Name: COLUMN gas_fee_tracking.subsidized; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.subsidized IS 'Whether the fee was subsidized by the platform';


--
-- Name: COLUMN gas_fee_tracking.subsidy_amount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.subsidy_amount IS 'Amount of fee subsidized in lamports';


--
-- Name: COLUMN gas_fee_tracking.transaction_size_bytes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.transaction_size_bytes IS 'Size of the transaction in bytes';


--
-- Name: COLUMN gas_fee_tracking.accounts_count; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.accounts_count IS 'Number of accounts involved in transaction';


--
-- Name: COLUMN gas_fee_tracking.instructions_count; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.instructions_count IS 'Number of instructions in transaction';


--
-- Name: COLUMN gas_fee_tracking.priority; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.priority IS 'Priority level of the transaction';


--
-- Name: COLUMN gas_fee_tracking.custom_priority_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.custom_priority_rate IS 'Custom priority fee rate if non-standard';


--
-- Name: COLUMN gas_fee_tracking.optimized; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.optimized IS 'Whether fee optimization was applied';


--
-- Name: COLUMN gas_fee_tracking.optimization_savings; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.optimization_savings IS 'Lamports saved through optimization';


--
-- Name: COLUMN gas_fee_tracking.optimization_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.optimization_method IS 'Method used for fee optimization';


--
-- Name: COLUMN gas_fee_tracking.failed_attempts; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.failed_attempts IS 'Number of failed submission attempts';


--
-- Name: COLUMN gas_fee_tracking.total_failed_fees; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.total_failed_fees IS 'Total fees lost to failed attempts';


--
-- Name: COLUMN gas_fee_tracking.confirmation_time_ms; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.confirmation_time_ms IS 'Time to confirmation in milliseconds';


--
-- Name: COLUMN gas_fee_tracking.blocks_to_confirm; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.blocks_to_confirm IS 'Number of blocks until confirmation';


--
-- Name: COLUMN gas_fee_tracking.hourly_average; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.hourly_average IS 'Average network fee in the hour';


--
-- Name: COLUMN gas_fee_tracking.daily_average; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.daily_average IS 'Average network fee in the day';


--
-- Name: COLUMN gas_fee_tracking.weekly_average; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.weekly_average IS 'Average network fee in the week';


--
-- Name: COLUMN gas_fee_tracking.reimbursable; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.reimbursable IS 'Whether fee is eligible for reimbursement';


--
-- Name: COLUMN gas_fee_tracking.reimbursed; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.reimbursed IS 'Whether fee has been reimbursed';


--
-- Name: COLUMN gas_fee_tracking.reimbursement_tx; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.reimbursement_tx IS 'Transaction signature of reimbursement';


--
-- Name: COLUMN gas_fee_tracking.cost_per_ticket; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.cost_per_ticket IS 'Transaction fee cost per ticket in SOL';


--
-- Name: COLUMN gas_fee_tracking.roi_percentage; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.roi_percentage IS 'Return on investment percentage';


--
-- Name: COLUMN gas_fee_tracking.created_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.created_at IS 'Timestamp when this record was created';


--
-- Name: COLUMN gas_fee_tracking.updated_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.gas_fee_tracking.updated_at IS 'Timestamp when this record was last updated';


--
-- Name: gdpr_deletion_requests; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.gdpr_deletion_requests (
    id integer NOT NULL,
    customer_id character varying(255) NOT NULL,
    requested_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    processed_at timestamp without time zone,
    status character varying(50) DEFAULT 'pending'::character varying,
    deletion_report json
);



--
-- Name: gdpr_deletion_requests_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.gdpr_deletion_requests_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;



--
-- Name: gdpr_deletion_requests_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.gdpr_deletion_requests_id_seq OWNED BY public.gdpr_deletion_requests.id;


--
-- Name: health_checks; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.health_checks (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    service_name character varying(100),
    status character varying(50),
    response_time integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: idempotency_keys; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.idempotency_keys (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    key character varying(255) NOT NULL,
    response jsonb,
    expires_at timestamp without time zone,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: image_metadata; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.image_metadata (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    file_id uuid,
    width integer,
    height integer,
    format character varying(50),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: integration_data_mappings; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.integration_data_mappings (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    integration_id uuid NOT NULL,
    mapping_name character varying(200) NOT NULL,
    mapping_description text,
    data_entity character varying(100) NOT NULL,
    mapping_direction character varying(20) DEFAULT 'bidirectional'::character varying NOT NULL,
    source_fields jsonb DEFAULT '{}'::jsonb NOT NULL,
    target_fields jsonb DEFAULT '{}'::jsonb NOT NULL,
    field_transformations jsonb DEFAULT '{}'::jsonb,
    validation_rules jsonb DEFAULT '{}'::jsonb,
    required_fields text[],
    default_values jsonb DEFAULT '{}'::jsonb,
    is_active boolean DEFAULT true NOT NULL,
    sync_frequency public.sync_frequency DEFAULT 'manual'::public.sync_frequency,
    batch_size integer DEFAULT 100,
    error_handling_strategy character varying(50) DEFAULT 'skip'::character varying,
    continue_on_error boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by_user_id uuid,
    CONSTRAINT integration_data_mappings_valid_batch_size CHECK ((batch_size > 0)),
    CONSTRAINT integration_data_mappings_valid_direction CHECK (((mapping_direction)::text = ANY (ARRAY[('inbound'::character varying)::text, ('outbound'::character varying)::text, ('bidirectional'::character varying)::text])))
);



--
-- Name: TABLE integration_data_mappings; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.integration_data_mappings IS 'Data field mappings and transformations between systems';


--
-- Name: integration_logs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.integration_logs (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    integration_id uuid NOT NULL,
    venue_id uuid NOT NULL,
    webhook_id uuid,
    log_level character varying(20) DEFAULT 'info'::character varying NOT NULL,
    log_type character varying(50) NOT NULL,
    log_message text NOT NULL,
    request_id character varying(100),
    http_method character varying(10),
    endpoint_url text,
    request_headers jsonb,
    request_body text,
    response_status integer,
    response_headers jsonb,
    response_body text,
    response_time_ms integer,
    error_code character varying(100),
    error_category character varying(100),
    error_details jsonb,
    stack_trace text,
    sync_operation character varying(100),
    records_processed integer,
    records_succeeded integer,
    records_failed integer,
    sync_duration_ms integer,
    retry_attempt integer DEFAULT 0,
    is_retry boolean DEFAULT false NOT NULL,
    original_log_id uuid,
    user_id uuid,
    session_id uuid,
    correlation_id character varying(100),
    additional_context jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT integration_logs_valid_records CHECK (((records_processed IS NULL) OR ((records_processed >= 0) AND (records_succeeded >= 0) AND (records_failed >= 0) AND (records_processed >= (records_succeeded + records_failed))))),
    CONSTRAINT integration_logs_valid_response_time CHECK (((response_time_ms IS NULL) OR (response_time_ms >= 0))),
    CONSTRAINT integration_logs_valid_retry CHECK ((retry_attempt >= 0))
);



--
-- Name: TABLE integration_logs; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.integration_logs IS 'Comprehensive logging for integration activities, errors, and performance';


--
-- Name: COLUMN integration_logs.sync_operation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.integration_logs.sync_operation IS 'Sync operation: type of synchronization operation performed';


--
-- Name: COLUMN integration_logs.records_processed; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.integration_logs.records_processed IS 'Records processed: number of data records processed in operation';


--
-- Name: COLUMN integration_logs.correlation_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.integration_logs.correlation_id IS 'Correlation ID: identifier for tracing related log entries';


--
-- Name: COLUMN integration_logs.additional_context; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.integration_logs.additional_context IS 'Additional context: extra metadata for log entry';


--
-- Name: integration_mappings; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.integration_mappings (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    source_system character varying(100),
    target_system character varying(100),
    mapping_config jsonb,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: integration_schedules; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.integration_schedules (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    integration_id uuid NOT NULL,
    schedule_name character varying(200) NOT NULL,
    schedule_description text,
    sync_frequency public.sync_frequency NOT NULL,
    custom_cron_expression character varying(100),
    start_time time without time zone,
    end_time time without time zone,
    timezone character varying(100) DEFAULT 'UTC'::character varying,
    effective_from timestamp with time zone DEFAULT now(),
    effective_until timestamp with time zone,
    excluded_dates date[],
    data_entities text[],
    sync_direction character varying(20) DEFAULT 'bidirectional'::character varying,
    full_sync boolean DEFAULT false NOT NULL,
    is_enabled boolean DEFAULT true NOT NULL,
    last_run_at timestamp with time zone,
    next_run_at timestamp with time zone,
    last_run_status character varying(50),
    last_run_duration_ms integer,
    total_runs integer DEFAULT 0,
    successful_runs integer DEFAULT 0,
    failed_runs integer DEFAULT 0,
    average_duration_ms integer,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by_user_id uuid,
    CONSTRAINT integration_schedules_valid_dates CHECK (((effective_until IS NULL) OR (effective_until > effective_from))),
    CONSTRAINT integration_schedules_valid_direction CHECK (((sync_direction)::text = ANY (ARRAY[('inbound'::character varying)::text, ('outbound'::character varying)::text, ('bidirectional'::character varying)::text]))),
    CONSTRAINT integration_schedules_valid_runs CHECK (((total_runs >= 0) AND (successful_runs >= 0) AND (failed_runs >= 0) AND (total_runs >= (successful_runs + failed_runs)))),
    CONSTRAINT integration_schedules_valid_times CHECK (((start_time IS NULL) OR (end_time IS NULL) OR (start_time <= end_time)))
);



--
-- Name: TABLE integration_schedules; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.integration_schedules IS 'Scheduled sync jobs and automation for integrations';


--
-- Name: integration_webhooks; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.integration_webhooks (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    integration_id uuid NOT NULL,
    venue_id uuid NOT NULL,
    webhook_name character varying(200) NOT NULL,
    webhook_purpose text,
    webhook_url text NOT NULL,
    webhook_method character varying(10) DEFAULT 'POST'::character varying,
    webhook_secret_encrypted bytea,
    verification_token_encrypted bytea,
    subscribed_events text[] DEFAULT '{}'::text[],
    event_filters jsonb DEFAULT '{}'::jsonb,
    payload_format character varying(50) DEFAULT 'json'::character varying,
    custom_headers jsonb DEFAULT '{}'::jsonb,
    authentication_headers_encrypted bytea,
    content_type character varying(100) DEFAULT 'application/json'::character varying,
    webhook_status public.webhook_status DEFAULT 'pending_verification'::public.webhook_status NOT NULL,
    is_verified boolean DEFAULT false NOT NULL,
    verification_attempts integer DEFAULT 0,
    last_verification_at timestamp with time zone,
    total_deliveries integer DEFAULT 0,
    successful_deliveries integer DEFAULT 0,
    failed_deliveries integer DEFAULT 0,
    last_delivery_at timestamp with time zone,
    last_successful_delivery_at timestamp with time zone,
    average_response_time_ms integer,
    last_response_status integer,
    last_response_body text,
    last_response_headers jsonb,
    consecutive_failures integer DEFAULT 0,
    max_failures_before_disable integer DEFAULT 10,
    failure_backoff_seconds integer DEFAULT 300,
    delivery_rate_limit integer,
    delivery_rate_period interval DEFAULT '00:01:00'::interval,
    retry_enabled boolean DEFAULT true NOT NULL,
    max_retry_attempts integer DEFAULT 3,
    retry_intervals integer[] DEFAULT '{60,300,900}'::integer[],
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by_user_id uuid,
    CONSTRAINT integration_webhooks_valid_deliveries CHECK (((total_deliveries >= 0) AND (successful_deliveries >= 0) AND (failed_deliveries >= 0) AND (total_deliveries >= (successful_deliveries + failed_deliveries)))),
    CONSTRAINT integration_webhooks_valid_failures CHECK (((consecutive_failures >= 0) AND (max_failures_before_disable > 0))),
    CONSTRAINT integration_webhooks_valid_method CHECK (((webhook_method)::text = ANY (ARRAY[('GET'::character varying)::text, ('POST'::character varying)::text, ('PUT'::character varying)::text, ('PATCH'::character varying)::text, ('DELETE'::character varying)::text])))
);



--
-- Name: TABLE integration_webhooks; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.integration_webhooks IS 'Webhook configuration and delivery tracking for real-time integrations';


--
-- Name: COLUMN integration_webhooks.webhook_secret_encrypted; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.integration_webhooks.webhook_secret_encrypted IS 'Webhook secret: encrypted secret for webhook verification';


--
-- Name: COLUMN integration_webhooks.subscribed_events; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.integration_webhooks.subscribed_events IS 'Event subscriptions: array of events to receive notifications for';


--
-- Name: COLUMN integration_webhooks.delivery_rate_limit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.integration_webhooks.delivery_rate_limit IS 'Delivery rate limit: maximum webhook deliveries per time period';


--
-- Name: COLUMN integration_webhooks.retry_intervals; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.integration_webhooks.retry_intervals IS 'Retry intervals: array of retry delays in seconds';


--
-- Name: international_fees; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.international_fees (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    country_code character varying(2),
    fee_percentage numeric(5,2),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: invoices; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoices (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    user_id uuid NOT NULL,
    subscription_id uuid,
    invoice_number character varying(50) NOT NULL,
    status character varying(50) DEFAULT 'draft'::character varying NOT NULL,
    issue_date date DEFAULT CURRENT_DATE NOT NULL,
    due_date date NOT NULL,
    payment_date date,
    subtotal bigint NOT NULL,
    tax_amount bigint DEFAULT 0,
    discount_amount bigint DEFAULT 0,
    total_amount bigint GENERATED ALWAYS AS (((subtotal + tax_amount) - discount_amount)) STORED,
    amount_paid bigint DEFAULT 0,
    amount_due bigint GENERATED ALWAYS AS ((((subtotal + tax_amount) - discount_amount) - amount_paid)) STORED,
    currency character varying(10) DEFAULT 'USD'::character varying NOT NULL,
    line_items jsonb DEFAULT '[]'::jsonb NOT NULL,
    tax_rate numeric(5,4),
    tax_id character varying(50),
    payment_method_id uuid,
    transaction_id uuid,
    provider_invoice_id text,
    provider_invoice_url text,
    pdf_url text,
    pdf_generated_at timestamp with time zone,
    notes text,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_invoice_status CHECK (((status)::text = ANY (ARRAY[('draft'::character varying)::text, ('open'::character varying)::text, ('paid'::character varying)::text, ('void'::character varying)::text, ('uncollectible'::character varying)::text])))
);



--
-- Name: TABLE invoices; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.invoices IS 'Comprehensive invoice management for subscriptions, one-time charges, and settlements. Handles full invoice lifecycle from draft to payment with tax compliance and accounting integration.';


--
-- Name: COLUMN invoices.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.id IS 'Unique invoice identifier (UUID)';


--
-- Name: COLUMN invoices.invoice_number; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.invoice_number IS 'Sequential invoice number (auto-generated)';


--
-- Name: COLUMN invoices.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.status IS 'Current invoice status in payment lifecycle';


--
-- Name: COLUMN invoices.due_date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.due_date IS 'Payment due date';


--
-- Name: COLUMN invoices.line_items; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.line_items IS 'JSON array of invoice line items with pricing details';


--
-- Name: COLUMN invoices.pdf_url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.pdf_url IS 'Generated PDF invoice URL';


--
-- Name: irs_filings; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.irs_filings (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    filing_type character varying(50),
    filing_date date,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: job_executions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.job_executions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    job_id uuid,
    started_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    completed_at timestamp without time zone,
    status character varying(50),
    error_message text
);



--
-- Name: kyc_records; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.kyc_records (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    user_id uuid,
    verification_status character varying(50),
    verified_at timestamp without time zone,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: layout_accessibility_features; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.layout_accessibility_features (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    layout_id uuid NOT NULL,
    feature_type character varying(100) NOT NULL,
    feature_name character varying(200) NOT NULL,
    feature_description text,
    location_type character varying(50) NOT NULL,
    section_id uuid,
    coordinates jsonb,
    compliance_standards text[],
    capacity integer,
    dimensions jsonb,
    is_available boolean DEFAULT true NOT NULL,
    maintenance_required boolean DEFAULT false NOT NULL,
    inspection_due_date date,
    documentation_url text,
    certification_date date,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT layout_accessibility_valid_capacity CHECK (((capacity IS NULL) OR (capacity >= 0)))
);



--
-- Name: TABLE layout_accessibility_features; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.layout_accessibility_features IS 'Detailed accessibility feature mapping for ADA compliance';


--
-- Name: layout_pricing_zones; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.layout_pricing_zones (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    layout_id uuid NOT NULL,
    venue_id uuid NOT NULL,
    zone_name character varying(100) NOT NULL,
    zone_code character varying(20) NOT NULL,
    zone_description text,
    pricing_tier public.pricing_tier NOT NULL,
    base_price numeric(10,2) NOT NULL,
    min_price numeric(10,2),
    max_price numeric(10,2),
    zone_boundaries jsonb,
    included_sections uuid[],
    included_seats uuid[],
    excluded_seats uuid[],
    dynamic_pricing_enabled boolean DEFAULT false NOT NULL,
    pricing_rules jsonb DEFAULT '{}'::jsonb,
    peak_multiplier numeric(4,2) DEFAULT 1.0,
    off_peak_multiplier numeric(4,2) DEFAULT 1.0,
    included_amenities text[],
    special_features text[],
    food_beverage_included boolean DEFAULT false NOT NULL,
    parking_included boolean DEFAULT false NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    requires_membership boolean DEFAULT false NOT NULL,
    advance_booking_required boolean DEFAULT false NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT layout_pricing_zones_valid_multipliers CHECK (((peak_multiplier > (0)::numeric) AND (off_peak_multiplier > (0)::numeric))),
    CONSTRAINT layout_pricing_zones_valid_prices CHECK (((base_price >= (0)::numeric) AND ((min_price IS NULL) OR (min_price >= (0)::numeric)) AND ((max_price IS NULL) OR (max_price >= min_price)) AND ((min_price IS NULL) OR (base_price >= min_price)) AND ((max_price IS NULL) OR (base_price <= max_price))))
);



--
-- Name: TABLE layout_pricing_zones; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.layout_pricing_zones IS 'Pricing zone definitions for dynamic and tiered pricing';


--
-- Name: layout_seats; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.layout_seats (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    section_id uuid NOT NULL,
    layout_id uuid NOT NULL,
    venue_id uuid NOT NULL,
    seat_number character varying(20) NOT NULL,
    row_identifier character varying(20) NOT NULL,
    seat_code character varying(50),
    seat_type public.seat_type DEFAULT 'standard'::public.seat_type NOT NULL,
    is_accessible boolean DEFAULT false NOT NULL,
    is_companion boolean DEFAULT false NOT NULL,
    is_removable boolean DEFAULT false NOT NULL,
    is_obstructed boolean DEFAULT false NOT NULL,
    seat_position jsonb,
    seat_orientation numeric(6,2),
    aisle_proximity character varying(20),
    seat_width numeric(6,2),
    seat_depth numeric(6,2),
    seat_height numeric(6,2),
    leg_room numeric(6,2),
    has_back boolean DEFAULT true NOT NULL,
    has_armrests boolean DEFAULT true NOT NULL,
    has_cup_holder boolean DEFAULT false NOT NULL,
    has_cushion boolean DEFAULT true NOT NULL,
    is_foldable boolean DEFAULT false NOT NULL,
    viewing_angle numeric(6,2),
    stage_distance numeric(8,2),
    elevation numeric(8,2),
    sightline_quality character varying(50) DEFAULT 'good'::character varying,
    pricing_tier public.pricing_tier DEFAULT 'general_admission'::public.pricing_tier,
    base_price numeric(10,2),
    premium_multiplier numeric(4,2) DEFAULT 1.0,
    is_active boolean DEFAULT true NOT NULL,
    is_saleable boolean DEFAULT true NOT NULL,
    is_blocked boolean DEFAULT false NOT NULL,
    block_reason text,
    condition_rating integer DEFAULT 5,
    maintenance_notes text,
    last_inspection_date date,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT layout_seats_valid_condition CHECK (((condition_rating >= 1) AND (condition_rating <= 5))),
    CONSTRAINT layout_seats_valid_dimensions CHECK ((((seat_width IS NULL) OR (seat_width > (0)::numeric)) AND ((seat_depth IS NULL) OR (seat_depth > (0)::numeric)) AND ((seat_height IS NULL) OR (seat_height > (0)::numeric)) AND ((leg_room IS NULL) OR (leg_room >= (0)::numeric)))),
    CONSTRAINT layout_seats_valid_multiplier CHECK ((premium_multiplier > (0)::numeric))
);



--
-- Name: TABLE layout_seats; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.layout_seats IS 'Individual seat/position mapping with detailed properties and accessibility';


--
-- Name: COLUMN layout_seats.seat_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.layout_seats.seat_code IS 'Unique seat identifier: automatically generated section-row-seat code';


--
-- Name: COLUMN layout_seats.seat_position; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.layout_seats.seat_position IS 'Seat coordinates: 3D position data (x, y, z) for precise seat mapping';


--
-- Name: COLUMN layout_seats.aisle_proximity; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.layout_seats.aisle_proximity IS 'Aisle access: proximity to aisle (left, right, none) for accessibility';


--
-- Name: COLUMN layout_seats.sightline_quality; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.layout_seats.sightline_quality IS 'Sightline rating: quality assessment of view from this specific seat';


--
-- Name: COLUMN layout_seats.premium_multiplier; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.layout_seats.premium_multiplier IS 'Price multiplier: factor applied to base price for premium positioning';


--
-- Name: layout_sections; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.layout_sections (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    layout_id uuid NOT NULL,
    venue_id uuid NOT NULL,
    section_name character varying(100) NOT NULL,
    section_code character varying(20) NOT NULL,
    section_type public.section_type NOT NULL,
    parent_section_id uuid,
    section_level integer DEFAULT 1 NOT NULL,
    display_order integer DEFAULT 0 NOT NULL,
    section_capacity integer DEFAULT 0 NOT NULL,
    available_seats integer,
    wheelchair_seats integer DEFAULT 0 NOT NULL,
    companion_seats integer DEFAULT 0 NOT NULL,
    section_position jsonb,
    section_boundaries jsonb,
    row_configuration jsonb DEFAULT '{}'::jsonb,
    has_numbering boolean DEFAULT true NOT NULL,
    numbering_scheme character varying(50) DEFAULT 'numeric'::character varying,
    row_numbering_scheme character varying(50) DEFAULT 'numeric'::character varying,
    pricing_tier public.pricing_tier DEFAULT 'general_admission'::public.pricing_tier,
    base_price numeric(10,2),
    requires_special_access boolean DEFAULT false NOT NULL,
    access_restrictions text[],
    has_backs boolean DEFAULT true NOT NULL,
    has_armrests boolean DEFAULT true NOT NULL,
    has_cup_holders boolean DEFAULT false NOT NULL,
    is_covered boolean DEFAULT true NOT NULL,
    climate_controlled boolean DEFAULT false NOT NULL,
    view_quality character varying(50) DEFAULT 'good'::character varying,
    stage_distance_min numeric(8,2),
    stage_distance_max numeric(8,2),
    elevation_angle numeric(6,2),
    is_active boolean DEFAULT true NOT NULL,
    is_saleable boolean DEFAULT true NOT NULL,
    maintenance_notes text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT layout_sections_no_self_parent CHECK ((parent_section_id <> id)),
    CONSTRAINT layout_sections_valid_accessible CHECK (((wheelchair_seats >= 0) AND (companion_seats >= 0) AND (wheelchair_seats <= section_capacity))),
    CONSTRAINT layout_sections_valid_capacity CHECK ((section_capacity >= 0)),
    CONSTRAINT layout_sections_valid_level CHECK ((section_level > 0))
);



--
-- Name: TABLE layout_sections; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.layout_sections IS 'Individual sections within venue layouts (VIP, general, balcony, etc.)';


--
-- Name: COLUMN layout_sections.section_boundaries; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.layout_sections.section_boundaries IS 'Section boundaries: coordinate data defining section perimeter';


--
-- Name: COLUMN layout_sections.row_configuration; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.layout_sections.row_configuration IS 'Row layout: configuration data for seat arrangements within section';


--
-- Name: COLUMN layout_sections.view_quality; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.layout_sections.view_quality IS 'View quality rating: subjective assessment of sightlines from section';


--
-- Name: COLUMN layout_sections.stage_distance_min; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.layout_sections.stage_distance_min IS 'Minimum stage distance: closest point in section to performance area';


--
-- Name: listings; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.listings (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    ticket_id uuid NOT NULL,
    seller_id uuid NOT NULL,
    status character varying(50) DEFAULT 'ACTIVE'::character varying NOT NULL,
    listing_type character varying(50) DEFAULT 'FIXED_PRICE'::character varying,
    price numeric(10,2) NOT NULL,
    currency character varying(10) DEFAULT 'USD'::character varying,
    original_price numeric(10,2),
    min_price numeric(10,2),
    max_price numeric(10,2),
    price_cap_percentage numeric(5,2) DEFAULT 200,
    auto_price_drop boolean DEFAULT false,
    price_drop_percentage numeric(5,2),
    price_drop_interval_hours integer DEFAULT 24,
    last_price_drop_at timestamp with time zone,
    market_maker_enabled boolean DEFAULT false,
    spread_percentage numeric(5,2) DEFAULT 2.0,
    liquidity_pool_id uuid,
    is_featured boolean DEFAULT false,
    featured_until timestamp with time zone,
    visibility character varying(50) DEFAULT 'PUBLIC'::character varying,
    instant_transfer boolean DEFAULT true,
    transfer_deadline_hours integer DEFAULT 24,
    accepts_offers boolean DEFAULT true,
    view_count integer DEFAULT 0,
    offer_count integer DEFAULT 0,
    price_history jsonb DEFAULT '[]'::jsonb,
    listing_title character varying(200),
    listing_description text,
    tags text[],
    metadata jsonb DEFAULT '{}'::jsonb,
    listed_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    expires_at timestamp with time zone,
    sold_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT price_cap_check CHECK (((original_price IS NULL) OR (price <= (original_price * (price_cap_percentage / 100.0))))),
    CONSTRAINT valid_listing_status CHECK (((status)::text = ANY (ARRAY[('DRAFT'::character varying)::text, ('ACTIVE'::character varying)::text, ('SOLD'::character varying)::text, ('EXPIRED'::character varying)::text, ('CANCELLED'::character varying)::text, ('SUSPENDED'::character varying)::text, ('PENDING_APPROVAL'::character varying)::text]))),
    CONSTRAINT valid_price_limits CHECK ((((min_price IS NULL) OR (price >= min_price)) AND ((max_price IS NULL) OR (price <= max_price))))
);



--
-- Name: loyalty_accounts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.loyalty_accounts (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    user_id uuid,
    points_balance integer DEFAULT 0,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: loyalty_programs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.loyalty_programs (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    name character varying(100) NOT NULL,
    description text,
    terms_and_conditions text,
    is_active boolean DEFAULT true,
    is_default boolean DEFAULT false,
    points_per_dollar numeric(10,4) DEFAULT 1.0000,
    signup_bonus integer DEFAULT 0,
    referral_bonus integer DEFAULT 0,
    points_expire boolean DEFAULT false,
    points_validity_months integer DEFAULT 12,
    tiers jsonb DEFAULT '[{"name": "Bronze", "perks": [], "min_points": 0, "multiplier": 1.0}, {"name": "Silver", "perks": ["priority_support"], "min_points": 1000, "multiplier": 1.25}, {"name": "Gold", "perks": ["priority_support", "early_access"], "min_points": 5000, "multiplier": 1.5}, {"name": "Platinum", "perks": ["priority_support", "early_access", "vip_events"], "min_points": 10000, "multiplier": 2.0}]'::jsonb,
    min_redemption_points integer DEFAULT 100,
    redemption_rate numeric(10,4) DEFAULT 0.01,
    icon_url character varying(500),
    color_scheme jsonb DEFAULT '{"primary": "#8B5CF6", "secondary": "#F59E0B"}'::jsonb,
    marketing_name character varying(100),
    marketing_tagline character varying(200),
    created_by uuid,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_min_redemption_positive CHECK ((min_redemption_points > 0)),
    CONSTRAINT chk_points_per_dollar_positive CHECK ((points_per_dollar > (0)::numeric)),
    CONSTRAINT chk_points_validity_positive CHECK (((points_validity_months IS NULL) OR (points_validity_months > 0))),
    CONSTRAINT chk_redemption_rate_positive CHECK ((redemption_rate > (0)::numeric)),
    CONSTRAINT chk_referral_bonus_non_negative CHECK ((referral_bonus >= 0)),
    CONSTRAINT chk_signup_bonus_non_negative CHECK ((signup_bonus >= 0))
);



--
-- Name: TABLE loyalty_programs; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.loyalty_programs IS 'Master configuration for loyalty programs with point and tier settings';


--
-- Name: COLUMN loyalty_programs.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.loyalty_programs.id IS 'Unique identifier for the loyalty program';


--
-- Name: COLUMN loyalty_programs.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.loyalty_programs.name IS 'Unique program name';


--
-- Name: COLUMN loyalty_programs.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.loyalty_programs.description IS 'Detailed program description for customers';


--
-- Name: COLUMN loyalty_programs.terms_and_conditions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.loyalty_programs.terms_and_conditions IS 'Legal terms and conditions';


--
-- Name: COLUMN loyalty_programs.is_active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.loyalty_programs.is_active IS 'Whether program accepts new members';


--
-- Name: COLUMN loyalty_programs.is_default; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.loyalty_programs.is_default IS 'Default program for auto-enrollment';


--
-- Name: COLUMN loyalty_programs.points_per_dollar; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.loyalty_programs.points_per_dollar IS 'Base earning rate';


--
-- Name: COLUMN loyalty_programs.signup_bonus; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.loyalty_programs.signup_bonus IS 'Points awarded for joining';


--
-- Name: COLUMN loyalty_programs.referral_bonus; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.loyalty_programs.referral_bonus IS 'Points for successful referrals';


--
-- Name: COLUMN loyalty_programs.points_expire; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.loyalty_programs.points_expire IS 'Whether points have expiration';


--
-- Name: COLUMN loyalty_programs.points_validity_months; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.loyalty_programs.points_validity_months IS 'How long points remain valid';


--
-- Name: COLUMN loyalty_programs.tiers; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.loyalty_programs.tiers IS 'JSON array of tier configurations';


--
-- Name: COLUMN loyalty_programs.min_redemption_points; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.loyalty_programs.min_redemption_points IS 'Minimum points to redeem';


--
-- Name: COLUMN loyalty_programs.redemption_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.loyalty_programs.redemption_rate IS 'Dollar value per point';


--
-- Name: loyalty_transactions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.loyalty_transactions (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    account_id uuid,
    points integer,
    transaction_type character varying(50),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: market_analytics; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.market_analytics (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    analytics_type character varying(50) NOT NULL,
    scope_id uuid,
    period character varying(20) NOT NULL,
    period_start timestamp with time zone NOT NULL,
    period_end timestamp with time zone NOT NULL,
    total_listings integer DEFAULT 0,
    total_sales integer DEFAULT 0,
    total_volume numeric(12,2) DEFAULT 0,
    average_price numeric(10,2),
    median_price numeric(10,2),
    price_std_dev numeric(10,2),
    min_price numeric(10,2),
    max_price numeric(10,2),
    active_listings integer DEFAULT 0,
    unique_sellers integer DEFAULT 0,
    unique_buyers integer DEFAULT 0,
    average_time_to_sale interval,
    sell_through_rate numeric(5,2),
    price_change_percentage numeric(5,2),
    volatility_index numeric(5,2),
    calculation_metadata jsonb DEFAULT '{}'::jsonb,
    calculated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_analytics_type CHECK (((analytics_type)::text = ANY (ARRAY[('EVENT'::character varying)::text, ('VENUE'::character varying)::text, ('CATEGORY'::character varying)::text, ('ARTIST'::character varying)::text, ('GLOBAL'::character varying)::text]))),
    CONSTRAINT valid_period CHECK (((period)::text = ANY (ARRAY[('HOURLY'::character varying)::text, ('DAILY'::character varying)::text, ('WEEKLY'::character varying)::text, ('MONTHLY'::character varying)::text, ('QUARTERLY'::character varying)::text, ('YEARLY'::character varying)::text])))
);



--
-- Name: marketplace_transactions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.marketplace_transactions (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    listing_id uuid NOT NULL,
    ticket_id uuid NOT NULL,
    buyer_id uuid NOT NULL,
    seller_id uuid NOT NULL,
    offer_id uuid,
    escrow_id uuid,
    transaction_type character varying(50) DEFAULT 'SALE'::character varying NOT NULL,
    status character varying(50) DEFAULT 'PENDING'::character varying NOT NULL,
    sale_price numeric(10,2) NOT NULL,
    currency character varying(10) DEFAULT 'USD'::character varying,
    platform_fee numeric(10,2) DEFAULT 0,
    platform_fee_percentage numeric(5,2) DEFAULT 5.0,
    payment_processing_fee numeric(10,2) DEFAULT 0,
    blockchain_fee numeric(10,2) DEFAULT 0,
    total_fees numeric(10,2) GENERATED ALWAYS AS (((platform_fee + payment_processing_fee) + blockchain_fee)) STORED,
    seller_payout numeric(10,2) GENERATED ALWAYS AS ((((sale_price - platform_fee) - payment_processing_fee) - blockchain_fee)) STORED,
    transfer_initiated_at timestamp with time zone,
    transfer_completed_at timestamp with time zone,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_transaction_status CHECK (((status)::text = ANY (ARRAY[('PENDING'::character varying)::text, ('PROCESSING'::character varying)::text, ('COMPLETED'::character varying)::text, ('FAILED'::character varying)::text, ('CANCELLED'::character varying)::text, ('DISPUTED'::character varying)::text, ('REFUNDED'::character varying)::text]))),
    CONSTRAINT valid_transaction_type CHECK (((transaction_type)::text = ANY (ARRAY[('SALE'::character varying)::text, ('AUCTION_WIN'::character varying)::text, ('OFFER_ACCEPTED'::character varying)::text, ('INSTANT_BUY'::character varying)::text])))
);



--
-- Name: nft_metadata; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.nft_metadata (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    ticket_id uuid,
    mint_address character varying(44) NOT NULL,
    metadata_uri character varying(500),
    name character varying(200),
    symbol character varying(10),
    description text,
    image_url character varying(500),
    animation_url character varying(500),
    external_url character varying(500),
    is_compressed boolean DEFAULT true,
    tree_address character varying(44),
    leaf_index bigint,
    data_hash character varying(64),
    collection_address character varying(44),
    collection_name character varying(200),
    collection_verified boolean DEFAULT false,
    attributes jsonb DEFAULT '[]'::jsonb,
    creators jsonb DEFAULT '[]'::jsonb,
    seller_fee_basis_points integer DEFAULT 250,
    royalty_recipients jsonb DEFAULT '[]'::jsonb,
    standard character varying(30) DEFAULT 'metaplex'::character varying NOT NULL,
    version character varying(10),
    is_mutable boolean DEFAULT false,
    primary_sale_happened boolean DEFAULT false,
    edition_nonce integer,
    token_standard character varying(20),
    uses jsonb,
    last_synced_at timestamp with time zone,
    sync_status character varying(20) DEFAULT 'PENDING'::character varying,
    cache_expires_at timestamp with time zone,
    force_refresh boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_standard CHECK (((standard)::text = ANY (ARRAY[('metaplex'::character varying)::text, ('metaplex-bubblegum'::character varying)::text]))),
    CONSTRAINT valid_sync_status CHECK (((sync_status)::text = ANY (ARRAY[('PENDING'::character varying)::text, ('SYNCED'::character varying)::text, ('FAILED'::character varying)::text, ('OUTDATED'::character varying)::text])))
);



--
-- Name: TABLE nft_metadata; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.nft_metadata IS 'Caches NFT metadata for ticket tokens, supporting both regular and compressed NFTs';


--
-- Name: COLUMN nft_metadata.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.id IS 'Unique identifier for the metadata record';


--
-- Name: COLUMN nft_metadata.ticket_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.ticket_id IS 'Reference to the ticket this NFT represents';


--
-- Name: COLUMN nft_metadata.mint_address; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.mint_address IS 'Solana mint address of the NFT (base58 encoded)';


--
-- Name: COLUMN nft_metadata.metadata_uri; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.metadata_uri IS 'URI pointing to the metadata JSON file (usually Arweave or IPFS)';


--
-- Name: COLUMN nft_metadata.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.name IS 'Name of the NFT from metadata';


--
-- Name: COLUMN nft_metadata.symbol; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.symbol IS 'Symbol of the NFT from metadata';


--
-- Name: COLUMN nft_metadata.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.description IS 'Description of the NFT from metadata';


--
-- Name: COLUMN nft_metadata.image_url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.image_url IS 'URL to the primary image for the NFT';


--
-- Name: COLUMN nft_metadata.animation_url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.animation_url IS 'URL to animation or video content if applicable';


--
-- Name: COLUMN nft_metadata.external_url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.external_url IS 'External URL for more information about the NFT';


--
-- Name: COLUMN nft_metadata.is_compressed; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.is_compressed IS 'Whether this is a compressed NFT (Metaplex Bubblegum)';


--
-- Name: COLUMN nft_metadata.tree_address; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.tree_address IS 'Merkle tree address for compressed NFTs';


--
-- Name: COLUMN nft_metadata.leaf_index; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.leaf_index IS 'Position of this NFT in the merkle tree';


--
-- Name: COLUMN nft_metadata.data_hash; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.data_hash IS 'Hash of the compressed NFT data';


--
-- Name: COLUMN nft_metadata.collection_address; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.collection_address IS 'Mint address of the collection this NFT belongs to';


--
-- Name: COLUMN nft_metadata.collection_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.collection_name IS 'Name of the collection';


--
-- Name: COLUMN nft_metadata.collection_verified; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.collection_verified IS 'Whether this NFT is verified as part of the collection';


--
-- Name: COLUMN nft_metadata.attributes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.attributes IS 'Array of attributes with trait_type and value';


--
-- Name: COLUMN nft_metadata.creators; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.creators IS 'Array of creators with their addresses and share percentages';


--
-- Name: COLUMN nft_metadata.seller_fee_basis_points; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.seller_fee_basis_points IS 'Royalty percentage in basis points (100 = 1%)';


--
-- Name: COLUMN nft_metadata.royalty_recipients; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.royalty_recipients IS 'Array of addresses that receive royalties';


--
-- Name: COLUMN nft_metadata.standard; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.standard IS 'Metadata standard used (metaplex or metaplex-bubblegum)';


--
-- Name: COLUMN nft_metadata.version; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.version IS 'Version of the metadata standard';


--
-- Name: COLUMN nft_metadata.is_mutable; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.is_mutable IS 'Whether the metadata can be changed after minting';


--
-- Name: COLUMN nft_metadata.primary_sale_happened; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.primary_sale_happened IS 'Whether the first sale has occurred';


--
-- Name: COLUMN nft_metadata.edition_nonce; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.edition_nonce IS 'Nonce for print editions if applicable';


--
-- Name: COLUMN nft_metadata.token_standard; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.token_standard IS 'Token standard type from Metaplex';


--
-- Name: COLUMN nft_metadata.uses; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.uses IS 'Token uses configuration for limited use NFTs';


--
-- Name: COLUMN nft_metadata.last_synced_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.last_synced_at IS 'Last time metadata was successfully synced from chain';


--
-- Name: COLUMN nft_metadata.sync_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.sync_status IS 'Current synchronization status';


--
-- Name: COLUMN nft_metadata.cache_expires_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.cache_expires_at IS 'When the cached data should be refreshed';


--
-- Name: COLUMN nft_metadata.force_refresh; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.force_refresh IS 'Flag to force metadata refresh on next sync';


--
-- Name: COLUMN nft_metadata.created_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.created_at IS 'Timestamp when this record was created';


--
-- Name: COLUMN nft_metadata.updated_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.nft_metadata.updated_at IS 'Timestamp when this record was last updated';


--
-- Name: notification_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.notification_history (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    user_id uuid,
    notification_type character varying(100),
    content text,
    sent_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: notification_preferences; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.notification_preferences (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    user_id uuid,
    channel character varying(50),
    enabled boolean DEFAULT true,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: notification_queue; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.notification_queue (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    type character varying(50) NOT NULL,
    recipient_id uuid NOT NULL,
    data jsonb NOT NULL,
    status character varying(20) DEFAULT 'pending'::character varying,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    processed_at timestamp with time zone
);



--
-- Name: notification_templates; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.notification_templates (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    template_name character varying(100),
    template_content text,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: notifications; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.notifications (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    user_id uuid NOT NULL,
    status character varying(20) DEFAULT 'SENT'::character varying NOT NULL,
    title text,
    body text,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    read_at timestamp with time zone
);



--
-- Name: offers; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.offers (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    listing_id uuid NOT NULL,
    buyer_id uuid NOT NULL,
    offer_amount numeric(10,2) NOT NULL,
    currency character varying(10) DEFAULT 'USD'::character varying,
    status character varying(50) DEFAULT 'PENDING'::character varying NOT NULL,
    expires_at timestamp with time zone DEFAULT (CURRENT_TIMESTAMP + '24:00:00'::interval) NOT NULL,
    buyer_message text,
    seller_response text,
    is_counter_offer boolean DEFAULT false,
    previous_offer_id uuid,
    counter_offer_count integer DEFAULT 0,
    auto_accept_enabled boolean DEFAULT false,
    auto_accept_price numeric(10,2),
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    responded_at timestamp with time zone,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT max_counter_offers CHECK ((counter_offer_count <= 5)),
    CONSTRAINT positive_offer CHECK ((offer_amount > (0)::numeric)),
    CONSTRAINT valid_offer_status CHECK (((status)::text = ANY (ARRAY[('PENDING'::character varying)::text, ('ACCEPTED'::character varying)::text, ('REJECTED'::character varying)::text, ('EXPIRED'::character varying)::text, ('CANCELLED'::character varying)::text, ('COUNTERED'::character varying)::text, ('AUTO_REJECTED'::character varying)::text])))
);



--
-- Name: offline_validation_cache; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.offline_validation_cache (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    ticket_id uuid,
    cached_data jsonb,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: order_items; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.order_items (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    order_id uuid NOT NULL,
    ticket_type_id uuid,
    ticket_id uuid,
    quantity integer DEFAULT 1,
    unit_price numeric(10,2) NOT NULL,
    discount_amount numeric(10,2) DEFAULT 0,
    tax_amount numeric(10,2) DEFAULT 0,
    total_price numeric(10,2) NOT NULL,
    status character varying(50) DEFAULT 'PENDING'::character varying,
    fulfilled_at timestamp without time zone,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT order_items_discount_amount_check CHECK ((discount_amount >= (0)::numeric)),
    CONSTRAINT order_items_quantity_check CHECK ((quantity > 0)),
    CONSTRAINT order_items_tax_amount_check CHECK ((tax_amount >= (0)::numeric)),
    CONSTRAINT order_items_total_price_check CHECK ((total_price >= (0)::numeric)),
    CONSTRAINT order_items_unit_price_check CHECK ((unit_price >= (0)::numeric)),
    CONSTRAINT valid_order_item_status CHECK (((status)::text = ANY (ARRAY[('PENDING'::character varying)::text, ('RESERVED'::character varying)::text, ('PAID'::character varying)::text, ('FULFILLED'::character varying)::text, ('CANCELLED'::character varying)::text, ('REFUNDED'::character varying)::text]))),
    CONSTRAINT valid_price_calculation CHECK ((total_price = (((unit_price * (quantity)::numeric) - discount_amount) + tax_amount)))
);



--
-- Name: TABLE order_items; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.order_items IS 'Individual line items within an order';


--
-- Name: order_state_transitions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.order_state_transitions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    order_id uuid NOT NULL,
    from_status character varying(50),
    to_status character varying(50) NOT NULL,
    reason text,
    error_message text,
    metadata jsonb DEFAULT '{}'::jsonb,
    triggered_by uuid,
    triggered_by_service character varying(100),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_transition_status CHECK (((to_status)::text = ANY (ARRAY[('PENDING'::character varying)::text, ('RESERVED'::character varying)::text, ('PAYMENT_PROCESSING'::character varying)::text, ('PAID'::character varying)::text, ('FULFILLED'::character varying)::text, ('COMPLETED'::character varying)::text, ('CANCELLED'::character varying)::text, ('EXPIRED'::character varying)::text, ('FAILED'::character varying)::text, ('REFUNDED'::character varying)::text, ('PARTIALLY_REFUNDED'::character varying)::text])))
);



--
-- Name: TABLE order_state_transitions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.order_state_transitions IS 'Audit trail of order state changes';


--
-- Name: orders; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.orders (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid,
    event_id uuid,
    status character varying(50) DEFAULT 'pending'::character varying,
    total_amount numeric(10,2),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    order_number character varying(20) NOT NULL,
    expires_at timestamp without time zone,
    customer_email character varying(255),
    customer_phone character varying(20),
    ip_address inet,
    user_agent text
);



--
-- Name: outbox; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.outbox (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    aggregate_type character varying(100) NOT NULL,
    aggregate_id uuid NOT NULL,
    event_type character varying(100) NOT NULL,
    payload jsonb NOT NULL,
    processed boolean DEFAULT false,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: outbox_events; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.outbox_events (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    event_type character varying(100),
    payload jsonb,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: payment_intents; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.payment_intents (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    stripe_intent_id character varying(255),
    amount numeric(10,2) NOT NULL,
    currency character varying(3) DEFAULT 'USD'::character varying,
    status character varying(50),
    user_id uuid,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: payment_methods; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.payment_methods (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    user_id uuid NOT NULL,
    type character varying(50) NOT NULL,
    provider character varying(50),
    payment_token text,
    last_four character varying(4),
    card_brand character varying(20),
    card_type character varying(20),
    account_last_four character varying(4),
    routing_number_encrypted text,
    account_type character varying(20),
    wallet_address character varying(44),
    wallet_type character varying(20),
    network character varying(50),
    billing_name character varying(200),
    billing_email character varying(255),
    billing_phone character varying(20),
    billing_address_line1 character varying(255),
    billing_address_line2 character varying(255),
    billing_city character varying(100),
    billing_state character varying(100),
    billing_postal_code character varying(20),
    billing_country character varying(2),
    is_verified boolean DEFAULT false,
    verified_at timestamp with time zone,
    verification_method character varying(50),
    expiry_month integer,
    expiry_year integer,
    is_active boolean DEFAULT true,
    is_default boolean DEFAULT false,
    nickname character varying(100),
    risk_score integer DEFAULT 0,
    fraud_check_passed boolean,
    requires_3ds boolean DEFAULT true,
    provider_customer_id text,
    provider_payment_method_id text,
    provider_metadata jsonb DEFAULT '{}'::jsonb,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    last_used_at timestamp with time zone,
    CONSTRAINT valid_card_expiry CHECK ((((type)::text <> ALL (ARRAY[('credit_card'::character varying)::text, ('debit_card'::character varying)::text])) OR ((expiry_month >= 1) AND (expiry_month <= 12) AND ((expiry_year)::numeric >= EXTRACT(year FROM CURRENT_DATE))))),
    CONSTRAINT valid_payment_type CHECK (((type)::text = ANY (ARRAY[('credit_card'::character varying)::text, ('debit_card'::character varying)::text, ('bank_account'::character varying)::text, ('crypto'::character varying)::text, ('paypal'::character varying)::text, ('apple_pay'::character varying)::text, ('google_pay'::character varying)::text, ('other'::character varying)::text])))
);



--
-- Name: TABLE payment_methods; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.payment_methods IS 'Stores user payment methods in a PCI-compliant manner. Only tokenized payment data is stored, never raw card numbers. All sensitive data is handled by certified payment providers.';


--
-- Name: COLUMN payment_methods.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_methods.id IS 'Unique identifier for the payment method (UUID)';


--
-- Name: COLUMN payment_methods.user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_methods.user_id IS 'Foreign key to users table - payment method owner';


--
-- Name: COLUMN payment_methods.wallet_address; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_methods.wallet_address IS 'Cryptocurrency wallet address';


--
-- Name: COLUMN payment_methods.wallet_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_methods.wallet_type IS 'Type of crypto wallet';


--
-- Name: COLUMN payment_methods.billing_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_methods.billing_name IS 'Name associated with payment method';


--
-- Name: COLUMN payment_methods.billing_email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_methods.billing_email IS 'Billing email address';


--
-- Name: COLUMN payment_methods.billing_phone; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_methods.billing_phone IS 'Billing phone number';


--
-- Name: COLUMN payment_methods.billing_address_line1; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_methods.billing_address_line1 IS 'Billing street address';


--
-- Name: COLUMN payment_methods.billing_address_line2; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_methods.billing_address_line2 IS 'Billing address line 2';


--
-- Name: COLUMN payment_methods.billing_city; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_methods.billing_city IS 'Billing city';


--
-- Name: COLUMN payment_methods.billing_state; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_methods.billing_state IS 'Billing state/province';


--
-- Name: COLUMN payment_methods.billing_country; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_methods.billing_country IS 'Billing country (ISO code)';


--
-- Name: COLUMN payment_methods.is_verified; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_methods.is_verified IS 'Whether payment method passed verification';


--
-- Name: COLUMN payment_methods.verification_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_methods.verification_method IS 'How verification was performed';


--
-- Name: COLUMN payment_methods.is_default; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_methods.is_default IS 'User default payment method';


--
-- Name: COLUMN payment_methods.nickname; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_methods.nickname IS 'User-friendly name for payment method';


--
-- Name: COLUMN payment_methods.risk_score; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_methods.risk_score IS 'Risk assessment score 0-100';


--
-- Name: COLUMN payment_methods.provider_metadata; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_methods.provider_metadata IS 'Provider-specific data (no sensitive info)';


--
-- Name: COLUMN payment_methods.metadata; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_methods.metadata IS 'Additional metadata as JSONB';


--
-- Name: COLUMN payment_methods.created_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_methods.created_at IS 'When payment method was added';


--
-- Name: COLUMN payment_methods.updated_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_methods.updated_at IS 'Last update timestamp';


--
-- Name: COLUMN payment_methods.last_used_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_methods.last_used_at IS 'Last successful transaction timestamp';


--
-- Name: pci_access_logs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.pci_access_logs (
    id integer NOT NULL,
    user_id character varying(255),
    action character varying(100),
    reason text,
    ip_address character varying(45),
    "timestamp" timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: pci_access_logs_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.pci_access_logs_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;



--
-- Name: pci_access_logs_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.pci_access_logs_id_seq OWNED BY public.pci_access_logs.id;


--
-- Name: ticket_refunds; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ticket_refunds (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    ticket_id uuid NOT NULL,
    transaction_id uuid,
    requested_by_user_id uuid NOT NULL,
    approved_by_user_id uuid,
    original_amount numeric(10,2) NOT NULL,
    refund_amount numeric(10,2) NOT NULL,
    refund_fee numeric(10,2) DEFAULT 0,
    refund_percentage numeric(5,2),
    reason character varying(100) NOT NULL,
    reason_details text,
    status character varying(20) DEFAULT 'REQUESTED'::character varying,
    processed_at timestamp with time zone,
    payment_method character varying(50),
    transaction_reference character varying(100),
    supporting_documents jsonb DEFAULT '[]'::jsonb,
    admin_notes text,
    requested_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_refund_amount CHECK (((refund_amount >= (0)::numeric) AND (refund_amount <= original_amount))),
    CONSTRAINT valid_refund_status CHECK (((status)::text = ANY (ARRAY[('REQUESTED'::character varying)::text, ('REVIEWING'::character varying)::text, ('APPROVED'::character varying)::text, ('PROCESSING'::character varying)::text, ('COMPLETED'::character varying)::text, ('REJECTED'::character varying)::text, ('CANCELLED'::character varying)::text])))
);



--
-- Name: TABLE ticket_refunds; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ticket_refunds IS 'Manages all ticket refund requests and processing. Workflow: requested -> approved -> processing -> completed. Includes policy compliance, financial calculations, and fraud detection.';


--
-- Name: COLUMN ticket_refunds.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_refunds.id IS 'Unique identifier for the refund request (UUID)';


--
-- Name: COLUMN ticket_refunds.ticket_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_refunds.ticket_id IS 'Foreign key to tickets table - ticket being refunded';


--
-- Name: COLUMN ticket_refunds.original_amount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_refunds.original_amount IS 'Original ticket purchase price';


--
-- Name: COLUMN ticket_refunds.refund_amount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_refunds.refund_amount IS 'Amount to be refunded (may be less than original)';


--
-- Name: COLUMN ticket_refunds.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_refunds.status IS 'Current refund status in workflow';


--
-- Name: COLUMN ticket_refunds.requested_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_refunds.requested_at IS 'When refund was initially requested';


--
-- Name: COLUMN ticket_refunds.updated_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_refunds.updated_at IS 'Last update timestamp';


--
-- Name: ticket_transactions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ticket_transactions (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    ticket_id uuid NOT NULL,
    blockchain_transaction_id uuid,
    transaction_type character varying(50) NOT NULL,
    from_user_id uuid,
    to_user_id uuid,
    amount numeric(10,2),
    currency character varying(3) DEFAULT 'USD'::character varying,
    fee_amount numeric(10,2) DEFAULT 0,
    status character varying(20) DEFAULT 'PENDING'::character varying,
    error_message text,
    transaction_signature character varying(88),
    block_number bigint,
    ip_address inet,
    user_agent text,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    completed_at timestamp with time zone,
    CONSTRAINT valid_transaction_status CHECK (((status)::text = ANY (ARRAY[('PENDING'::character varying)::text, ('PROCESSING'::character varying)::text, ('COMPLETED'::character varying)::text, ('FAILED'::character varying)::text, ('CANCELLED'::character varying)::text]))),
    CONSTRAINT valid_transaction_type CHECK (((transaction_type)::text = ANY (ARRAY[('PURCHASE'::character varying)::text, ('TRANSFER'::character varying)::text, ('LIST'::character varying)::text, ('DELIST'::character varying)::text, ('SALE'::character varying)::text, ('REDEEM'::character varying)::text, ('REFUND'::character varying)::text, ('BURN'::character varying)::text, ('MINT'::character varying)::text])))
);



--
-- Name: TABLE ticket_transactions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ticket_transactions IS 'Stores all ticket purchase transactions including purchases, refunds, and transfers';


--
-- Name: COLUMN ticket_transactions.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_transactions.id IS 'Unique identifier for the transaction (UUID)';


--
-- Name: COLUMN ticket_transactions.ticket_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_transactions.ticket_id IS 'Foreign key to tickets table - specific ticket if applicable';


--
-- Name: COLUMN ticket_transactions.transaction_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_transactions.transaction_type IS 'Type of transaction: purchase, refund, or transfer';


--
-- Name: COLUMN ticket_transactions.amount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_transactions.amount IS 'Transaction amount in the specified currency';


--
-- Name: COLUMN ticket_transactions.currency; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_transactions.currency IS 'ISO 4217 currency code (e.g., USD, EUR)';


--
-- Name: COLUMN ticket_transactions.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_transactions.status IS 'Current status of the transaction: pending, completed, failed, or cancelled';


--
-- Name: COLUMN ticket_transactions.metadata; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_transactions.metadata IS 'Additional transaction data stored as JSONB';


--
-- Name: COLUMN ticket_transactions.created_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_transactions.created_at IS 'Timestamp when the transaction record was created';


--
-- Name: tickets; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.tickets (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    event_id uuid,
    ticket_type_id uuid,
    owner_id uuid,
    status public.ticket_status DEFAULT 'AVAILABLE'::public.ticket_status,
    ticket_code uuid DEFAULT public.uuid_generate_v1(),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    is_transferable boolean DEFAULT true,
    is_valid boolean DEFAULT true,
    mint_address text,
    transfer_locked_until timestamp with time zone,
    original_purchaser_id uuid
);



--
-- Name: TABLE tickets; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.tickets IS 'Individual tickets with ownership, validation, and NFT integration';


--
-- Name: users; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.users (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    email character varying(255) NOT NULL,
    password_hash character varying(255) NOT NULL,
    email_verified boolean DEFAULT false,
    email_verification_token character varying(64),
    email_verification_expires timestamp with time zone,
    username character varying(30),
    display_name character varying(100),
    bio text,
    avatar_url text,
    cover_image_url text,
    first_name character varying(50),
    last_name character varying(50),
    date_of_birth date,
    phone character varying(20),
    phone_verified boolean DEFAULT false,
    country_code character varying(2),
    city character varying(100),
    state_province character varying(100),
    postal_code character varying(20),
    timezone character varying(50) DEFAULT 'UTC'::character varying,
    preferred_language character varying(10) DEFAULT 'en'::character varying,
    status public.user_status DEFAULT 'PENDING'::public.user_status,
    role character varying(20) DEFAULT 'user'::character varying,
    permissions jsonb DEFAULT '[]'::jsonb,
    two_factor_enabled boolean DEFAULT false,
    two_factor_secret character varying(32),
    backup_codes text[],
    last_password_change timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    password_reset_token character varying(64),
    password_reset_expires timestamp with time zone,
    last_login_at timestamp with time zone,
    last_login_ip inet,
    last_login_device character varying(255),
    login_count integer DEFAULT 0,
    failed_login_attempts integer DEFAULT 0,
    locked_until timestamp with time zone,
    preferences jsonb DEFAULT '{}'::jsonb,
    notification_preferences jsonb DEFAULT '{"push": {"security": true, "marketing": false, "transactions": true}, "email": {"security": true, "marketing": true, "transactions": true}}'::jsonb,
    terms_accepted_at timestamp with time zone,
    terms_version character varying(20),
    privacy_accepted_at timestamp with time zone,
    privacy_version character varying(20),
    marketing_consent boolean DEFAULT false,
    marketing_consent_date timestamp with time zone,
    referral_code character varying(20),
    referred_by uuid,
    referral_count integer DEFAULT 0,
    metadata jsonb DEFAULT '{}'::jsonb,
    tags text[],
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    deleted_at timestamp with time zone,
    total_purchases integer DEFAULT 0,
    total_spent numeric(12,2) DEFAULT 0,
    last_purchase_at timestamp with time zone,
    CONSTRAINT check_age_minimum CHECK (((date_of_birth IS NULL) OR (date_of_birth <= (CURRENT_DATE - '13 years'::interval)))),
    CONSTRAINT check_email_lowercase CHECK (((email)::text = lower((email)::text))),
    CONSTRAINT check_referral_not_self CHECK (((referred_by IS NULL) OR (referred_by <> id))),
    CONSTRAINT check_username_format CHECK (((username)::text ~ '^[a-zA-Z0-9_]{3,30}$'::text))
);



--
-- Name: TABLE users; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.users IS 'Core user accounts table for TicketToken platform authentication and profile management';


--
-- Name: COLUMN users.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.id IS 'Primary key: UUID identifier for the user account';


--
-- Name: COLUMN users.email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.email IS 'User email address: used for login and communication (unique, required)';


--
-- Name: COLUMN users.password_hash; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.password_hash IS 'Hashed password: stored using bcrypt or argon2 hashing';


--
-- Name: COLUMN users.email_verified; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.email_verified IS 'Email verification status: true if email has been verified';


--
-- Name: COLUMN users.email_verification_token; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.email_verification_token IS 'Email verification token: temporary token for email verification';


--
-- Name: COLUMN users.username; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.username IS 'User display name: unique identifier visible to other users';


--
-- Name: COLUMN users.first_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.first_name IS 'User first name: optional profile information';


--
-- Name: COLUMN users.last_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.last_name IS 'User last name: optional profile information';


--
-- Name: COLUMN users.phone; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.phone IS 'Phone number: optional, stored in international format';


--
-- Name: COLUMN users.phone_verified; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.phone_verified IS 'Phone verification status: true if phone has been verified';


--
-- Name: COLUMN users.two_factor_enabled; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.two_factor_enabled IS 'Two-factor authentication status: true if 2FA is enabled';


--
-- Name: COLUMN users.password_reset_token; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.password_reset_token IS 'Password reset token: temporary token for password reset';


--
-- Name: COLUMN users.last_login_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.last_login_at IS 'Last login timestamp: when user last successfully logged in';


--
-- Name: COLUMN users.failed_login_attempts; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.failed_login_attempts IS 'Failed login counter: tracks consecutive failed login attempts';


--
-- Name: COLUMN users.created_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.created_at IS 'Creation timestamp: when the user account was created';


--
-- Name: COLUMN users.updated_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.updated_at IS 'Update timestamp: when the user account was last modified';


--
-- Name: COLUMN users.deleted_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.deleted_at IS 'Soft delete timestamp: when the user account was deleted (NULL = active)';


--
-- Name: venues; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.venues (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    name character varying(255) NOT NULL,
    address text,
    city character varying(100),
    created_by uuid,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    total_events integer DEFAULT 0
);



--
-- Name: TABLE venues; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.venues IS 'Master venue data with comprehensive information for TicketToken platform';


--
-- Name: pending_refunds_view; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.pending_refunds_view AS
 SELECT r.id AS refund_id,
    r.status AS refund_status,
    r.requested_at AS refund_created_at,
    ttx.id AS ticket_tx_id,
    t.id AS ticket_id,
    u.id AS owner_id,
    u.email AS owner_email,
    e.id AS event_id,
    e.name AS event_name,
    v.id AS venue_id,
    v.name AS venue_name
   FROM (((((public.ticket_refunds r
     JOIN public.ticket_transactions ttx ON ((ttx.id = r.transaction_id)))
     JOIN public.tickets t ON ((t.id = ttx.ticket_id)))
     JOIN public.users u ON ((u.id = t.owner_id)))
     JOIN public.events e ON ((e.id = t.event_id)))
     JOIN public.venues v ON ((v.id = e.venue_id)))
  WHERE ((r.status)::text = 'PENDING'::text)
  ORDER BY r.requested_at;



--
-- Name: performance_metrics; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.performance_metrics (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    metric_name character varying(100),
    metric_value numeric,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: permission_dependencies; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.permission_dependencies (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    permission_id uuid NOT NULL,
    required_permission_id uuid NOT NULL,
    dependency_type character varying(50) DEFAULT 'prerequisite'::character varying NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT permission_dependencies_no_self_dependency CHECK ((permission_id <> required_permission_id))
);



--
-- Name: TABLE permission_dependencies; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.permission_dependencies IS 'Permission dependencies and prerequisites';


--
-- Name: permissions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.permissions (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    resource character varying(100) NOT NULL,
    action character varying(50) NOT NULL,
    description text,
    created_at timestamp with time zone DEFAULT now()
);



--
-- Name: TABLE permissions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.permissions IS 'Comprehensive permission management system for TicketToken platform';


--
-- Name: COLUMN permissions.resource; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.permissions.resource IS 'Target resource type (venue, event, ticket, etc.)';


--
-- Name: COLUMN permissions.action; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.permissions.action IS 'Action type (create, read, update, delete, manage, etc.)';


--
-- Name: COLUMN permissions.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.permissions.description IS 'Detailed description of permission capabilities';


--
-- Name: price_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.price_history (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    ticket_id uuid NOT NULL,
    listing_id uuid,
    price numeric(10,2) NOT NULL,
    currency character varying(10) DEFAULT 'USD'::character varying,
    price_type character varying(50) NOT NULL,
    market_average numeric(10,2),
    market_low numeric(10,2),
    market_high numeric(10,2),
    percentile_rank integer,
    event_id uuid NOT NULL,
    days_until_event integer,
    source character varying(50),
    metadata jsonb DEFAULT '{}'::jsonb,
    recorded_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_price_type CHECK (((price_type)::text = ANY (ARRAY[('LISTING'::character varying)::text, ('SALE'::character varying)::text, ('OFFER'::character varying)::text, ('ASK'::character varying)::text, ('BID'::character varying)::text, ('MARKET_MAKER'::character varying)::text])))
);



--
-- Name: privacy_audit_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.privacy_audit_log (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    action character varying(255),
    user_id uuid,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: psp_reconciliations; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.psp_reconciliations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    provider character varying(50) NOT NULL,
    reconciliation_date date NOT NULL,
    our_totals jsonb NOT NULL,
    psp_totals jsonb NOT NULL,
    discrepancies jsonb,
    status character varying(50) NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: qr_scan_attempts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.qr_scan_attempts (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    ticket_id uuid,
    scanner_id character varying(255),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: rate_limit_violations; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_limit_violations (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    user_id uuid,
    endpoint character varying(255),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: realtime_metrics; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.realtime_metrics (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    metric_name character varying(255) NOT NULL,
    metric_value jsonb,
    recorded_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: refund_requests; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.refund_requests (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    transaction_id uuid,
    reason text,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: refunds; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.refunds (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    transaction_id uuid NOT NULL,
    user_id uuid NOT NULL,
    amount bigint NOT NULL,
    currency character varying(10) NOT NULL,
    reason character varying(100) NOT NULL,
    reason_details text,
    status character varying(50) DEFAULT 'pending'::character varying NOT NULL,
    provider_refund_id text,
    provider_status character varying(50),
    provider_response jsonb,
    requested_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    approved_at timestamp with time zone,
    processed_at timestamp with time zone,
    completed_at timestamp with time zone,
    approved_by uuid,
    approval_notes text,
    auto_approved boolean DEFAULT false,
    refund_fee bigint DEFAULT 0,
    net_refund_amount bigint GENERATED ALWAYS AS ((amount - refund_fee)) STORED,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_refund_reason CHECK (((reason)::text = ANY (ARRAY[('duplicate'::character varying)::text, ('fraudulent'::character varying)::text, ('requested_by_customer'::character varying)::text, ('event_cancelled'::character varying)::text, ('technical_issue'::character varying)::text, ('other'::character varying)::text]))),
    CONSTRAINT valid_refund_status CHECK (((status)::text = ANY (ARRAY[('pending'::character varying)::text, ('approved'::character varying)::text, ('processing'::character varying)::text, ('completed'::character varying)::text, ('failed'::character varying)::text, ('cancelled'::character varying)::text, ('reversed'::character varying)::text])))
);



--
-- Name: TABLE refunds; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.refunds IS 'Comprehensive refund tracking table managing all payment refunds with policy compliance, approval workflows, and complete financial impact calculations. Supports both manual and automated refund processing.';


--
-- Name: COLUMN refunds.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.refunds.id IS 'Unique refund identifier (UUID)';


--
-- Name: COLUMN refunds.net_refund_amount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.refunds.net_refund_amount IS 'Amount after deducting refund processing fees';


--
-- Name: reportable_transactions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.reportable_transactions (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    transaction_id uuid,
    reported boolean DEFAULT false,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: reservations; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.reservations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    order_id uuid,
    user_id uuid,
    ticket_type_id uuid NOT NULL,
    event_id uuid NOT NULL,
    quantity integer NOT NULL,
    expires_at timestamp without time zone NOT NULL,
    status character varying(50) DEFAULT 'ACTIVE'::character varying,
    released_at timestamp without time zone,
    converted_at timestamp without time zone,
    session_id character varying(255),
    ip_address inet,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT reservations_quantity_check CHECK ((quantity > 0)),
    CONSTRAINT valid_expiry CHECK ((expires_at > created_at)),
    CONSTRAINT valid_reservation_status CHECK (((status)::text = ANY (ARRAY[('ACTIVE'::character varying)::text, ('EXPIRED'::character varying)::text, ('RELEASED'::character varying)::text, ('CONVERTED'::character varying)::text])))
);



--
-- Name: TABLE reservations; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.reservations IS 'Temporary ticket holds during checkout process';


--
-- Name: revenue_projections; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.revenue_projections (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    projection_date date,
    projected_amount numeric(10,2),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: revenue_summary_view; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.revenue_summary_view AS
 WITH daily_revenue AS (
         SELECT date(tr.created_at) AS revenue_date,
            v.id AS venue_id,
            v.name AS venue_name,
            e.id AS event_id,
            e.name AS event_name,
            NULL::text AS event_category,
            count(DISTINCT tr.id) AS transaction_count,
            sum(tr.amount) AS gross_revenue,
            sum((0)::numeric) AS platform_fees,
            sum((0)::numeric) AS venue_fees,
            sum((0)::numeric) AS payment_fees,
            sum((((tr.amount - COALESCE((0)::numeric, (0)::numeric)) - COALESCE((0)::numeric, (0)::numeric)) - COALESCE((0)::numeric, (0)::numeric))) AS net_revenue
           FROM ((((public.marketplace_transactions mt
             JOIN public.ticket_transactions tr ON ((tr.id = mt.ticket_id)))
             JOIN public.tickets t ON ((t.id = mt.ticket_id)))
             JOIN public.events e ON ((e.id = t.event_id)))
             JOIN public.venues v ON ((v.id = e.venue_id)))
          WHERE (((tr.status)::text = 'COMPLETED'::text) AND ((tr.transaction_type)::text = ANY (ARRAY[('PURCHASE'::character varying)::text, ('MARKETPLACE_SALE'::character varying)::text])))
          GROUP BY (date(tr.created_at)), v.id, v.name, e.id, e.name
        )
 SELECT daily_revenue.revenue_date,
    daily_revenue.venue_id,
    daily_revenue.venue_name,
    daily_revenue.event_id,
    daily_revenue.event_name,
    daily_revenue.event_category,
    daily_revenue.transaction_count,
    daily_revenue.gross_revenue,
    daily_revenue.platform_fees,
    daily_revenue.venue_fees,
    daily_revenue.payment_fees,
    daily_revenue.net_revenue,
    sum(daily_revenue.gross_revenue) OVER (PARTITION BY daily_revenue.venue_id ORDER BY daily_revenue.revenue_date) AS cumulative_venue_revenue,
    sum(daily_revenue.gross_revenue) OVER (ORDER BY daily_revenue.revenue_date) AS cumulative_total_revenue
   FROM daily_revenue;



--
-- Name: VIEW revenue_summary_view; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON VIEW public.revenue_summary_view IS 'Daily revenue breakdown by venue and event';


--
-- Name: role_permissions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.role_permissions (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    role_id uuid NOT NULL,
    permission_id uuid NOT NULL,
    granted_at timestamp with time zone DEFAULT now() NOT NULL,
    granted_by_user_id uuid,
    venue_id uuid,
    event_id uuid,
    conditions jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);



--
-- Name: TABLE role_permissions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.role_permissions IS 'Many-to-many relationship between roles and permissions';


--
-- Name: roles; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.roles (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    name character varying(100) NOT NULL,
    description text,
    permissions jsonb DEFAULT '[]'::jsonb,
    is_system boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    deleted_at timestamp with time zone
);



--
-- Name: TABLE roles; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.roles IS 'Role-based access control (RBAC) system for TicketToken platform';


--
-- Name: COLUMN roles.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.roles.id IS 'Primary key: UUID identifier for the role';


--
-- Name: COLUMN roles.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.roles.description IS 'Role description: detailed explanation of role responsibilities';


--
-- Name: royalties; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.royalties (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    marketplace_transaction_id uuid NOT NULL,
    venue_id uuid NOT NULL,
    recipient_id uuid NOT NULL,
    royalty_percentage numeric(5,2) NOT NULL,
    sale_amount numeric(10,2) NOT NULL,
    royalty_amount numeric(10,2) NOT NULL,
    currency character varying(10) DEFAULT 'USD'::character varying,
    status character varying(50) DEFAULT 'PENDING'::character varying NOT NULL,
    payment_transaction_id uuid,
    distribution_type character varying(50) DEFAULT 'IMMEDIATE'::character varying,
    batch_id uuid,
    calculation_details jsonb DEFAULT '{}'::jsonb,
    calculated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    paid_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT royalty_calculation_check CHECK ((royalty_amount = round((sale_amount * (royalty_percentage / 100.0)), 2))),
    CONSTRAINT valid_royalty_percentage CHECK (((royalty_percentage >= (0)::numeric) AND (royalty_percentage <= (50)::numeric))),
    CONSTRAINT valid_royalty_status CHECK (((status)::text = ANY (ARRAY[('PENDING'::character varying)::text, ('PROCESSING'::character varying)::text, ('PAID'::character varying)::text, ('FAILED'::character varying)::text, ('CANCELLED'::character varying)::text])))
);



--
-- Name: royalty_settlements; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.royalty_settlements (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    amount numeric(10,2),
    settled_date date,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: sanctions_screening; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.sanctions_screening (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    user_id uuid,
    screening_result character varying(50),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: scanner_devices; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.scanner_devices (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    device_name character varying(255),
    venue_id uuid,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: schedule_activities; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.schedule_activities (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    schedule_id uuid NOT NULL,
    activity_name character varying(200) NOT NULL,
    activity_type public.activity_type NOT NULL,
    activity_description text,
    scheduled_start_time timestamp with time zone NOT NULL,
    scheduled_end_time timestamp with time zone,
    duration interval,
    activity_order integer DEFAULT 1 NOT NULL,
    depends_on_activity_id uuid,
    buffer_time_before interval DEFAULT '00:00:00'::interval,
    buffer_time_after interval DEFAULT '00:00:00'::interval,
    required_staff integer DEFAULT 0,
    required_equipment jsonb DEFAULT '[]'::jsonb,
    setup_time interval DEFAULT '00:00:00'::interval,
    breakdown_time interval DEFAULT '00:00:00'::interval,
    activity_location character varying(200),
    room_or_area character varying(100),
    capacity_limit integer,
    is_public boolean DEFAULT true NOT NULL,
    is_optional boolean DEFAULT false NOT NULL,
    is_critical boolean DEFAULT false NOT NULL,
    requires_ticket boolean DEFAULT false NOT NULL,
    performer_id uuid,
    participant_limit integer,
    current_participants integer DEFAULT 0,
    actual_start_time timestamp with time zone,
    actual_end_time timestamp with time zone,
    completion_status character varying(50) DEFAULT 'pending'::character varying,
    completion_notes text,
    special_instructions text,
    accessibility_requirements text,
    equipment_setup_notes text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by_user_id uuid,
    CONSTRAINT schedule_activities_no_self_dependency CHECK ((depends_on_activity_id <> id)),
    CONSTRAINT schedule_activities_valid_capacity CHECK (((capacity_limit IS NULL) OR (capacity_limit > 0))),
    CONSTRAINT schedule_activities_valid_order CHECK ((activity_order > 0)),
    CONSTRAINT schedule_activities_valid_participants CHECK (((current_participants >= 0) AND ((participant_limit IS NULL) OR (current_participants <= participant_limit)))),
    CONSTRAINT schedule_activities_valid_times CHECK (((scheduled_end_time IS NULL) OR (scheduled_end_time > scheduled_start_time)))
);



--
-- Name: TABLE schedule_activities; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.schedule_activities IS 'Individual activities and timeline components within event schedules';


--
-- Name: COLUMN schedule_activities.activity_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.schedule_activities.activity_type IS 'Activity classification: setup, doors_open, main_event, cleanup, etc.';


--
-- Name: COLUMN schedule_activities.depends_on_activity_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.schedule_activities.depends_on_activity_id IS 'Activity dependency: previous activity that must complete first';


--
-- Name: COLUMN schedule_activities.buffer_time_before; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.schedule_activities.buffer_time_before IS 'Schedule buffer: time buffer before activity starts';


--
-- Name: COLUMN schedule_activities.is_critical; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.schedule_activities.is_critical IS 'Critical activity: essential for event success and cannot be skipped';


--
-- Name: schedule_conflicts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.schedule_conflicts (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    primary_schedule_id uuid NOT NULL,
    conflicting_schedule_id uuid NOT NULL,
    conflict_type character varying(100) NOT NULL,
    conflict_description text,
    severity character varying(20) DEFAULT 'medium'::character varying,
    conflict_start timestamp with time zone NOT NULL,
    conflict_end timestamp with time zone NOT NULL,
    overlap_duration interval,
    resource_type character varying(100),
    resource_id character varying(100),
    resource_description text,
    conflict_status character varying(50) DEFAULT 'unresolved'::character varying,
    resolution_strategy character varying(100),
    resolution_description text,
    resolved_at timestamp with time zone,
    resolved_by_user_id uuid,
    business_impact character varying(100),
    customer_impact character varying(100),
    financial_impact numeric(10,2),
    stakeholders_notified boolean DEFAULT false NOT NULL,
    public_communication_required boolean DEFAULT false NOT NULL,
    communication_plan text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    detected_by_user_id uuid,
    CONSTRAINT schedule_conflicts_valid_financial_impact CHECK (((financial_impact IS NULL) OR (financial_impact >= (0)::numeric))),
    CONSTRAINT schedule_conflicts_valid_schedules CHECK ((primary_schedule_id <> conflicting_schedule_id)),
    CONSTRAINT schedule_conflicts_valid_timeframe CHECK ((conflict_end > conflict_start))
);



--
-- Name: TABLE schedule_conflicts; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.schedule_conflicts IS 'Schedule conflict detection and resolution tracking';


--
-- Name: COLUMN schedule_conflicts.conflict_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.schedule_conflicts.conflict_type IS 'Conflict classification: venue double-booking, staff conflict, equipment conflict';


--
-- Name: COLUMN schedule_conflicts.severity; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.schedule_conflicts.severity IS 'Conflict importance: low, medium, high, critical impact level';


--
-- Name: COLUMN schedule_conflicts.resolution_strategy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.schedule_conflicts.resolution_strategy IS 'Resolution approach: reschedule, relocate, staff reassignment, etc.';


--
-- Name: schedule_exceptions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.schedule_exceptions (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    schedule_id uuid NOT NULL,
    exception_name character varying(200),
    exception_type character varying(100) NOT NULL,
    exception_reason text,
    exception_date date NOT NULL,
    start_time time without time zone,
    end_time time without time zone,
    is_all_day boolean DEFAULT true NOT NULL,
    action_type character varying(50) DEFAULT 'cancel'::character varying NOT NULL,
    replacement_datetime timestamp with time zone,
    modification_details jsonb DEFAULT '{}'::jsonb,
    affects_all_activities boolean DEFAULT true NOT NULL,
    affected_activity_ids uuid[],
    public_notice text,
    notification_sent boolean DEFAULT false NOT NULL,
    notification_sent_at timestamp with time zone,
    requires_approval boolean DEFAULT false NOT NULL,
    approved_by_user_id uuid,
    approved_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by_user_id uuid,
    CONSTRAINT schedule_exceptions_valid_times CHECK (((is_all_day = true) OR ((start_time IS NOT NULL) AND (end_time IS NOT NULL) AND (end_time > start_time))))
);



--
-- Name: TABLE schedule_exceptions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.schedule_exceptions IS 'Exceptions and blackout dates for recurring event schedules';


--
-- Name: COLUMN schedule_exceptions.action_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.schedule_exceptions.action_type IS 'Exception action: cancel, reschedule, or modify the affected occurrence';


--
-- Name: COLUMN schedule_exceptions.affects_all_activities; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.schedule_exceptions.affects_all_activities IS 'Exception scope: whether exception applies to all activities or specific ones';


--
-- Name: COLUMN schedule_exceptions.public_notice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.schedule_exceptions.public_notice IS 'Public communication: notice displayed to attendees about exception';


--
-- Name: schema_migrations; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.schema_migrations (
    version integer NOT NULL,
    name text NOT NULL,
    applied_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: search_analytics; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.search_analytics (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    search_query character varying(255),
    results_count integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: search_index_events; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.search_index_events (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    event_id uuid,
    indexed_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: security_alerts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.security_alerts (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    alert_type character varying(100),
    severity character varying(50),
    description text,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: security_audit_logs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.security_audit_logs (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    action character varying(255),
    user_id uuid,
    ip_address inet,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: segment_definitions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.segment_definitions (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    segment_key character varying(50) NOT NULL,
    display_name character varying(100) NOT NULL,
    description text,
    segment_type public.segment_type_enum DEFAULT 'automatic'::public.segment_type_enum NOT NULL,
    criteria jsonb DEFAULT '{}'::jsonb NOT NULL,
    color_code character varying(7) DEFAULT '#6B7280'::character varying,
    icon_name character varying(50) DEFAULT 'users'::character varying,
    priority integer DEFAULT 100,
    display_order integer DEFAULT 1000,
    default_campaign_eligible boolean DEFAULT true,
    requires_opt_in boolean DEFAULT false,
    is_active boolean DEFAULT true,
    is_system boolean DEFAULT false,
    tags text[],
    metadata jsonb DEFAULT '{}'::jsonb,
    created_by uuid,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_color_code_format CHECK (((color_code)::text ~* '^#[0-9A-Fa-f]{6}$'::text)),
    CONSTRAINT chk_display_order_positive CHECK ((display_order >= 0)),
    CONSTRAINT chk_priority_positive CHECK ((priority > 0))
);



--
-- Name: TABLE segment_definitions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.segment_definitions IS 'Master list of available customer segments with their rules and configuration';


--
-- Name: COLUMN segment_definitions.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.segment_definitions.id IS 'Unique identifier for the segment definition';


--
-- Name: COLUMN segment_definitions.segment_key; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.segment_definitions.segment_key IS 'Unique key identifier (e.g., new_customer, vip)';


--
-- Name: COLUMN segment_definitions.display_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.segment_definitions.display_name IS 'Human-readable name for UI display';


--
-- Name: COLUMN segment_definitions.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.segment_definitions.description IS 'Detailed description of segment purpose and criteria';


--
-- Name: COLUMN segment_definitions.segment_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.segment_definitions.segment_type IS 'How the segment is populated (automatic, manual, behavioral)';


--
-- Name: COLUMN segment_definitions.criteria; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.segment_definitions.criteria IS 'JSON rules for automatic segment assignment';


--
-- Name: COLUMN segment_definitions.color_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.segment_definitions.color_code IS 'Hex color code for UI representation';


--
-- Name: COLUMN segment_definitions.icon_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.segment_definitions.icon_name IS 'Icon identifier for UI display';


--
-- Name: COLUMN segment_definitions.priority; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.segment_definitions.priority IS 'Segment priority (lower = higher priority)';


--
-- Name: COLUMN segment_definitions.display_order; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.segment_definitions.display_order IS 'Order for UI display';


--
-- Name: COLUMN segment_definitions.default_campaign_eligible; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.segment_definitions.default_campaign_eligible IS 'Default campaign eligibility for new assignments';


--
-- Name: COLUMN segment_definitions.requires_opt_in; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.segment_definitions.requires_opt_in IS 'Whether customers must explicitly opt into this segment';


--
-- Name: COLUMN segment_definitions.is_active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.segment_definitions.is_active IS 'Whether this segment is currently in use';


--
-- Name: COLUMN segment_definitions.is_system; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.segment_definitions.is_system IS 'System segments cannot be deleted';


--
-- Name: COLUMN segment_definitions.tags; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.segment_definitions.tags IS 'Tags for categorization and filtering';


--
-- Name: COLUMN segment_definitions.metadata; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.segment_definitions.metadata IS 'Additional configuration data';


--
-- Name: service_health; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.service_health (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    service_name character varying(100),
    status character varying(50),
    last_check timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: session_activities; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.session_activities (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    session_id uuid NOT NULL,
    activity_type character varying(100) NOT NULL,
    activity_description text,
    "timestamp" timestamp with time zone DEFAULT now() NOT NULL,
    ip_address inet,
    user_agent text,
    page_url text,
    http_method character varying(10),
    http_status_code integer,
    request_data jsonb,
    response_data jsonb,
    processing_time_ms integer,
    is_suspicious boolean DEFAULT false NOT NULL,
    risk_score integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);



--
-- Name: sessions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.sessions (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    user_id uuid NOT NULL,
    token character varying(255) NOT NULL,
    ip_address inet,
    user_agent text,
    last_activity timestamp with time zone DEFAULT now(),
    expires_at timestamp with time zone NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);



--
-- Name: settlement_batches; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.settlement_batches (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    batch_date date,
    total_amount numeric(10,2),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: settlement_items; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.settlement_items (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    batch_id uuid,
    amount numeric(10,2),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: settlement_pending_view; Type: MATERIALIZED VIEW; Schema: public; Owner: postgres
--

CREATE MATERIALIZED VIEW public.settlement_pending_view AS
 WITH pending_transactions AS (
         SELECT v.id AS venue_id,
            v.name AS venue_name,
            count(DISTINCT tr.id) AS pending_transaction_count,
            sum(((tr.amount - COALESCE((0)::numeric, (0)::numeric)) - COALESCE((0)::numeric, (0)::numeric))) AS pending_amount,
            min(tr.created_at) AS oldest_transaction_date,
            max(tr.created_at) AS newest_transaction_date
           FROM ((((public.venues v
             JOIN public.events e ON ((e.venue_id = v.id)))
             JOIN public.tickets t ON ((t.event_id = e.id)))
             JOIN public.marketplace_transactions mt ON ((mt.ticket_id = t.id)))
             JOIN public.ticket_transactions tr ON ((tr.id = mt.ticket_id)))
          WHERE (((tr.status)::text = 'COMPLETED'::text) AND true)
          GROUP BY v.id, v.name
        )
 SELECT pending_transactions.venue_id,
    pending_transactions.venue_name,
    pending_transactions.pending_transaction_count,
    pending_transactions.pending_amount,
    pending_transactions.oldest_transaction_date,
    pending_transactions.newest_transaction_date,
    (CURRENT_TIMESTAMP - pending_transactions.oldest_transaction_date) AS oldest_transaction_age,
    false AS is_overdue,
    CURRENT_TIMESTAMP AS last_calculated
   FROM pending_transactions
  WHERE (pending_transactions.pending_amount > (0)::numeric)
  WITH NO DATA;



--
-- Name: MATERIALIZED VIEW settlement_pending_view; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON MATERIALIZED VIEW public.settlement_pending_view IS 'Pending settlements by venue - refresh every hour';


--
-- Name: settlement_reports; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.settlement_reports (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    venue_id uuid,
    settlement_date date NOT NULL,
    gross_revenue numeric(10,2) NOT NULL,
    platform_fees numeric(10,2) NOT NULL,
    taxes numeric(10,2) NOT NULL,
    net_payout numeric(10,2) NOT NULL,
    order_count integer NOT NULL,
    ticket_count integer NOT NULL,
    report_data jsonb,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: settlements; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.settlements (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    settlement_date date NOT NULL,
    provider character varying(50) NOT NULL,
    provider_settlement_id text,
    currency character varying(10) DEFAULT 'USD'::character varying NOT NULL,
    gross_amount bigint NOT NULL,
    fee_amount bigint NOT NULL,
    net_amount bigint NOT NULL,
    transaction_count integer NOT NULL,
    refund_count integer DEFAULT 0,
    chargeback_count integer DEFAULT 0,
    bank_account_id uuid,
    transfer_initiated_at timestamp with time zone,
    transfer_completed_at timestamp with time zone,
    transfer_reference character varying(100),
    status character varying(50) DEFAULT 'pending'::character varying NOT NULL,
    payment_volume bigint DEFAULT 0,
    refund_volume bigint DEFAULT 0,
    fee_breakdown jsonb DEFAULT '{}'::jsonb,
    is_reconciled boolean DEFAULT false,
    reconciled_at timestamp with time zone,
    reconciliation_notes text,
    discrepancy_amount bigint DEFAULT 0,
    report_url text,
    invoice_url text,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_settlement_status CHECK (((status)::text = ANY (ARRAY[('pending'::character varying)::text, ('processing'::character varying)::text, ('paid'::character varying)::text, ('failed'::character varying)::text, ('reversed'::character varying)::text])))
);



--
-- Name: TABLE settlements; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.settlements IS 'Manages venue payouts and settlement calculations. Tracks complete financial breakdown for each settlement period with support for multiple payout methods and comprehensive reconciliation.';


--
-- Name: COLUMN settlements.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.settlements.id IS 'Unique settlement identifier (UUID)';


--
-- Name: COLUMN settlements.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.settlements.status IS 'Current status in payout workflow';


--
-- Name: sla_metrics; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.sla_metrics (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    service character varying(100),
    uptime_percentage numeric(5,2),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: smart_contract_events; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.smart_contract_events (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    program_id character varying(44) NOT NULL,
    event_type character varying(100) NOT NULL,
    event_data jsonb NOT NULL,
    transaction_signature character varying(88),
    instruction_index integer,
    inner_instruction_index integer,
    slot_number bigint NOT NULL,
    block_time timestamp with time zone,
    ticket_id uuid,
    venue_id uuid,
    event_id uuid,
    wallet_address character varying(44),
    amount numeric(20,8),
    token_mint character varying(44),
    category character varying(20) NOT NULL,
    event_version integer DEFAULT 1,
    schema_version integer DEFAULT 1,
    processed boolean DEFAULT false,
    processed_at timestamp with time zone,
    processing_error text,
    retry_count integer DEFAULT 0,
    derived_metrics jsonb DEFAULT '{}'::jsonb,
    indexed_fields jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_category CHECK (((category)::text = ANY (ARRAY[('TICKET'::character varying)::text, ('MARKETPLACE'::character varying)::text, ('ROYALTY'::character varying)::text, ('GOVERNANCE'::character varying)::text, ('VENUE'::character varying)::text]))),
    CONSTRAINT valid_event_type CHECK (((event_type)::text = ANY (ARRAY[('TicketMinted'::character varying)::text, ('TicketTransferred'::character varying)::text, ('TicketRedeemed'::character varying)::text, ('TicketBurned'::character varying)::text, ('TicketUpdated'::character varying)::text, ('MarketplaceListed'::character varying)::text, ('MarketplaceDelisted'::character varying)::text, ('MarketplaceSold'::character varying)::text, ('MarketplacePriceUpdated'::character varying)::text, ('RoyaltyPaid'::character varying)::text, ('RoyaltyUpdated'::character varying)::text, ('VenueRegistered'::character varying)::text, ('VenueUpdated'::character varying)::text, ('VenueVerified'::character varying)::text, ('EventCreated'::character varying)::text, ('EventUpdated'::character varying)::text, ('EventCancelled'::character varying)::text, ('EventCompleted'::character varying)::text])))
);



--
-- Name: TABLE smart_contract_events; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.smart_contract_events IS 'Logs all events emitted by smart contracts for the TicketToken platform';


--
-- Name: COLUMN smart_contract_events.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.id IS 'Unique identifier for the event log entry';


--
-- Name: COLUMN smart_contract_events.program_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.program_id IS 'Solana program address that emitted this event';


--
-- Name: COLUMN smart_contract_events.event_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.event_type IS 'Specific type of event that was emitted';


--
-- Name: COLUMN smart_contract_events.event_data; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.event_data IS 'Complete event data in JSON format';


--
-- Name: COLUMN smart_contract_events.transaction_signature; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.transaction_signature IS 'Reference to the blockchain transaction containing this event';


--
-- Name: COLUMN smart_contract_events.instruction_index; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.instruction_index IS 'Position of instruction within the transaction';


--
-- Name: COLUMN smart_contract_events.inner_instruction_index; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.inner_instruction_index IS 'Position if this is a CPI (cross-program invocation)';


--
-- Name: COLUMN smart_contract_events.slot_number; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.slot_number IS 'Solana slot number when event was emitted';


--
-- Name: COLUMN smart_contract_events.block_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.block_time IS 'Timestamp of the block containing this event';


--
-- Name: COLUMN smart_contract_events.ticket_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.ticket_id IS 'Ticket ID for ticket-related events';


--
-- Name: COLUMN smart_contract_events.venue_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.venue_id IS 'Venue ID for venue-related events';


--
-- Name: COLUMN smart_contract_events.event_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.event_id IS 'Event ID for event-related events (not the log event itself)';


--
-- Name: COLUMN smart_contract_events.wallet_address; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.wallet_address IS 'Primary wallet address involved in the event';


--
-- Name: COLUMN smart_contract_events.amount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.amount IS 'Monetary amount involved in the event (8 decimal places)';


--
-- Name: COLUMN smart_contract_events.token_mint; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.token_mint IS 'Token mint address for token-related events';


--
-- Name: COLUMN smart_contract_events.category; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.category IS 'High-level category of the event';


--
-- Name: COLUMN smart_contract_events.event_version; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.event_version IS 'Version of the event format';


--
-- Name: COLUMN smart_contract_events.schema_version; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.schema_version IS 'Version of the data schema';


--
-- Name: COLUMN smart_contract_events.processed; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.processed IS 'Whether this event has been processed by backend systems';


--
-- Name: COLUMN smart_contract_events.processed_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.processed_at IS 'Timestamp when event was processed';


--
-- Name: COLUMN smart_contract_events.processing_error; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.processing_error IS 'Error message if processing failed';


--
-- Name: COLUMN smart_contract_events.retry_count; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.retry_count IS 'Number of times processing has been retried';


--
-- Name: COLUMN smart_contract_events.derived_metrics; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.derived_metrics IS 'Calculated metrics from processing the event';


--
-- Name: COLUMN smart_contract_events.indexed_fields; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.indexed_fields IS 'Additional searchable data extracted from event';


--
-- Name: COLUMN smart_contract_events.created_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.smart_contract_events.created_at IS 'Timestamp when this record was created';


--
-- Name: staff_certifications; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.staff_certifications (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    venue_staff_id uuid NOT NULL,
    certification_name character varying(200) NOT NULL,
    certification_type character varying(100) NOT NULL,
    issuing_organization character varying(200),
    certification_number character varying(100),
    issue_date date NOT NULL,
    expiry_date date,
    renewal_required boolean DEFAULT true NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    is_verified boolean DEFAULT false NOT NULL,
    verification_date date,
    verification_method character varying(100),
    certificate_document_url text,
    verification_document_url text,
    renewal_reminder_sent boolean DEFAULT false NOT NULL,
    renewal_notice_days integer DEFAULT 30,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by_user_id uuid,
    CONSTRAINT staff_certs_valid_dates CHECK (((expiry_date IS NULL) OR (expiry_date >= issue_date))),
    CONSTRAINT staff_certs_valid_reminder_days CHECK ((renewal_notice_days > 0))
);



--
-- Name: TABLE staff_certifications; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.staff_certifications IS 'Individual certification tracking with expiry monitoring';


--
-- Name: staff_schedules; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.staff_schedules (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    venue_staff_id uuid NOT NULL,
    venue_id uuid NOT NULL,
    schedule_name character varying(200),
    schedule_date date NOT NULL,
    start_time time without time zone NOT NULL,
    end_time time without time zone NOT NULL,
    break_duration_minutes integer DEFAULT 0,
    schedule_type character varying(100) DEFAULT 'regular'::character varying,
    schedule_status character varying(50) DEFAULT 'scheduled'::character varying,
    assigned_position character varying(200),
    assigned_area character varying(200),
    special_instructions text,
    event_id uuid,
    actual_start_time timestamp with time zone,
    actual_end_time timestamp with time zone,
    hours_worked numeric(4,2),
    overtime_hours numeric(4,2) DEFAULT 0,
    staff_notes text,
    supervisor_notes text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by_user_id uuid,
    CONSTRAINT staff_schedules_valid_break CHECK ((break_duration_minutes >= 0)),
    CONSTRAINT staff_schedules_valid_hours CHECK (((hours_worked IS NULL) OR (hours_worked >= (0)::numeric))),
    CONSTRAINT staff_schedules_valid_overtime CHECK ((overtime_hours >= (0)::numeric)),
    CONSTRAINT staff_schedules_valid_times CHECK ((end_time > start_time))
);



--
-- Name: TABLE staff_schedules; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.staff_schedules IS 'Staff work schedules and shift assignments with attendance tracking';


--
-- Name: COLUMN staff_schedules.schedule_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.staff_schedules.schedule_status IS 'Schedule status: tracks scheduled, confirmed, completed, cancelled, no_show';


--
-- Name: COLUMN staff_schedules.actual_start_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.staff_schedules.actual_start_time IS 'Clock-in time: actual start time when staff clocked in';


--
-- Name: COLUMN staff_schedules.actual_end_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.staff_schedules.actual_end_time IS 'Clock-out time: actual end time when staff clocked out';


--
-- Name: COLUMN staff_schedules.hours_worked; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.staff_schedules.hours_worked IS 'Calculated hours: automatically calculated from actual times';


--
-- Name: COLUMN staff_schedules.overtime_hours; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.staff_schedules.overtime_hours IS 'Overtime hours: calculated automatically for hours over 8 per day';


--
-- Name: staff_training_records; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.staff_training_records (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    venue_staff_id uuid NOT NULL,
    training_name character varying(200) NOT NULL,
    training_type character varying(100) NOT NULL,
    training_category character varying(100),
    training_provider character varying(200),
    completion_status character varying(50) DEFAULT 'not_started'::character varying,
    start_date date,
    completion_date date,
    score numeric(5,2),
    passing_score numeric(5,2),
    is_mandatory boolean DEFAULT false NOT NULL,
    is_recurring boolean DEFAULT false NOT NULL,
    renewal_frequency interval,
    next_renewal_date date,
    training_materials jsonb DEFAULT '{}'::jsonb,
    completion_certificate_url text,
    trainer_name character varying(200),
    training_hours numeric(4,2),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by_user_id uuid,
    CONSTRAINT staff_training_valid_dates CHECK (((completion_date IS NULL) OR (start_date IS NULL) OR (completion_date >= start_date))),
    CONSTRAINT staff_training_valid_hours CHECK (((training_hours IS NULL) OR (training_hours >= (0)::numeric))),
    CONSTRAINT staff_training_valid_score CHECK (((score IS NULL) OR (score >= (0)::numeric)))
);



--
-- Name: TABLE staff_training_records; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.staff_training_records IS 'Training completion and progress tracking for staff development';


--
-- Name: state_compliance_rules; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.state_compliance_rules (
    id integer NOT NULL,
    state_code character varying(2) NOT NULL,
    max_markup_percentage numeric(5,2),
    requires_disclosure boolean DEFAULT false,
    requires_license boolean DEFAULT false,
    special_rules json,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: state_compliance_rules_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.state_compliance_rules_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;



--
-- Name: state_compliance_rules_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.state_compliance_rules_id_seq OWNED BY public.state_compliance_rules.id;


--
-- Name: subscriptions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.subscriptions (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    user_id uuid NOT NULL,
    payment_method_id uuid,
    plan_id character varying(100) NOT NULL,
    plan_name character varying(200),
    status character varying(50) DEFAULT 'active'::character varying NOT NULL,
    amount bigint NOT NULL,
    currency character varying(10) DEFAULT 'USD'::character varying NOT NULL,
    "interval" character varying(20) NOT NULL,
    interval_count integer DEFAULT 1,
    trial_start date,
    trial_end date,
    trial_days integer DEFAULT 0,
    current_period_start date NOT NULL,
    current_period_end date NOT NULL,
    billing_cycle_anchor date,
    cancel_at_period_end boolean DEFAULT false,
    cancelled_at timestamp with time zone,
    cancellation_reason character varying(100),
    provider character varying(50),
    provider_subscription_id text,
    provider_customer_id text,
    usage_based boolean DEFAULT false,
    usage_limit bigint,
    current_usage bigint DEFAULT 0,
    discount_percentage numeric(5,2),
    discount_amount bigint,
    discount_end_date date,
    metadata jsonb DEFAULT '{}'::jsonb,
    features jsonb DEFAULT '[]'::jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_interval CHECK ((("interval")::text = ANY (ARRAY[('daily'::character varying)::text, ('weekly'::character varying)::text, ('monthly'::character varying)::text, ('quarterly'::character varying)::text, ('yearly'::character varying)::text]))),
    CONSTRAINT valid_subscription_status CHECK (((status)::text = ANY (ARRAY[('trialing'::character varying)::text, ('active'::character varying)::text, ('past_due'::character varying)::text, ('cancelled'::character varying)::text, ('unpaid'::character varying)::text, ('incomplete'::character varying)::text, ('incomplete_expired'::character varying)::text, ('paused'::character varying)::text])))
);



--
-- Name: TABLE subscriptions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.subscriptions IS 'Manages all recurring billing subscriptions for platform services. Handles subscription lifecycle from trial through cancellation, including billing cycles, discounts, and usage tracking.';


--
-- Name: COLUMN subscriptions.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.subscriptions.id IS 'Unique subscription identifier (UUID)';


--
-- Name: COLUMN subscriptions.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.subscriptions.status IS 'Current subscription status in lifecycle';


--
-- Name: COLUMN subscriptions.current_period_start; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.subscriptions.current_period_start IS 'Start of current billing period';


--
-- Name: COLUMN subscriptions.cancel_at_period_end; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.subscriptions.cancel_at_period_end IS 'Whether to cancel after current period';


--
-- Name: suspicious_sessions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.suspicious_sessions (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    session_id uuid NOT NULL,
    user_id uuid NOT NULL,
    detection_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    detection_reason text NOT NULL,
    severity public.session_risk_level DEFAULT 'medium'::public.session_risk_level NOT NULL,
    detection_method character varying(100),
    detected_by_user_id uuid,
    investigated boolean DEFAULT false NOT NULL,
    investigated_at timestamp with time zone,
    investigated_by_user_id uuid,
    investigation_notes text,
    resolved boolean DEFAULT false NOT NULL,
    resolved_at timestamp with time zone,
    resolution_action character varying(100),
    additional_data jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);



--
-- Name: sync_logs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.sync_logs (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    sync_type character varying(100),
    status character varying(50),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: tax_collections; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.tax_collections (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    amount numeric(10,2),
    tax_type character varying(50),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: tax_form_recipients; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.tax_form_recipients (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    user_id uuid,
    form_type character varying(50),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: tax_forms_1099; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.tax_forms_1099 (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    user_id uuid,
    tax_year integer,
    total_amount numeric(10,2),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: tax_remittances; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.tax_remittances (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    amount numeric(10,2),
    remitted_date date,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: tax_reporting_requirements; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.tax_reporting_requirements (
    id integer NOT NULL,
    customer_id character varying(255),
    venue_id character varying(255),
    year integer NOT NULL,
    form_type character varying(20) NOT NULL,
    threshold_met boolean DEFAULT false,
    total_amount numeric(10,2),
    form_sent boolean DEFAULT false,
    sent_date timestamp without time zone,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: tax_reporting_requirements_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.tax_reporting_requirements_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;



--
-- Name: tax_reporting_requirements_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.tax_reporting_requirements_id_seq OWNED BY public.tax_reporting_requirements.id;


--
-- Name: tenants; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.tenants (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    tenant_name character varying(255),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: ticket_batch_operations; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ticket_batch_operations (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    operation_type character varying(30) NOT NULL,
    event_id uuid,
    ticket_type_id uuid,
    operation_parameters jsonb NOT NULL,
    ticket_ids uuid[],
    target_user_id uuid,
    status character varying(20) DEFAULT 'PENDING'::character varying,
    total_tickets integer NOT NULL,
    processed_tickets integer DEFAULT 0,
    successful_tickets integer DEFAULT 0,
    failed_tickets integer DEFAULT 0,
    progress_percentage numeric(5,2) DEFAULT 0,
    estimated_completion timestamp with time zone,
    error_messages text[],
    started_at timestamp with time zone,
    completed_at timestamp with time zone,
    cancelled_at timestamp with time zone,
    initiated_by uuid NOT NULL,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_batch_counts CHECK ((processed_tickets = (successful_tickets + failed_tickets))),
    CONSTRAINT ticket_batch_operations_operation_type_check CHECK (((operation_type)::text = ANY (ARRAY[('BULK_CREATE'::character varying)::text, ('BULK_TRANSFER'::character varying)::text, ('BULK_CANCEL'::character varying)::text, ('BULK_REFUND'::character varying)::text, ('BULK_UPDATE'::character varying)::text, ('BULK_VALIDATE'::character varying)::text]))),
    CONSTRAINT ticket_batch_operations_status_check CHECK (((status)::text = ANY (ARRAY[('PENDING'::character varying)::text, ('PROCESSING'::character varying)::text, ('COMPLETED'::character varying)::text, ('FAILED'::character varying)::text, ('CANCELLED'::character varying)::text])))
);



--
-- Name: TABLE ticket_batch_operations; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ticket_batch_operations IS 'Bulk operations on multiple tickets';


--
-- Name: ticket_metadata; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ticket_metadata (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    ticket_id uuid NOT NULL,
    name character varying(200),
    symbol character varying(10),
    description text,
    image text,
    animation_url text,
    external_url text,
    attributes jsonb DEFAULT '[]'::jsonb,
    properties jsonb DEFAULT '{}'::jsonb,
    collection jsonb,
    uses jsonb,
    seller_fee_basis_points integer DEFAULT 250,
    creators jsonb DEFAULT '[]'::jsonb,
    event_details jsonb,
    venue_details jsonb,
    perks jsonb DEFAULT '[]'::jsonb,
    media_assets jsonb DEFAULT '[]'::jsonb,
    authenticity_hash character varying(64),
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: TABLE ticket_metadata; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ticket_metadata IS 'Stores NFT metadata and blockchain references for tokenized tickets. Supports both standard and compressed NFTs on Solana with full Metaplex metadata standard compliance.';


--
-- Name: COLUMN ticket_metadata.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_metadata.id IS 'Unique identifier for the metadata record (UUID)';


--
-- Name: COLUMN ticket_metadata.ticket_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_metadata.ticket_id IS 'Foreign key to tickets table - one-to-one relationship';


--
-- Name: COLUMN ticket_metadata.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_metadata.name IS 'NFT display name (e.g., "Concert Name - Seat A1")';


--
-- Name: COLUMN ticket_metadata.symbol; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_metadata.symbol IS 'NFT collection symbol';


--
-- Name: COLUMN ticket_metadata.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_metadata.description IS 'Detailed description of the ticket NFT';


--
-- Name: COLUMN ticket_metadata.animation_url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_metadata.animation_url IS 'URL to animation/video content if applicable';


--
-- Name: COLUMN ticket_metadata.external_url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_metadata.external_url IS 'External URL for more information';


--
-- Name: COLUMN ticket_metadata.attributes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_metadata.attributes IS 'JSON array of trait objects following Metaplex standard';


--
-- Name: COLUMN ticket_metadata.properties; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_metadata.properties IS 'Additional properties including files and creators';


--
-- Name: COLUMN ticket_metadata.seller_fee_basis_points; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_metadata.seller_fee_basis_points IS 'Total royalty in basis points (250 = 2.5%)';


--
-- Name: COLUMN ticket_metadata.creators; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_metadata.creators IS 'Array of creators with royalty shares';


--
-- Name: COLUMN ticket_metadata.created_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_metadata.created_at IS 'When metadata record was created';


--
-- Name: COLUMN ticket_metadata.updated_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_metadata.updated_at IS 'When metadata was last updated';


--
-- Name: ticket_ownership_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ticket_ownership_history (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    ticket_id uuid NOT NULL,
    owner_user_id uuid NOT NULL,
    ownership_type character varying(20) NOT NULL,
    owned_from timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    owned_until timestamp with time zone,
    is_current_owner boolean DEFAULT false,
    source_transaction_id uuid,
    source_transaction_type character varying(20),
    price_paid numeric(10,2),
    ownership_proof_hash character varying(64),
    blockchain_transaction_hash character varying(100),
    legal_document_url character varying(500),
    ownership_notes text,
    metadata jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT ticket_ownership_history_ownership_type_check CHECK (((ownership_type)::text = ANY (ARRAY[('PURCHASE'::character varying)::text, ('TRANSFER'::character varying)::text, ('GIFT'::character varying)::text, ('INHERITANCE'::character varying)::text, ('ADMIN_ASSIGN'::character varying)::text, ('REFUND_REISSUE'::character varying)::text])))
);



--
-- Name: TABLE ticket_ownership_history; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ticket_ownership_history IS 'Complete ownership chain for each ticket';


--
-- Name: ticket_redemptions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ticket_redemptions (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    ticket_id uuid NOT NULL,
    event_schedule_id uuid,
    redeemed_by_user_id uuid,
    redeemed_by_staff_id uuid,
    redemption_method character varying(50) DEFAULT 'QR_CODE'::character varying,
    redemption_gate character varying(50),
    redemption_location jsonb,
    device_id character varying(100),
    validation_code character varying(100),
    is_valid boolean DEFAULT true,
    validation_errors text[],
    seat_assigned character varying(50),
    special_instructions text,
    metadata jsonb DEFAULT '{}'::jsonb,
    redeemed_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_redemption_method CHECK (((redemption_method)::text = ANY (ARRAY[('QR_CODE'::character varying)::text, ('BARCODE'::character varying)::text, ('MANUAL'::character varying)::text, ('NFC'::character varying)::text, ('FACIAL'::character varying)::text, ('OTHER'::character varying)::text])))
);



--
-- Name: TABLE ticket_redemptions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ticket_redemptions IS 'Tracks all ticket entry validations and redemptions at venue gates. Validation process: QR scan -> NFT verification -> Fraud check -> Entry granted/denied';


--
-- Name: COLUMN ticket_redemptions.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_redemptions.id IS 'Unique identifier for the redemption attempt (UUID)';


--
-- Name: COLUMN ticket_redemptions.ticket_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_redemptions.ticket_id IS 'Foreign key to tickets table - the ticket being redeemed';


--
-- Name: COLUMN ticket_redemptions.metadata; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_redemptions.metadata IS 'Additional redemption data as JSONB';


--
-- Name: ticket_resale_listings; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ticket_resale_listings (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    ticket_id uuid NOT NULL,
    seller_user_id uuid NOT NULL,
    listing_price numeric(10,2) NOT NULL,
    min_price numeric(10,2),
    currency_code character varying(3) DEFAULT 'USD'::character varying,
    price_type character varying(20) DEFAULT 'FIXED'::character varying,
    auction_start_price numeric(10,2),
    auction_reserve_price numeric(10,2),
    auction_end_time timestamp with time zone,
    current_highest_bid numeric(10,2),
    bid_count integer DEFAULT 0,
    status character varying(20) DEFAULT 'ACTIVE'::character varying,
    visibility character varying(20) DEFAULT 'PUBLIC'::character varying,
    is_verified boolean DEFAULT false,
    verification_notes text,
    platform_fee_percentage numeric(5,2) DEFAULT 10,
    seller_fee numeric(10,2) DEFAULT 0,
    buyer_fee numeric(10,2) DEFAULT 0,
    title character varying(200),
    description text,
    listing_images text[],
    tags text[],
    external_listing_urls text[],
    allowed_countries text[],
    restricted_regions text[],
    local_pickup_available boolean DEFAULT false,
    shipping_options jsonb,
    listed_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    expires_at timestamp with time zone,
    sold_at timestamp with time zone,
    removed_at timestamp with time zone,
    view_count integer DEFAULT 0,
    inquiry_count integer DEFAULT 0,
    offer_count integer DEFAULT 0,
    metadata jsonb,
    created_by uuid,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_resale_auction CHECK ((((price_type)::text <> 'AUCTION'::text) OR ((auction_start_price IS NOT NULL) AND (auction_end_time IS NOT NULL)))),
    CONSTRAINT ticket_resale_listings_check CHECK ((min_price <= listing_price)),
    CONSTRAINT ticket_resale_listings_listing_price_check CHECK ((listing_price > (0)::numeric)),
    CONSTRAINT ticket_resale_listings_price_type_check CHECK (((price_type)::text = ANY (ARRAY[('FIXED'::character varying)::text, ('AUCTION'::character varying)::text, ('MAKE_OFFER'::character varying)::text, ('DECLINING'::character varying)::text]))),
    CONSTRAINT ticket_resale_listings_status_check CHECK (((status)::text = ANY (ARRAY[('DRAFT'::character varying)::text, ('ACTIVE'::character varying)::text, ('PAUSED'::character varying)::text, ('SOLD'::character varying)::text, ('CANCELLED'::character varying)::text, ('EXPIRED'::character varying)::text, ('REMOVED'::character varying)::text]))),
    CONSTRAINT ticket_resale_listings_visibility_check CHECK (((visibility)::text = ANY (ARRAY[('PUBLIC'::character varying)::text, ('PRIVATE'::character varying)::text, ('INVITE_ONLY'::character varying)::text, ('PLATFORM_ONLY'::character varying)::text])))
);



--
-- Name: TABLE ticket_resale_listings; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ticket_resale_listings IS 'Secondary market ticket listings and auctions';


--
-- Name: ticket_reservations; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ticket_reservations (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    ticket_type_id uuid,
    user_id uuid,
    expires_at timestamp without time zone,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: ticket_reservations_backup; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ticket_reservations_backup (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    reservation_data jsonb,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: ticket_scans; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ticket_scans (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    ticket_id uuid,
    device_id uuid,
    scanned_at timestamp without time zone NOT NULL,
    scan_type character varying(50),
    result character varying(50),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: ticket_transfers; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ticket_transfers (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    ticket_id uuid NOT NULL,
    transaction_id uuid,
    from_user_id uuid NOT NULL,
    to_user_id uuid NOT NULL,
    to_email character varying(255),
    to_phone character varying(20),
    transfer_method character varying(50) DEFAULT 'DIRECT'::character varying,
    transfer_price numeric(10,2),
    transfer_fee numeric(10,2) DEFAULT 0,
    status character varying(20) DEFAULT 'PENDING'::character varying,
    acceptance_code character varying(20),
    accepted_at timestamp with time zone,
    expires_at timestamp with time zone,
    is_gift boolean DEFAULT false,
    message text,
    initiated_via character varying(50),
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT different_users CHECK ((from_user_id <> to_user_id)),
    CONSTRAINT valid_transfer_status CHECK (((status)::text = ANY (ARRAY[('PENDING'::character varying)::text, ('ACCEPTED'::character varying)::text, ('REJECTED'::character varying)::text, ('EXPIRED'::character varying)::text, ('CANCELLED'::character varying)::text, ('COMPLETED'::character varying)::text])))
);



--
-- Name: TABLE ticket_transfers; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ticket_transfers IS 'Complete history of ticket transfers between users';


--
-- Name: COLUMN ticket_transfers.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_transfers.id IS 'Unique identifier for the transfer (UUID)';


--
-- Name: COLUMN ticket_transfers.ticket_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_transfers.ticket_id IS 'Foreign key to tickets table - the ticket being transferred';


--
-- Name: COLUMN ticket_transfers.transaction_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_transfers.transaction_id IS 'Foreign key to ticket_transactions table for financial tracking';


--
-- Name: COLUMN ticket_transfers.from_user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_transfers.from_user_id IS 'Foreign key to users table - current owner transferring the ticket';


--
-- Name: COLUMN ticket_transfers.to_user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_transfers.to_user_id IS 'Foreign key to users table - new owner receiving the ticket';


--
-- Name: COLUMN ticket_transfers.transfer_price; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_transfers.transfer_price IS 'Sale price of the ticket (NULL for gifts/refunds)';


--
-- Name: COLUMN ticket_transfers.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_transfers.status IS 'Current transfer status: initiated (created), pending_approval (awaiting verification), completed (ownership transferred), cancelled';


--
-- Name: COLUMN ticket_transfers.expires_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_transfers.expires_at IS 'When the transfer offer expires if not completed';


--
-- Name: COLUMN ticket_transfers.metadata; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_transfers.metadata IS 'Additional transfer data as JSONB (gift messages, conditions, etc.)';


--
-- Name: COLUMN ticket_transfers.created_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ticket_transfers.created_at IS 'When the transfer was initiated';


--
-- Name: ticket_type_analytics; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ticket_type_analytics (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    ticket_type_id uuid NOT NULL,
    analytics_date date NOT NULL,
    views integer DEFAULT 0,
    add_to_cart integer DEFAULT 0,
    purchases integer DEFAULT 0,
    revenue numeric(12,2) DEFAULT 0,
    refunds integer DEFAULT 0,
    transfers integer DEFAULT 0,
    conversion_rate numeric(5,4) DEFAULT 0,
    average_quantity_per_purchase numeric(8,4) DEFAULT 0,
    bounce_rate numeric(5,4) DEFAULT 0,
    time_to_purchase_minutes integer,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: TABLE ticket_type_analytics; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ticket_type_analytics IS 'Daily analytics and performance metrics for ticket types';


--
-- Name: ticket_type_availability_schedules; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ticket_type_availability_schedules (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    ticket_type_id uuid NOT NULL,
    schedule_name character varying(100) NOT NULL,
    release_date timestamp with time zone NOT NULL,
    quantity_to_release integer NOT NULL,
    price_at_release numeric(10,2),
    is_processed boolean DEFAULT false,
    processed_at timestamp with time zone,
    processed_quantity integer DEFAULT 0,
    notes text,
    created_by uuid,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT ticket_type_availability_schedules_quantity_to_release_check CHECK ((quantity_to_release > 0))
);



--
-- Name: TABLE ticket_type_availability_schedules; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ticket_type_availability_schedules IS 'Scheduled releases of additional ticket inventory';


--
-- Name: ticket_type_benefits; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ticket_type_benefits (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    ticket_type_id uuid NOT NULL,
    benefit_category character varying(30) NOT NULL,
    benefit_name character varying(200) NOT NULL,
    benefit_description text,
    benefit_value character varying(100),
    is_included boolean DEFAULT true,
    is_highlighted boolean DEFAULT false,
    display_order integer DEFAULT 0,
    icon_name character varying(50),
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT ticket_type_benefits_benefit_category_check CHECK (((benefit_category)::text = ANY (ARRAY[('ACCESS'::character varying)::text, ('AMENITY'::character varying)::text, ('SERVICE'::character varying)::text, ('MERCHANDISE'::character varying)::text, ('FOOD_BEVERAGE'::character varying)::text, ('PARKING'::character varying)::text, ('EXPERIENCE'::character varying)::text, ('DISCOUNT'::character varying)::text])))
);



--
-- Name: TABLE ticket_type_benefits; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ticket_type_benefits IS 'Benefits and inclusions for different ticket types';


--
-- Name: ticket_type_refund_policies; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ticket_type_refund_policies (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    ticket_type_id uuid NOT NULL,
    refund_allowed boolean DEFAULT true,
    refund_deadline_hours integer,
    refund_fee numeric(10,2) DEFAULT 0,
    refund_fee_type character varying(20) DEFAULT 'FIXED'::character varying,
    refund_percentage numeric(5,2) DEFAULT 100,
    processing_time_days integer DEFAULT 7,
    refund_tiers jsonb,
    weather_cancellation_full_refund boolean DEFAULT true,
    artist_cancellation_full_refund boolean DEFAULT true,
    venue_cancellation_full_refund boolean DEFAULT true,
    covid_policy_refund boolean DEFAULT false,
    requires_reason boolean DEFAULT false,
    allowed_reasons text[],
    requires_documentation boolean DEFAULT false,
    documentation_types text[],
    refund_method character varying(20) DEFAULT 'ORIGINAL'::character varying,
    restrictions text,
    created_by uuid,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT ticket_type_refund_policies_refund_fee_type_check CHECK (((refund_fee_type)::text = ANY (ARRAY[('FIXED'::character varying)::text, ('PERCENTAGE'::character varying)::text]))),
    CONSTRAINT ticket_type_refund_policies_refund_method_check CHECK (((refund_method)::text = ANY (ARRAY[('ORIGINAL'::character varying)::text, ('CREDIT'::character varying)::text, ('BOTH'::character varying)::text]))),
    CONSTRAINT ticket_type_refund_policies_refund_percentage_check CHECK (((refund_percentage >= (0)::numeric) AND (refund_percentage <= (100)::numeric)))
);



--
-- Name: TABLE ticket_type_refund_policies; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ticket_type_refund_policies IS 'Refund policies and conditions for ticket types';


--
-- Name: ticket_type_restrictions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ticket_type_restrictions (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    ticket_type_id uuid NOT NULL,
    restriction_type character varying(30) NOT NULL,
    restriction_name character varying(100) NOT NULL,
    restriction_rule jsonb NOT NULL,
    error_message text,
    is_active boolean DEFAULT true,
    severity character varying(20) DEFAULT 'ERROR'::character varying,
    created_by uuid,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT ticket_type_restrictions_restriction_type_check CHECK (((restriction_type)::text = ANY (ARRAY[('AGE'::character varying)::text, ('LOCATION'::character varying)::text, ('MEMBERSHIP'::character varying)::text, ('PURCHASE_HISTORY'::character varying)::text, ('DEVICE'::character varying)::text, ('TIME'::character varying)::text, ('QUANTITY'::character varying)::text, ('PAYMENT_METHOD'::character varying)::text]))),
    CONSTRAINT ticket_type_restrictions_severity_check CHECK (((severity)::text = ANY (ARRAY[('ERROR'::character varying)::text, ('WARNING'::character varying)::text, ('INFO'::character varying)::text])))
);



--
-- Name: TABLE ticket_type_restrictions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ticket_type_restrictions IS 'Purchase restrictions and validation rules for ticket types';


--
-- Name: ticket_type_transfer_policies; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ticket_type_transfer_policies (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    ticket_type_id uuid NOT NULL,
    transfer_allowed boolean DEFAULT true,
    transfer_fee numeric(10,2) DEFAULT 0,
    transfer_fee_type character varying(20) DEFAULT 'FIXED'::character varying,
    max_transfers_per_ticket integer DEFAULT 1,
    transfer_deadline_hours integer,
    requires_approval boolean DEFAULT false,
    approval_required_from character varying(20),
    blackout_periods jsonb,
    allowed_transfer_methods text[] DEFAULT ARRAY['PLATFORM'::text, 'EMAIL'::text],
    restrictions text,
    created_by uuid,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT ticket_type_transfer_policies_approval_required_from_check CHECK (((approval_required_from)::text = ANY (ARRAY[('VENUE'::character varying)::text, ('ORGANIZER'::character varying)::text, ('SYSTEM'::character varying)::text, ('ANY_ADMIN'::character varying)::text]))),
    CONSTRAINT ticket_type_transfer_policies_transfer_fee_type_check CHECK (((transfer_fee_type)::text = ANY (ARRAY[('FIXED'::character varying)::text, ('PERCENTAGE'::character varying)::text])))
);



--
-- Name: TABLE ticket_type_transfer_policies; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ticket_type_transfer_policies IS 'Transfer policies and restrictions for ticket types';


--
-- Name: ticket_types; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ticket_types (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    event_id uuid,
    name character varying(255) NOT NULL,
    price numeric(10,2),
    quantity integer,
    available_quantity integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: TABLE ticket_types; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ticket_types IS 'Master table for ticket types and categories with pricing and policies';


--
-- Name: ticket_validations; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ticket_validations (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    ticket_id uuid NOT NULL,
    validation_type character varying(20) NOT NULL,
    validation_method character varying(20) NOT NULL,
    validation_result character varying(20) NOT NULL,
    validation_location character varying(100),
    venue_zone character varying(50),
    device_id character varying(100),
    device_type character varying(30),
    gps_coordinates point,
    ip_address inet,
    user_agent text,
    validated_by_user_id uuid,
    validation_notes text,
    error_message text,
    confidence_score numeric(3,2),
    fraud_flags text[],
    risk_score numeric(5,2) DEFAULT 0,
    duplicate_scan_detected boolean DEFAULT false,
    time_since_last_scan interval,
    validation_data jsonb,
    photo_url character varying(500),
    signature_data text,
    validated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    processing_time_ms integer,
    CONSTRAINT ticket_validations_confidence_score_check CHECK (((confidence_score >= (0)::numeric) AND (confidence_score <= (1)::numeric))),
    CONSTRAINT ticket_validations_validation_method_check CHECK (((validation_method)::text = ANY (ARRAY[('QR_SCAN'::character varying)::text, ('BARCODE_SCAN'::character varying)::text, ('NFC'::character varying)::text, ('RFID'::character varying)::text, ('MANUAL'::character varying)::text, ('MOBILE_APP'::character varying)::text, ('KIOSK'::character varying)::text]))),
    CONSTRAINT ticket_validations_validation_result_check CHECK (((validation_result)::text = ANY (ARRAY[('VALID'::character varying)::text, ('INVALID'::character varying)::text, ('EXPIRED'::character varying)::text, ('USED'::character varying)::text, ('DUPLICATE'::character varying)::text, ('FRAUD'::character varying)::text, ('ERROR'::character varying)::text]))),
    CONSTRAINT ticket_validations_validation_type_check CHECK (((validation_type)::text = ANY (ARRAY[('ENTRY_SCAN'::character varying)::text, ('VALIDATION_CHECK'::character varying)::text, ('FRAUD_CHECK'::character varying)::text, ('ID_VERIFICATION'::character varying)::text, ('MANUAL_CHECK'::character varying)::text])))
);



--
-- Name: TABLE ticket_validations; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ticket_validations IS 'Entry validation logs and fraud detection records';


--
-- Name: tos_acceptances; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.tos_acceptances (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_email character varying(255) NOT NULL,
    version character varying(50) NOT NULL,
    ip_address inet,
    user_agent text,
    accepted_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: transactions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.transactions (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    user_id uuid NOT NULL,
    payment_method_id uuid,
    order_id uuid,
    type character varying(50) NOT NULL,
    status character varying(50) DEFAULT 'pending'::character varying NOT NULL,
    amount bigint NOT NULL,
    currency character varying(10) DEFAULT 'USD'::character varying NOT NULL,
    exchange_rate numeric(20,10) DEFAULT 1.0,
    platform_fee bigint DEFAULT 0,
    payment_processor_fee bigint DEFAULT 0,
    network_fee bigint DEFAULT 0,
    total_fee bigint GENERATED ALWAYS AS (((platform_fee + payment_processor_fee) + network_fee)) STORED,
    net_amount bigint GENERATED ALWAYS AS ((((amount - platform_fee) - payment_processor_fee) - network_fee)) STORED,
    provider character varying(50),
    provider_transaction_id text,
    provider_reference text,
    provider_response jsonb,
    blockchain_network character varying(50),
    transaction_hash character varying(100),
    block_number bigint,
    confirmations integer DEFAULT 0,
    authentication_required boolean DEFAULT false,
    authentication_status character varying(50),
    authentication_response jsonb,
    risk_score integer,
    risk_factors jsonb DEFAULT '[]'::jsonb,
    fraud_detected boolean DEFAULT false,
    initiated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    processing_started_at timestamp with time zone,
    completed_at timestamp with time zone,
    failed_at timestamp with time zone,
    error_code character varying(50),
    error_message text,
    retry_count integer DEFAULT 0,
    description text,
    metadata jsonb DEFAULT '{}'::jsonb,
    ip_address inet,
    user_agent text,
    idempotency_key character varying(100),
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    total_amount numeric(10,2),
    CONSTRAINT positive_amount CHECK ((amount > 0)),
    CONSTRAINT valid_transaction_status CHECK (((status)::text = ANY (ARRAY[('pending'::character varying)::text, ('processing'::character varying)::text, ('requires_action'::character varying)::text, ('succeeded'::character varying)::text, ('failed'::character varying)::text, ('cancelled'::character varying)::text, ('reversed'::character varying)::text]))),
    CONSTRAINT valid_transaction_type CHECK (((type)::text = ANY (ARRAY[('payment'::character varying)::text, ('refund'::character varying)::text, ('partial_refund'::character varying)::text, ('payout'::character varying)::text, ('fee'::character varying)::text, ('adjustment'::character varying)::text, ('chargeback'::character varying)::text, ('dispute'::character varying)::text])))
);



--
-- Name: TABLE transactions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.transactions IS 'Central financial transactions table tracking all money movements including payments, refunds, payouts, and fees. Designed for financial compliance, accurate reporting, and complete audit trails.';


--
-- Name: COLUMN transactions.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.id IS 'Unique transaction identifier (UUID)';


--
-- Name: COLUMN transactions.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.status IS 'Current transaction status in processing workflow';


--
-- Name: COLUMN transactions.amount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.amount IS 'Transaction amount (positive for charges, negative for refunds)';


--
-- Name: COLUMN transactions.net_amount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.net_amount IS 'Calculated amount after all fees (generated column)';


--
-- Name: COLUMN transactions.risk_score; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.risk_score IS 'Risk assessment score 0-100';


--
-- Name: upload_sessions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.upload_sessions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid,
    status character varying(50) DEFAULT 'pending'::character varying,
    total_files integer,
    uploaded_files integer DEFAULT 0,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: user_consents; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.user_consents (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    user_id uuid,
    consent_type character varying(100),
    granted boolean DEFAULT false,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: user_permissions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.user_permissions (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    user_id uuid NOT NULL,
    permission_id uuid NOT NULL,
    is_granted boolean NOT NULL,
    granted_at timestamp with time zone DEFAULT now() NOT NULL,
    granted_by_user_id uuid,
    expires_at timestamp with time zone,
    venue_id uuid,
    event_id uuid,
    conditions jsonb,
    reason text,
    is_active boolean DEFAULT true NOT NULL,
    revoked_at timestamp with time zone,
    revoked_by_user_id uuid,
    revoke_reason text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT user_permissions_valid_expiry CHECK (((expires_at IS NULL) OR (expires_at > granted_at))),
    CONSTRAINT user_permissions_valid_revocation CHECK (((revoked_at IS NULL) OR (revoked_at >= granted_at)))
);



--
-- Name: TABLE user_permissions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.user_permissions IS 'Direct user permission overrides with grant/deny capability';


--
-- Name: user_privacy_settings; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.user_privacy_settings (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    user_id uuid,
    setting_name character varying(100),
    setting_value character varying(255),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: user_roles; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.user_roles (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    user_id uuid NOT NULL,
    role_id uuid NOT NULL,
    assigned_at timestamp with time zone DEFAULT now() NOT NULL,
    assigned_by_user_id uuid,
    expires_at timestamp with time zone,
    venue_id uuid,
    event_id uuid,
    is_active boolean DEFAULT true NOT NULL,
    revoked_at timestamp with time zone,
    revoked_by_user_id uuid,
    revoke_reason text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT user_roles_valid_expiry CHECK (((expires_at IS NULL) OR (expires_at > assigned_at))),
    CONSTRAINT user_roles_valid_revocation CHECK (((revoked_at IS NULL) OR (revoked_at >= assigned_at)))
);



--
-- Name: TABLE user_roles; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.user_roles IS 'Junction table assigning roles to users with scope and expiration support';


--
-- Name: COLUMN user_roles.user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.user_roles.user_id IS 'User reference: ID of user assigned this role';


--
-- Name: COLUMN user_roles.role_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.user_roles.role_id IS 'Role reference: ID of role being assigned';


--
-- Name: COLUMN user_roles.assigned_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.user_roles.assigned_at IS 'Assignment timestamp: when role was assigned to user';


--
-- Name: COLUMN user_roles.assigned_by_user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.user_roles.assigned_by_user_id IS 'Assigner reference: user who assigned this role';


--
-- Name: COLUMN user_roles.expires_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.user_roles.expires_at IS 'Expiration timestamp: when role assignment expires (NULL = never)';


--
-- Name: COLUMN user_roles.venue_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.user_roles.venue_id IS 'Venue scope: limits role to specific venue (NULL = all venues)';


--
-- Name: COLUMN user_roles.event_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.user_roles.event_id IS 'Event scope: limits role to specific event (NULL = all events)';


--
-- Name: COLUMN user_roles.is_active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.user_roles.is_active IS 'Active status: whether role assignment is currently active';


--
-- Name: COLUMN user_roles.revoked_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.user_roles.revoked_at IS 'Revocation timestamp: when role was revoked';


--
-- Name: COLUMN user_roles.revoked_by_user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.user_roles.revoked_by_user_id IS 'Revoker reference: user who revoked this role';


--
-- Name: COLUMN user_roles.revoke_reason; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.user_roles.revoke_reason IS 'Revocation reason: explanation for why role was revoked';


--
-- Name: user_sessions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.user_sessions (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    user_id uuid,
    session_token character varying(255),
    expires_at timestamp without time zone,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: venue_analytics; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.venue_analytics (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    venue_id uuid,
    date date NOT NULL,
    ticket_sales integer DEFAULT 0,
    revenue numeric(10,2) DEFAULT 0,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: venue_balances; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.venue_balances (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    venue_id uuid,
    amount numeric(10,2) DEFAULT 0 NOT NULL,
    balance_type character varying(20) NOT NULL,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: venue_blackout_dates; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.venue_blackout_dates (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    venue_id uuid NOT NULL,
    blackout_name character varying(200) NOT NULL,
    start_date date NOT NULL,
    end_date date NOT NULL,
    blackout_type character varying(100) NOT NULL,
    affects character varying(100)[] DEFAULT '{all}'::character varying[],
    reason text,
    restrictions jsonb DEFAULT '{}'::jsonb,
    allows_override boolean DEFAULT false NOT NULL,
    override_conditions jsonb,
    is_recurring boolean DEFAULT false NOT NULL,
    recurrence_pattern jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by_user_id uuid,
    CONSTRAINT venue_blackout_dates_valid_period CHECK ((end_date >= start_date))
);



--
-- Name: TABLE venue_blackout_dates; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.venue_blackout_dates IS 'Venue unavailability periods and restrictions';


--
-- Name: venue_compliance; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.venue_compliance (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    venue_id uuid,
    compliance_type character varying(100),
    status character varying(50),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: venue_custom_categories; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.venue_custom_categories (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    venue_id uuid NOT NULL,
    category_id uuid NOT NULL,
    custom_name character varying(100),
    custom_description text,
    custom_icon character varying(50),
    custom_color character varying(7),
    is_enabled boolean DEFAULT true,
    sort_order integer DEFAULT 0,
    pricing_modifier numeric(5,4) DEFAULT 1.0000,
    capacity_modifier numeric(5,4) DEFAULT 1.0000,
    special_requirements text,
    created_by uuid,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: TABLE venue_custom_categories; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.venue_custom_categories IS 'Venue-specific category customizations and branding';


--
-- Name: venue_documents; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.venue_documents (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    venue_id uuid,
    document_type character varying(100),
    document_url text,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: venue_integrations; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.venue_integrations (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    venue_id uuid NOT NULL,
    integration_type character varying(50) NOT NULL,
    integration_name character varying(100) NOT NULL,
    is_active boolean DEFAULT true,
    api_key_encrypted text,
    api_secret_encrypted text,
    webhook_endpoint text,
    config_data jsonb DEFAULT '{}'::jsonb,
    sync_enabled boolean DEFAULT false,
    sync_frequency character varying(20),
    last_sync_at timestamp with time zone,
    last_sync_status character varying(20),
    last_sync_error text,
    field_mappings jsonb DEFAULT '{}'::jsonb,
    rate_limit integer,
    rate_limit_window integer,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: TABLE venue_integrations; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.venue_integrations IS 'Third-party system integration settings and credentials';


--
-- Name: COLUMN venue_integrations.sync_frequency; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.venue_integrations.sync_frequency IS 'Sync frequency: how often data synchronization occurs';


--
-- Name: venue_layouts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.venue_layouts (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    venue_id uuid NOT NULL,
    name character varying(200) NOT NULL,
    description text,
    layout_type character varying(50) NOT NULL,
    is_default boolean DEFAULT false,
    is_active boolean DEFAULT true,
    total_capacity integer NOT NULL,
    seated_capacity integer,
    standing_capacity integer,
    accessible_capacity integer,
    svg_data text,
    seat_map jsonb,
    sections jsonb DEFAULT '[]'::jsonb NOT NULL,
    price_tiers jsonb DEFAULT '[]'::jsonb,
    stage_location character varying(20),
    stage_dimensions jsonb,
    entry_points jsonb DEFAULT '[]'::jsonb,
    exit_points jsonb DEFAULT '[]'::jsonb,
    emergency_exits jsonb DEFAULT '[]'::jsonb,
    restroom_locations jsonb DEFAULT '[]'::jsonb,
    concession_locations jsonb DEFAULT '[]'::jsonb,
    merchandise_locations jsonb DEFAULT '[]'::jsonb,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_by uuid,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: TABLE venue_layouts; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.venue_layouts IS 'Master venue layout configurations with seating and standing arrangements';


--
-- Name: COLUMN venue_layouts.svg_data; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.venue_layouts.svg_data IS 'SVG representation: scalable vector graphics for layout visualization';


--
-- Name: venue_notification_templates; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.venue_notification_templates (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    venue_id uuid NOT NULL,
    template_name character varying(200) NOT NULL,
    template_type character varying(100) NOT NULL,
    template_category character varying(100),
    subject_template text,
    body_template text NOT NULL,
    html_template text,
    sms_template text,
    supported_channels character varying(50)[] DEFAULT '{email}'::character varying[],
    variables jsonb DEFAULT '{}'::jsonb,
    is_active boolean DEFAULT true NOT NULL,
    is_default boolean DEFAULT false NOT NULL,
    send_immediately boolean DEFAULT false NOT NULL,
    personalization_rules jsonb DEFAULT '{}'::jsonb,
    conditional_content jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by_user_id uuid
);



--
-- Name: TABLE venue_notification_templates; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.venue_notification_templates IS 'Customizable notification templates for venue communications';


--
-- Name: venue_operating_hours; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.venue_operating_hours (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    venue_id uuid NOT NULL,
    day_of_week integer NOT NULL,
    is_open boolean DEFAULT true NOT NULL,
    open_time time without time zone,
    close_time time without time zone,
    is_24_hours boolean DEFAULT false NOT NULL,
    notes text,
    effective_from date,
    effective_until date,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT venue_hours_valid_dates CHECK (((effective_from IS NULL) OR (effective_until IS NULL) OR (effective_from <= effective_until))),
    CONSTRAINT venue_hours_valid_day CHECK (((day_of_week >= 0) AND (day_of_week <= 6))),
    CONSTRAINT venue_hours_valid_times CHECK (((NOT is_open) OR is_24_hours OR ((open_time IS NOT NULL) AND (close_time IS NOT NULL))))
);



--
-- Name: TABLE venue_operating_hours; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.venue_operating_hours IS 'Venue operating hours and availability schedule';


--
-- Name: venue_payout_accounts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.venue_payout_accounts (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    venue_id uuid NOT NULL,
    account_type character varying(50) NOT NULL,
    account_details jsonb NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    is_verified boolean DEFAULT false NOT NULL,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    verified_at timestamp with time zone
);



--
-- Name: venue_policies; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.venue_policies (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    venue_id uuid NOT NULL,
    policy_type character varying(100) NOT NULL,
    policy_name character varying(200) NOT NULL,
    policy_description text,
    policy_text text NOT NULL,
    policy_summary text,
    policy_rules jsonb,
    is_mandatory boolean DEFAULT true NOT NULL,
    is_default boolean DEFAULT false NOT NULL,
    applies_to character varying(100)[],
    effective_from timestamp with time zone DEFAULT now() NOT NULL,
    effective_until timestamp with time zone,
    version character varying(20) DEFAULT '1.0'::character varying NOT NULL,
    previous_version_id uuid,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by_user_id uuid,
    CONSTRAINT venue_policies_valid_dates CHECK (((effective_until IS NULL) OR (effective_until > effective_from)))
);



--
-- Name: TABLE venue_policies; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.venue_policies IS 'Venue-specific policies and terms (refund, cancellation, etc.)';


--
-- Name: venue_pricing_rules; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.venue_pricing_rules (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    tenant_id uuid,
    venue_id uuid NOT NULL,
    rule_name character varying(200) NOT NULL,
    rule_type character varying(100) NOT NULL,
    rule_description text,
    conditions jsonb NOT NULL,
    priority integer DEFAULT 0 NOT NULL,
    base_price numeric(10,2),
    price_modifier_type character varying(50),
    price_modifier_value numeric(10,4),
    minimum_price numeric(10,2),
    maximum_price numeric(10,2),
    fees jsonb DEFAULT '{}'::jsonb,
    discounts jsonb DEFAULT '{}'::jsonb,
    applies_to character varying(100)[],
    excludes character varying(100)[],
    effective_from timestamp with time zone DEFAULT now() NOT NULL,
    effective_until timestamp with time zone,
    is_active boolean DEFAULT true NOT NULL,
    is_combinable boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by_user_id uuid,
    CONSTRAINT venue_pricing_rules_priority_positive CHECK ((priority >= 0)),
    CONSTRAINT venue_pricing_rules_valid_dates CHECK (((effective_until IS NULL) OR (effective_until > effective_from))),
    CONSTRAINT venue_pricing_rules_valid_prices CHECK (((minimum_price IS NULL) OR (maximum_price IS NULL) OR (minimum_price <= maximum_price)))
);



--
-- Name: TABLE venue_pricing_rules; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.venue_pricing_rules IS 'Dynamic pricing rules and fee structures for venues';


--
-- Name: venue_settings; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.venue_settings (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    venue_id uuid NOT NULL,
    allow_print_at_home boolean DEFAULT true,
    allow_mobile_tickets boolean DEFAULT true,
    require_id_verification boolean DEFAULT false,
    ticket_transfer_allowed boolean DEFAULT true,
    ticket_resale_allowed boolean DEFAULT true,
    max_tickets_per_order integer DEFAULT 10,
    service_fee_percentage numeric(5,2) DEFAULT 2.50,
    facility_fee_amount numeric(10,2) DEFAULT 0.00,
    processing_fee_percentage numeric(5,2) DEFAULT 2.95,
    payment_methods jsonb DEFAULT '["credit_card", "crypto"]'::jsonb,
    accepted_currencies text[] DEFAULT ARRAY['USD'::text, 'SOL'::text],
    payout_frequency character varying(20) DEFAULT 'weekly'::character varying,
    minimum_payout_amount numeric(10,2) DEFAULT 100.00,
    email_notifications jsonb DEFAULT '{"payout": true, "review": true, "new_order": true, "cancellation": true}'::jsonb,
    webhook_url text,
    webhook_secret character varying(255),
    google_analytics_id character varying(50),
    facebook_pixel_id character varying(50),
    custom_tracking_code text,
    require_2fa boolean DEFAULT false,
    ip_whitelist inet[],
    api_rate_limit integer DEFAULT 1000,
    primary_color character varying(7),
    secondary_color character varying(7),
    custom_css text,
    custom_js text,
    check_in_method character varying(20) DEFAULT 'qr_code'::character varying,
    early_entry_minutes integer DEFAULT 30,
    late_entry_minutes integer DEFAULT 60,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: TABLE venue_settings; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.venue_settings IS 'Flexible venue configuration system with key-value storage and version control';


--
-- Name: venue_staff; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.venue_staff (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    venue_id uuid NOT NULL,
    user_id uuid NOT NULL,
    role character varying(50) NOT NULL,
    permissions jsonb DEFAULT '[]'::jsonb,
    department character varying(100),
    job_title character varying(100),
    employment_type character varying(20),
    start_date date DEFAULT CURRENT_DATE NOT NULL,
    end_date date,
    is_active boolean DEFAULT true,
    access_areas text[],
    shift_schedule jsonb,
    pin_code character varying(6),
    contact_email character varying(255),
    contact_phone character varying(20),
    emergency_contact jsonb,
    hourly_rate numeric(10,2),
    commission_percentage numeric(5,2),
    added_by uuid,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_staff_role CHECK (((role)::text = ANY (ARRAY[('owner'::character varying)::text, ('manager'::character varying)::text, ('assistant_manager'::character varying)::text, ('box_office'::character varying)::text, ('security'::character varying)::text, ('maintenance'::character varying)::text, ('marketing'::character varying)::text, ('finance'::character varying)::text, ('other'::character varying)::text])))
);



--
-- Name: TABLE venue_staff; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.venue_staff IS 'Comprehensive venue staff management with roles, permissions, and employment tracking';


--
-- Name: venue_staff_employee_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.venue_staff_employee_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;



--
-- Name: wallet_addresses; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.wallet_addresses (
    id uuid DEFAULT public.uuid_generate_v1() NOT NULL,
    user_id uuid NOT NULL,
    wallet_address character varying(44) NOT NULL,
    blockchain character varying(20) DEFAULT 'solana'::character varying,
    type character varying(20) NOT NULL,
    is_primary boolean DEFAULT false,
    is_verified boolean DEFAULT false,
    verification_signature text,
    verification_message text,
    verification_timestamp timestamp with time zone,
    label character varying(100),
    wallet_name character varying(100),
    last_used_at timestamp with time zone,
    transaction_count integer DEFAULT 0,
    total_volume numeric(20,8),
    risk_score integer DEFAULT 0,
    suspicious_activity boolean DEFAULT false,
    domain_name character varying(100),
    domain_verified boolean DEFAULT false,
    linked_device_id uuid,
    device_fingerprint character varying(64),
    last_session_id uuid,
    last_ip_address inet,
    is_blocked boolean DEFAULT false,
    blocked_reason text,
    blocked_at timestamp with time zone,
    transaction_notifications boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_wallet_type CHECK (((type)::text = ANY (ARRAY[('phantom'::character varying)::text, ('solflare'::character varying)::text, ('ledger'::character varying)::text, ('backpack'::character varying)::text, ('metamask'::character varying)::text, ('other'::character varying)::text])))
);



--
-- Name: TABLE wallet_addresses; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.wallet_addresses IS 'Manages user wallet addresses for blockchain interactions with verification and security features';


--
-- Name: COLUMN wallet_addresses.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.id IS 'Unique identifier for the wallet record';


--
-- Name: COLUMN wallet_addresses.user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.user_id IS 'Reference to the user who owns this wallet';


--
-- Name: COLUMN wallet_addresses.wallet_address; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.wallet_address IS 'Blockchain wallet address (base58 for Solana)';


--
-- Name: COLUMN wallet_addresses.blockchain; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.blockchain IS 'Blockchain network (default: solana)';


--
-- Name: COLUMN wallet_addresses.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.type IS 'Type of wallet provider used';


--
-- Name: COLUMN wallet_addresses.is_primary; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.is_primary IS 'Whether this is the users primary wallet for this blockchain';


--
-- Name: COLUMN wallet_addresses.is_verified; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.is_verified IS 'Whether wallet ownership has been cryptographically verified';


--
-- Name: COLUMN wallet_addresses.verification_signature; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.verification_signature IS 'Cryptographic signature proving wallet ownership';


--
-- Name: COLUMN wallet_addresses.verification_message; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.verification_message IS 'Message that was signed for verification';


--
-- Name: COLUMN wallet_addresses.verification_timestamp; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.verification_timestamp IS 'When the wallet was verified';


--
-- Name: COLUMN wallet_addresses.label; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.label IS 'User-defined label for easy identification';


--
-- Name: COLUMN wallet_addresses.wallet_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.wallet_name IS 'Detected wallet provider name';


--
-- Name: COLUMN wallet_addresses.last_used_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.last_used_at IS 'Last time this wallet was used for a transaction';


--
-- Name: COLUMN wallet_addresses.transaction_count; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.transaction_count IS 'Total number of transactions from this wallet';


--
-- Name: COLUMN wallet_addresses.total_volume; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.total_volume IS 'Total transaction volume in native currency';


--
-- Name: COLUMN wallet_addresses.risk_score; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.risk_score IS 'Calculated risk score (0-100)';


--
-- Name: COLUMN wallet_addresses.suspicious_activity; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.suspicious_activity IS 'Flag indicating suspicious behavior detected';


--
-- Name: COLUMN wallet_addresses.domain_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.domain_name IS 'Associated blockchain domain name (e.g., .sol)';


--
-- Name: COLUMN wallet_addresses.domain_verified; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.domain_verified IS 'Whether domain ownership is verified';


--
-- Name: COLUMN wallet_addresses.linked_device_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.linked_device_id IS 'Reference to the device this wallet is linked to';


--
-- Name: COLUMN wallet_addresses.device_fingerprint; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.device_fingerprint IS 'Hashed device fingerprint for security';


--
-- Name: COLUMN wallet_addresses.last_session_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.last_session_id IS 'Last session that used this wallet';


--
-- Name: COLUMN wallet_addresses.last_ip_address; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.last_ip_address IS 'Last IP address that accessed this wallet';


--
-- Name: COLUMN wallet_addresses.is_blocked; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.is_blocked IS 'Whether this wallet is blocked from use';


--
-- Name: COLUMN wallet_addresses.blocked_reason; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.blocked_reason IS 'Reason for blocking the wallet';


--
-- Name: COLUMN wallet_addresses.blocked_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.blocked_at IS 'When the wallet was blocked';


--
-- Name: COLUMN wallet_addresses.transaction_notifications; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.transaction_notifications IS 'Whether to send notifications for wallet transactions';


--
-- Name: COLUMN wallet_addresses.created_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.created_at IS 'Timestamp when this record was created';


--
-- Name: COLUMN wallet_addresses.updated_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.wallet_addresses.updated_at IS 'Timestamp when this record was last updated';


--
-- Name: webhook_deliveries; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.webhook_deliveries (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    webhook_event_id uuid,
    delivered_at timestamp without time zone,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: webhook_endpoints; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.webhook_endpoints (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    url text,
    active boolean DEFAULT true,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: webhook_events; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.webhook_events (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    provider character varying(50) NOT NULL,
    event_type character varying(100) NOT NULL,
    payload jsonb NOT NULL,
    processed boolean DEFAULT false,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: webhook_inbox; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.webhook_inbox (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    source character varying(100) NOT NULL,
    event_type character varying(100) NOT NULL,
    payload jsonb NOT NULL,
    processed boolean DEFAULT false,
    processed_at timestamp without time zone,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);



--
-- Name: customer_tax_records id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.customer_tax_records ALTER COLUMN id SET DEFAULT nextval('public.customer_tax_records_id_seq'::regclass);


--
-- Name: data_retention_policies id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.data_retention_policies ALTER COLUMN id SET DEFAULT nextval('public.data_retention_policies_id_seq'::regclass);


--
-- Name: gdpr_deletion_requests id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.gdpr_deletion_requests ALTER COLUMN id SET DEFAULT nextval('public.gdpr_deletion_requests_id_seq'::regclass);


--
-- Name: pci_access_logs id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.pci_access_logs ALTER COLUMN id SET DEFAULT nextval('public.pci_access_logs_id_seq'::regclass);


--
-- Name: state_compliance_rules id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.state_compliance_rules ALTER COLUMN id SET DEFAULT nextval('public.state_compliance_rules_id_seq'::regclass);


--
-- Name: tax_reporting_requirements id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tax_reporting_requirements ALTER COLUMN id SET DEFAULT nextval('public.tax_reporting_requirements_id_seq'::regclass);


--
-- Name: audit_log audit_log_pkey; Type: CONSTRAINT; Schema: audit; Owner: postgres
--

ALTER TABLE ONLY audit.audit_log
    ADD CONSTRAINT audit_log_pkey PRIMARY KEY (id);


--
-- Name: aml_checks aml_checks_pkey; Type: CONSTRAINT; Schema: compliance; Owner: postgres
--

ALTER TABLE ONLY compliance.aml_checks
    ADD CONSTRAINT aml_checks_pkey PRIMARY KEY (id);


--
-- Name: compliance_reports compliance_reports_pkey; Type: CONSTRAINT; Schema: compliance; Owner: postgres
--

ALTER TABLE ONLY compliance.compliance_reports
    ADD CONSTRAINT compliance_reports_pkey PRIMARY KEY (id);


--
-- Name: compliance_reports compliance_reports_report_number_key; Type: CONSTRAINT; Schema: compliance; Owner: postgres
--

ALTER TABLE ONLY compliance.compliance_reports
    ADD CONSTRAINT compliance_reports_report_number_key UNIQUE (report_number);


--
-- Name: data_retention data_retention_pkey; Type: CONSTRAINT; Schema: compliance; Owner: postgres
--

ALTER TABLE ONLY compliance.data_retention
    ADD CONSTRAINT data_retention_pkey PRIMARY KEY (id);


--
-- Name: data_retention data_retention_policy_name_key; Type: CONSTRAINT; Schema: compliance; Owner: postgres
--

ALTER TABLE ONLY compliance.data_retention
    ADD CONSTRAINT data_retention_policy_name_key UNIQUE (policy_name);


--
-- Name: kyc_records kyc_records_pkey; Type: CONSTRAINT; Schema: compliance; Owner: postgres
--

ALTER TABLE ONLY compliance.kyc_records
    ADD CONSTRAINT kyc_records_pkey PRIMARY KEY (id);


--
-- Name: sanctions_screening sanctions_screening_pkey; Type: CONSTRAINT; Schema: compliance; Owner: postgres
--

ALTER TABLE ONLY compliance.sanctions_screening
    ADD CONSTRAINT sanctions_screening_pkey PRIMARY KEY (id);


--
-- Name: api_credentials api_credentials_pkey; Type: CONSTRAINT; Schema: integrations; Owner: postgres
--

ALTER TABLE ONLY integrations.api_credentials
    ADD CONSTRAINT api_credentials_pkey PRIMARY KEY (id);


--
-- Name: external_references external_references_pkey; Type: CONSTRAINT; Schema: integrations; Owner: postgres
--

ALTER TABLE ONLY integrations.external_references
    ADD CONSTRAINT external_references_pkey PRIMARY KEY (id);


--
-- Name: integration_mappings integration_mappings_pkey; Type: CONSTRAINT; Schema: integrations; Owner: postgres
--

ALTER TABLE ONLY integrations.integration_mappings
    ADD CONSTRAINT integration_mappings_pkey PRIMARY KEY (id);


--
-- Name: sync_logs sync_logs_pkey; Type: CONSTRAINT; Schema: integrations; Owner: postgres
--

ALTER TABLE ONLY integrations.sync_logs
    ADD CONSTRAINT sync_logs_pkey PRIMARY KEY (id);


--
-- Name: sync_logs sync_logs_sync_id_key; Type: CONSTRAINT; Schema: integrations; Owner: postgres
--

ALTER TABLE ONLY integrations.sync_logs
    ADD CONSTRAINT sync_logs_sync_id_key UNIQUE (sync_id);


--
-- Name: api_credentials uq_api_credentials_provider_env; Type: CONSTRAINT; Schema: integrations; Owner: postgres
--

ALTER TABLE ONLY integrations.api_credentials
    ADD CONSTRAINT uq_api_credentials_provider_env UNIQUE (provider_name, environment);


--
-- Name: external_references uq_external_references_mapping; Type: CONSTRAINT; Schema: integrations; Owner: postgres
--

ALTER TABLE ONLY integrations.external_references
    ADD CONSTRAINT uq_external_references_mapping UNIQUE (internal_entity_type, internal_entity_id, external_system);


--
-- Name: webhook_endpoints webhook_endpoints_pkey; Type: CONSTRAINT; Schema: integrations; Owner: postgres
--

ALTER TABLE ONLY integrations.webhook_endpoints
    ADD CONSTRAINT webhook_endpoints_pkey PRIMARY KEY (id);


--
-- Name: webhook_endpoints webhook_endpoints_url_key; Type: CONSTRAINT; Schema: integrations; Owner: postgres
--

ALTER TABLE ONLY integrations.webhook_endpoints
    ADD CONSTRAINT webhook_endpoints_url_key UNIQUE (url);


--
-- Name: royalty_settlements royalty_settlements_pkey; Type: CONSTRAINT; Schema: marketplace; Owner: postgres
--

ALTER TABLE ONLY marketplace.royalty_settlements
    ADD CONSTRAINT royalty_settlements_pkey PRIMARY KEY (id);


--
-- Name: campaigns campaigns_pkey; Type: CONSTRAINT; Schema: notifications; Owner: postgres
--

ALTER TABLE ONLY notifications.campaigns
    ADD CONSTRAINT campaigns_pkey PRIMARY KEY (id);


--
-- Name: campaigns campaigns_slug_key; Type: CONSTRAINT; Schema: notifications; Owner: postgres
--

ALTER TABLE ONLY notifications.campaigns
    ADD CONSTRAINT campaigns_slug_key UNIQUE (slug);


--
-- Name: delivery_tracking delivery_tracking_message_id_key; Type: CONSTRAINT; Schema: notifications; Owner: postgres
--

ALTER TABLE ONLY notifications.delivery_tracking
    ADD CONSTRAINT delivery_tracking_message_id_key UNIQUE (message_id);


--
-- Name: delivery_tracking delivery_tracking_pkey; Type: CONSTRAINT; Schema: notifications; Owner: postgres
--

ALTER TABLE ONLY notifications.delivery_tracking
    ADD CONSTRAINT delivery_tracking_pkey PRIMARY KEY (id);


--
-- Name: notification_history notification_history_pkey; Type: CONSTRAINT; Schema: notifications; Owner: postgres
--

ALTER TABLE ONLY notifications.notification_history
    ADD CONSTRAINT notification_history_pkey PRIMARY KEY (id);


--
-- Name: notification_preferences notification_preferences_pkey; Type: CONSTRAINT; Schema: notifications; Owner: postgres
--

ALTER TABLE ONLY notifications.notification_preferences
    ADD CONSTRAINT notification_preferences_pkey PRIMARY KEY (id);


--
-- Name: notification_preferences notification_preferences_unsubscribe_token_key; Type: CONSTRAINT; Schema: notifications; Owner: postgres
--

ALTER TABLE ONLY notifications.notification_preferences
    ADD CONSTRAINT notification_preferences_unsubscribe_token_key UNIQUE (unsubscribe_token);


--
-- Name: notification_preferences uq_notification_preferences_customer_profile_id; Type: CONSTRAINT; Schema: notifications; Owner: postgres
--

ALTER TABLE ONLY notifications.notification_preferences
    ADD CONSTRAINT uq_notification_preferences_customer_profile_id UNIQUE (customer_profile_id);


--
-- Name: agreements agreements_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.agreements
    ADD CONSTRAINT agreements_pkey PRIMARY KEY (id);


--
-- Name: alerts alerts_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alerts
    ADD CONSTRAINT alerts_pkey PRIMARY KEY (id);


--
-- Name: aml_checks aml_checks_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.aml_checks
    ADD CONSTRAINT aml_checks_pkey PRIMARY KEY (id);


--
-- Name: analytics_events analytics_events_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.analytics_events
    ADD CONSTRAINT analytics_events_pkey PRIMARY KEY (id);


--
-- Name: analytics_jobs analytics_jobs_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.analytics_jobs
    ADD CONSTRAINT analytics_jobs_pkey PRIMARY KEY (id);


--
-- Name: api_credentials api_credentials_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.api_credentials
    ADD CONSTRAINT api_credentials_pkey PRIMARY KEY (id);


--
-- Name: api_keys api_keys_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.api_keys
    ADD CONSTRAINT api_keys_pkey PRIMARY KEY (id);


--
-- Name: audit_log_alerts audit_log_alerts_alert_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.audit_log_alerts
    ADD CONSTRAINT audit_log_alerts_alert_name_key UNIQUE (alert_name);


--
-- Name: audit_log_alerts audit_log_alerts_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.audit_log_alerts
    ADD CONSTRAINT audit_log_alerts_pkey PRIMARY KEY (id);


--
-- Name: audit_log_entries audit_log_entries_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.audit_log_entries
    ADD CONSTRAINT audit_log_entries_pkey PRIMARY KEY (id);


--
-- Name: audit_log audit_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.audit_log
    ADD CONSTRAINT audit_log_pkey PRIMARY KEY (id);


--
-- Name: audit_log_summaries audit_log_summaries_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.audit_log_summaries
    ADD CONSTRAINT audit_log_summaries_pkey PRIMARY KEY (id);


--
-- Name: audit_log_summaries audit_log_summaries_summary_date_summary_type_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.audit_log_summaries
    ADD CONSTRAINT audit_log_summaries_summary_date_summary_type_key UNIQUE (summary_date, summary_type);


--
-- Name: audit_logs audit_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.audit_logs
    ADD CONSTRAINT audit_logs_pkey PRIMARY KEY (id);


--
-- Name: background_jobs background_jobs_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.background_jobs
    ADD CONSTRAINT background_jobs_pkey PRIMARY KEY (id);


--
-- Name: blockchain_transactions blockchain_transactions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.blockchain_transactions
    ADD CONSTRAINT blockchain_transactions_pkey PRIMARY KEY (id);


--
-- Name: blockchain_transactions blockchain_transactions_transaction_signature_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.blockchain_transactions
    ADD CONSTRAINT blockchain_transactions_transaction_signature_key UNIQUE (transaction_signature);


--
-- Name: campaigns campaigns_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.campaigns
    ADD CONSTRAINT campaigns_pkey PRIMARY KEY (id);


--
-- Name: loyalty_programs chk_single_default; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.loyalty_programs
    ADD CONSTRAINT chk_single_default EXCLUDE USING btree (is_default WITH =) WHERE ((is_default = true));


--
-- Name: commissions commissions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.commissions
    ADD CONSTRAINT commissions_pkey PRIMARY KEY (id);


--
-- Name: communications_log communications_log_message_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.communications_log
    ADD CONSTRAINT communications_log_message_id_key UNIQUE (message_id);


--
-- Name: communications_log communications_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.communications_log
    ADD CONSTRAINT communications_log_pkey PRIMARY KEY (id);


--
-- Name: compliance_inspections compliance_inspections_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.compliance_inspections
    ADD CONSTRAINT compliance_inspections_pkey PRIMARY KEY (id);


--
-- Name: compliance_reminders compliance_reminders_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.compliance_reminders
    ADD CONSTRAINT compliance_reminders_pkey PRIMARY KEY (id);


--
-- Name: compliance_violations compliance_violations_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.compliance_violations
    ADD CONSTRAINT compliance_violations_pkey PRIMARY KEY (id);


--
-- Name: critical_jobs critical_jobs_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.critical_jobs
    ADD CONSTRAINT critical_jobs_pkey PRIMARY KEY (id);


--
-- Name: customer_analytics customer_analytics_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.customer_analytics
    ADD CONSTRAINT customer_analytics_pkey PRIMARY KEY (id);


--
-- Name: customer_feedback customer_feedback_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.customer_feedback
    ADD CONSTRAINT customer_feedback_pkey PRIMARY KEY (id);


--
-- Name: customer_ltv customer_ltv_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.customer_ltv
    ADD CONSTRAINT customer_ltv_pkey PRIMARY KEY (id);


--
-- Name: customer_preferences customer_preferences_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.customer_preferences
    ADD CONSTRAINT customer_preferences_pkey PRIMARY KEY (customer_id);


--
-- Name: customer_profiles customer_profiles_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.customer_profiles
    ADD CONSTRAINT customer_profiles_pkey PRIMARY KEY (customer_id);


--
-- Name: customer_segments customer_segments_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.customer_segments
    ADD CONSTRAINT customer_segments_pkey PRIMARY KEY (id);


--
-- Name: customer_tax_records customer_tax_records_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.customer_tax_records
    ADD CONSTRAINT customer_tax_records_pkey PRIMARY KEY (id);


--
-- Name: data_breach_notifications data_breach_notifications_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.data_breach_notifications
    ADD CONSTRAINT data_breach_notifications_pkey PRIMARY KEY (id);


--
-- Name: data_deletion_requests data_deletion_requests_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.data_deletion_requests
    ADD CONSTRAINT data_deletion_requests_pkey PRIMARY KEY (id);


--
-- Name: data_export_requests data_export_requests_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.data_export_requests
    ADD CONSTRAINT data_export_requests_pkey PRIMARY KEY (id);


--
-- Name: data_retention data_retention_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.data_retention
    ADD CONSTRAINT data_retention_pkey PRIMARY KEY (id);


--
-- Name: data_retention_policies data_retention_policies_data_type_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.data_retention_policies
    ADD CONSTRAINT data_retention_policies_data_type_key UNIQUE (data_type);


--
-- Name: data_retention_policies data_retention_policies_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.data_retention_policies
    ADD CONSTRAINT data_retention_policies_pkey PRIMARY KEY (id);


--
-- Name: dead_letter_jobs dead_letter_jobs_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dead_letter_jobs
    ADD CONSTRAINT dead_letter_jobs_pkey PRIMARY KEY (id);


--
-- Name: dead_letter_queue dead_letter_queue_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dead_letter_queue
    ADD CONSTRAINT dead_letter_queue_pkey PRIMARY KEY (id);


--
-- Name: delivery_tracking delivery_tracking_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.delivery_tracking
    ADD CONSTRAINT delivery_tracking_pkey PRIMARY KEY (id);


--
-- Name: dispute_evidence_packs dispute_evidence_packs_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dispute_evidence_packs
    ADD CONSTRAINT dispute_evidence_packs_pkey PRIMARY KEY (id);


--
-- Name: dispute_messages dispute_messages_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dispute_messages
    ADD CONSTRAINT dispute_messages_pkey PRIMARY KEY (id);


--
-- Name: dispute_resolution dispute_resolution_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dispute_resolution
    ADD CONSTRAINT dispute_resolution_pkey PRIMARY KEY (id);


--
-- Name: escrow escrow_marketplace_transaction_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.escrow
    ADD CONSTRAINT escrow_marketplace_transaction_id_key UNIQUE (marketplace_transaction_id);


--
-- Name: escrow escrow_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.escrow
    ADD CONSTRAINT escrow_pkey PRIMARY KEY (id);


--
-- Name: event_analytics event_analytics_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_analytics
    ADD CONSTRAINT event_analytics_pkey PRIMARY KEY (id);


--
-- Name: event_analytics_tracking event_analytics_tracking_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_analytics_tracking
    ADD CONSTRAINT event_analytics_tracking_pkey PRIMARY KEY (id);


--
-- Name: event_capacity_alerts event_capacity_alerts_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_alerts
    ADD CONSTRAINT event_capacity_alerts_pkey PRIMARY KEY (id);


--
-- Name: event_capacity_by_tier event_capacity_by_tier_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_by_tier
    ADD CONSTRAINT event_capacity_by_tier_pkey PRIMARY KEY (id);


--
-- Name: event_capacity_by_type event_capacity_by_type_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_by_type
    ADD CONSTRAINT event_capacity_by_type_pkey PRIMARY KEY (id);


--
-- Name: event_capacity_holds event_capacity_holds_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_holds
    ADD CONSTRAINT event_capacity_holds_pkey PRIMARY KEY (id);


--
-- Name: event_capacity_oversell_policies event_capacity_oversell_policies_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_oversell_policies
    ADD CONSTRAINT event_capacity_oversell_policies_pkey PRIMARY KEY (id);


--
-- Name: event_capacity event_capacity_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity
    ADD CONSTRAINT event_capacity_pkey PRIMARY KEY (id);


--
-- Name: event_capacity_reservations event_capacity_reservations_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_reservations
    ADD CONSTRAINT event_capacity_reservations_pkey PRIMARY KEY (id);


--
-- Name: event_capacity_snapshots event_capacity_snapshots_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_snapshots
    ADD CONSTRAINT event_capacity_snapshots_pkey PRIMARY KEY (id);


--
-- Name: event_capacity_utilization_history event_capacity_utilization_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_utilization_history
    ADD CONSTRAINT event_capacity_utilization_history_pkey PRIMARY KEY (id);


--
-- Name: event_categories event_categories_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_categories
    ADD CONSTRAINT event_categories_pkey PRIMARY KEY (id);


--
-- Name: event_categories event_categories_slug_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_categories
    ADD CONSTRAINT event_categories_slug_key UNIQUE (slug);


--
-- Name: event_category_analytics event_category_analytics_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_category_analytics
    ADD CONSTRAINT event_category_analytics_pkey PRIMARY KEY (id);


--
-- Name: event_category_attributes event_category_attributes_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_category_attributes
    ADD CONSTRAINT event_category_attributes_pkey PRIMARY KEY (id);


--
-- Name: event_category_mappings event_category_mappings_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_category_mappings
    ADD CONSTRAINT event_category_mappings_pkey PRIMARY KEY (id);


--
-- Name: event_category_search_suggestions event_category_search_suggestions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_category_search_suggestions
    ADD CONSTRAINT event_category_search_suggestions_pkey PRIMARY KEY (id);


--
-- Name: event_category_tags event_category_tags_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_category_tags
    ADD CONSTRAINT event_category_tags_pkey PRIMARY KEY (id);


--
-- Name: event_category_trending event_category_trending_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_category_trending
    ADD CONSTRAINT event_category_trending_pkey PRIMARY KEY (id);


--
-- Name: event_custom_attributes event_custom_attributes_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_custom_attributes
    ADD CONSTRAINT event_custom_attributes_pkey PRIMARY KEY (id);


--
-- Name: event_marketing_campaigns event_marketing_campaigns_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_marketing_campaigns
    ADD CONSTRAINT event_marketing_campaigns_pkey PRIMARY KEY (id);


--
-- Name: event_metadata_history event_metadata_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_metadata_history
    ADD CONSTRAINT event_metadata_history_pkey PRIMARY KEY (id);


--
-- Name: event_metadata event_metadata_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_metadata
    ADD CONSTRAINT event_metadata_pkey PRIMARY KEY (id);


--
-- Name: event_metadata_templates event_metadata_templates_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_metadata_templates
    ADD CONSTRAINT event_metadata_templates_pkey PRIMARY KEY (id);


--
-- Name: event_performance event_performance_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_performance
    ADD CONSTRAINT event_performance_pkey PRIMARY KEY (id);


--
-- Name: event_performers event_performers_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_performers
    ADD CONSTRAINT event_performers_pkey PRIMARY KEY (id);


--
-- Name: event_pricing_demand_factors event_pricing_demand_factors_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_demand_factors
    ADD CONSTRAINT event_pricing_demand_factors_pkey PRIMARY KEY (id);


--
-- Name: event_pricing_dynamic_rules event_pricing_dynamic_rules_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_dynamic_rules
    ADD CONSTRAINT event_pricing_dynamic_rules_pkey PRIMARY KEY (id);


--
-- Name: event_pricing_group_discounts event_pricing_group_discounts_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_group_discounts
    ADD CONSTRAINT event_pricing_group_discounts_pkey PRIMARY KEY (id);


--
-- Name: event_pricing_history event_pricing_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_history
    ADD CONSTRAINT event_pricing_history_pkey PRIMARY KEY (id);


--
-- Name: event_pricing event_pricing_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing
    ADD CONSTRAINT event_pricing_pkey PRIMARY KEY (id);


--
-- Name: event_pricing_promo_codes event_pricing_promo_codes_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_promo_codes
    ADD CONSTRAINT event_pricing_promo_codes_pkey PRIMARY KEY (id);


--
-- Name: event_pricing_schedules event_pricing_schedules_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_schedules
    ADD CONSTRAINT event_pricing_schedules_pkey PRIMARY KEY (id);


--
-- Name: event_pricing_surge_thresholds event_pricing_surge_thresholds_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_surge_thresholds
    ADD CONSTRAINT event_pricing_surge_thresholds_pkey PRIMARY KEY (id);


--
-- Name: event_pricing_tiers event_pricing_tiers_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_tiers
    ADD CONSTRAINT event_pricing_tiers_pkey PRIMARY KEY (id);


--
-- Name: event_production_schedules event_production_schedules_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_production_schedules
    ADD CONSTRAINT event_production_schedules_pkey PRIMARY KEY (id);


--
-- Name: event_schedules event_schedules_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_schedules
    ADD CONSTRAINT event_schedules_pkey PRIMARY KEY (id);


--
-- Name: event_seo_metadata event_seo_metadata_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_seo_metadata
    ADD CONSTRAINT event_seo_metadata_pkey PRIMARY KEY (id);


--
-- Name: event_sessions event_sessions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_sessions
    ADD CONSTRAINT event_sessions_pkey PRIMARY KEY (id);


--
-- Name: event_social_media event_social_media_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_social_media
    ADD CONSTRAINT event_social_media_pkey PRIMARY KEY (id);


--
-- Name: event_tiers event_tiers_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_tiers
    ADD CONSTRAINT event_tiers_pkey PRIMARY KEY (id);


--
-- Name: events events_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.events
    ADD CONSTRAINT events_pkey PRIMARY KEY (id);


--
-- Name: external_references external_references_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.external_references
    ADD CONSTRAINT external_references_pkey PRIMARY KEY (id);


--
-- Name: failed_login_attempts failed_login_attempts_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.failed_login_attempts
    ADD CONSTRAINT failed_login_attempts_pkey PRIMARY KEY (id);


--
-- Name: feature_flags feature_flags_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.feature_flags
    ADD CONSTRAINT feature_flags_pkey PRIMARY KEY (id);


--
-- Name: feedback_responses feedback_responses_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.feedback_responses
    ADD CONSTRAINT feedback_responses_pkey PRIMARY KEY (id);


--
-- Name: file_access_logs file_access_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.file_access_logs
    ADD CONSTRAINT file_access_logs_pkey PRIMARY KEY (id);


--
-- Name: file_versions file_versions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.file_versions
    ADD CONSTRAINT file_versions_pkey PRIMARY KEY (id);


--
-- Name: files files_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.files
    ADD CONSTRAINT files_pkey PRIMARY KEY (id);


--
-- Name: financial_reports financial_reports_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.financial_reports
    ADD CONSTRAINT financial_reports_pkey PRIMARY KEY (id);


--
-- Name: fraud_prevention_rules fraud_prevention_rules_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.fraud_prevention_rules
    ADD CONSTRAINT fraud_prevention_rules_pkey PRIMARY KEY (id);


--
-- Name: fraud_prevention_rules fraud_prevention_rules_rule_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.fraud_prevention_rules
    ADD CONSTRAINT fraud_prevention_rules_rule_name_key UNIQUE (rule_name);


--
-- Name: gas_fee_tracking gas_fee_tracking_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.gas_fee_tracking
    ADD CONSTRAINT gas_fee_tracking_pkey PRIMARY KEY (id);


--
-- Name: gdpr_deletion_requests gdpr_deletion_requests_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.gdpr_deletion_requests
    ADD CONSTRAINT gdpr_deletion_requests_pkey PRIMARY KEY (id);


--
-- Name: health_checks health_checks_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.health_checks
    ADD CONSTRAINT health_checks_pkey PRIMARY KEY (id);


--
-- Name: idempotency_keys idempotency_keys_key_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.idempotency_keys
    ADD CONSTRAINT idempotency_keys_key_key UNIQUE (key);


--
-- Name: idempotency_keys idempotency_keys_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.idempotency_keys
    ADD CONSTRAINT idempotency_keys_pkey PRIMARY KEY (id);


--
-- Name: image_metadata image_metadata_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.image_metadata
    ADD CONSTRAINT image_metadata_pkey PRIMARY KEY (id);


--
-- Name: integration_data_mappings integration_data_mappings_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.integration_data_mappings
    ADD CONSTRAINT integration_data_mappings_pkey PRIMARY KEY (id);


--
-- Name: integration_data_mappings integration_data_mappings_unique_entity; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.integration_data_mappings
    ADD CONSTRAINT integration_data_mappings_unique_entity UNIQUE (integration_id, data_entity, mapping_direction);


--
-- Name: integration_logs integration_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.integration_logs
    ADD CONSTRAINT integration_logs_pkey PRIMARY KEY (id);


--
-- Name: integration_mappings integration_mappings_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.integration_mappings
    ADD CONSTRAINT integration_mappings_pkey PRIMARY KEY (id);


--
-- Name: integration_schedules integration_schedules_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.integration_schedules
    ADD CONSTRAINT integration_schedules_pkey PRIMARY KEY (id);


--
-- Name: integration_schedules integration_schedules_unique_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.integration_schedules
    ADD CONSTRAINT integration_schedules_unique_name UNIQUE (integration_id, schedule_name);


--
-- Name: integration_webhooks integration_webhooks_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.integration_webhooks
    ADD CONSTRAINT integration_webhooks_pkey PRIMARY KEY (id);


--
-- Name: integration_webhooks integration_webhooks_unique_url; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.integration_webhooks
    ADD CONSTRAINT integration_webhooks_unique_url UNIQUE (integration_id, webhook_url);


--
-- Name: international_fees international_fees_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.international_fees
    ADD CONSTRAINT international_fees_pkey PRIMARY KEY (id);


--
-- Name: invoices invoices_invoice_number_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoices
    ADD CONSTRAINT invoices_invoice_number_key UNIQUE (invoice_number);


--
-- Name: invoices invoices_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoices
    ADD CONSTRAINT invoices_pkey PRIMARY KEY (id);


--
-- Name: irs_filings irs_filings_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.irs_filings
    ADD CONSTRAINT irs_filings_pkey PRIMARY KEY (id);


--
-- Name: job_executions job_executions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.job_executions
    ADD CONSTRAINT job_executions_pkey PRIMARY KEY (id);


--
-- Name: kyc_records kyc_records_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.kyc_records
    ADD CONSTRAINT kyc_records_pkey PRIMARY KEY (id);


--
-- Name: layout_accessibility_features layout_accessibility_features_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.layout_accessibility_features
    ADD CONSTRAINT layout_accessibility_features_pkey PRIMARY KEY (id);


--
-- Name: layout_pricing_zones layout_pricing_zones_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.layout_pricing_zones
    ADD CONSTRAINT layout_pricing_zones_pkey PRIMARY KEY (id);


--
-- Name: layout_pricing_zones layout_pricing_zones_unique_code; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.layout_pricing_zones
    ADD CONSTRAINT layout_pricing_zones_unique_code UNIQUE (layout_id, zone_code);


--
-- Name: layout_seats layout_seats_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.layout_seats
    ADD CONSTRAINT layout_seats_pkey PRIMARY KEY (id);


--
-- Name: layout_seats layout_seats_unique_position; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.layout_seats
    ADD CONSTRAINT layout_seats_unique_position UNIQUE (section_id, row_identifier, seat_number);


--
-- Name: layout_sections layout_sections_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.layout_sections
    ADD CONSTRAINT layout_sections_pkey PRIMARY KEY (id);


--
-- Name: layout_sections layout_sections_unique_code; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.layout_sections
    ADD CONSTRAINT layout_sections_unique_code UNIQUE (layout_id, section_code);


--
-- Name: listings listings_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.listings
    ADD CONSTRAINT listings_pkey PRIMARY KEY (id);


--
-- Name: loyalty_accounts loyalty_accounts_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.loyalty_accounts
    ADD CONSTRAINT loyalty_accounts_pkey PRIMARY KEY (id);


--
-- Name: loyalty_programs loyalty_programs_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.loyalty_programs
    ADD CONSTRAINT loyalty_programs_name_key UNIQUE (name);


--
-- Name: loyalty_programs loyalty_programs_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.loyalty_programs
    ADD CONSTRAINT loyalty_programs_pkey PRIMARY KEY (id);


--
-- Name: loyalty_transactions loyalty_transactions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.loyalty_transactions
    ADD CONSTRAINT loyalty_transactions_pkey PRIMARY KEY (id);


--
-- Name: market_analytics market_analytics_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.market_analytics
    ADD CONSTRAINT market_analytics_pkey PRIMARY KEY (id);


--
-- Name: marketplace_transactions marketplace_transactions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.marketplace_transactions
    ADD CONSTRAINT marketplace_transactions_pkey PRIMARY KEY (id);


--
-- Name: nft_metadata nft_metadata_mint_address_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.nft_metadata
    ADD CONSTRAINT nft_metadata_mint_address_key UNIQUE (mint_address);


--
-- Name: nft_metadata nft_metadata_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.nft_metadata
    ADD CONSTRAINT nft_metadata_pkey PRIMARY KEY (id);


--
-- Name: nft_metadata nft_metadata_ticket_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.nft_metadata
    ADD CONSTRAINT nft_metadata_ticket_id_key UNIQUE (ticket_id);


--
-- Name: notification_history notification_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.notification_history
    ADD CONSTRAINT notification_history_pkey PRIMARY KEY (id);


--
-- Name: notification_preferences notification_preferences_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.notification_preferences
    ADD CONSTRAINT notification_preferences_pkey PRIMARY KEY (id);


--
-- Name: notification_queue notification_queue_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.notification_queue
    ADD CONSTRAINT notification_queue_pkey PRIMARY KEY (id);


--
-- Name: notification_templates notification_templates_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.notification_templates
    ADD CONSTRAINT notification_templates_pkey PRIMARY KEY (id);


--
-- Name: notifications notifications_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT notifications_pkey PRIMARY KEY (id);


--
-- Name: offers offers_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.offers
    ADD CONSTRAINT offers_pkey PRIMARY KEY (id);


--
-- Name: offline_validation_cache offline_validation_cache_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.offline_validation_cache
    ADD CONSTRAINT offline_validation_cache_pkey PRIMARY KEY (id);


--
-- Name: order_items order_items_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_items
    ADD CONSTRAINT order_items_pkey PRIMARY KEY (id);


--
-- Name: order_state_transitions order_state_transitions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_state_transitions
    ADD CONSTRAINT order_state_transitions_pkey PRIMARY KEY (id);


--
-- Name: orders orders_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.orders
    ADD CONSTRAINT orders_pkey PRIMARY KEY (id);


--
-- Name: outbox_events outbox_events_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.outbox_events
    ADD CONSTRAINT outbox_events_pkey PRIMARY KEY (id);


--
-- Name: outbox outbox_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.outbox
    ADD CONSTRAINT outbox_pkey PRIMARY KEY (id);


--
-- Name: payment_intents payment_intents_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.payment_intents
    ADD CONSTRAINT payment_intents_pkey PRIMARY KEY (id);


--
-- Name: payment_intents payment_intents_stripe_intent_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.payment_intents
    ADD CONSTRAINT payment_intents_stripe_intent_id_key UNIQUE (stripe_intent_id);


--
-- Name: payment_methods payment_methods_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.payment_methods
    ADD CONSTRAINT payment_methods_pkey PRIMARY KEY (id);


--
-- Name: pci_access_logs pci_access_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.pci_access_logs
    ADD CONSTRAINT pci_access_logs_pkey PRIMARY KEY (id);


--
-- Name: performance_metrics performance_metrics_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.performance_metrics
    ADD CONSTRAINT performance_metrics_pkey PRIMARY KEY (id);


--
-- Name: permission_dependencies permission_dependencies_permission_id_required_permission_i_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.permission_dependencies
    ADD CONSTRAINT permission_dependencies_permission_id_required_permission_i_key UNIQUE (permission_id, required_permission_id);


--
-- Name: permission_dependencies permission_dependencies_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.permission_dependencies
    ADD CONSTRAINT permission_dependencies_pkey PRIMARY KEY (id);


--
-- Name: permissions permissions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.permissions
    ADD CONSTRAINT permissions_pkey PRIMARY KEY (id);


--
-- Name: permissions permissions_resource_action_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.permissions
    ADD CONSTRAINT permissions_resource_action_key UNIQUE (resource, action);


--
-- Name: price_history price_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.price_history
    ADD CONSTRAINT price_history_pkey PRIMARY KEY (id);


--
-- Name: privacy_audit_log privacy_audit_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.privacy_audit_log
    ADD CONSTRAINT privacy_audit_log_pkey PRIMARY KEY (id);


--
-- Name: psp_reconciliations psp_reconciliations_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.psp_reconciliations
    ADD CONSTRAINT psp_reconciliations_pkey PRIMARY KEY (id);


--
-- Name: psp_reconciliations psp_reconciliations_provider_reconciliation_date_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.psp_reconciliations
    ADD CONSTRAINT psp_reconciliations_provider_reconciliation_date_key UNIQUE (provider, reconciliation_date);


--
-- Name: qr_scan_attempts qr_scan_attempts_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.qr_scan_attempts
    ADD CONSTRAINT qr_scan_attempts_pkey PRIMARY KEY (id);


--
-- Name: rate_limit_violations rate_limit_violations_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_limit_violations
    ADD CONSTRAINT rate_limit_violations_pkey PRIMARY KEY (id);


--
-- Name: realtime_metrics realtime_metrics_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.realtime_metrics
    ADD CONSTRAINT realtime_metrics_pkey PRIMARY KEY (id);


--
-- Name: refund_requests refund_requests_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.refund_requests
    ADD CONSTRAINT refund_requests_pkey PRIMARY KEY (id);


--
-- Name: refunds refunds_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.refunds
    ADD CONSTRAINT refunds_pkey PRIMARY KEY (id);


--
-- Name: reportable_transactions reportable_transactions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reportable_transactions
    ADD CONSTRAINT reportable_transactions_pkey PRIMARY KEY (id);


--
-- Name: reservations reservations_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reservations
    ADD CONSTRAINT reservations_pkey PRIMARY KEY (id);


--
-- Name: revenue_projections revenue_projections_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revenue_projections
    ADD CONSTRAINT revenue_projections_pkey PRIMARY KEY (id);


--
-- Name: role_permissions role_permissions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.role_permissions
    ADD CONSTRAINT role_permissions_pkey PRIMARY KEY (id);


--
-- Name: role_permissions role_permissions_role_id_permission_id_venue_id_event_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.role_permissions
    ADD CONSTRAINT role_permissions_role_id_permission_id_venue_id_event_id_key UNIQUE (role_id, permission_id, venue_id, event_id);


--
-- Name: roles roles_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.roles
    ADD CONSTRAINT roles_pkey PRIMARY KEY (id);


--
-- Name: royalties royalties_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.royalties
    ADD CONSTRAINT royalties_pkey PRIMARY KEY (id);


--
-- Name: royalty_settlements royalty_settlements_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.royalty_settlements
    ADD CONSTRAINT royalty_settlements_pkey PRIMARY KEY (id);


--
-- Name: sanctions_screening sanctions_screening_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sanctions_screening
    ADD CONSTRAINT sanctions_screening_pkey PRIMARY KEY (id);


--
-- Name: scanner_devices scanner_devices_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.scanner_devices
    ADD CONSTRAINT scanner_devices_pkey PRIMARY KEY (id);


--
-- Name: schedule_activities schedule_activities_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.schedule_activities
    ADD CONSTRAINT schedule_activities_pkey PRIMARY KEY (id);


--
-- Name: schedule_conflicts schedule_conflicts_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.schedule_conflicts
    ADD CONSTRAINT schedule_conflicts_pkey PRIMARY KEY (id);


--
-- Name: schedule_exceptions schedule_exceptions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.schedule_exceptions
    ADD CONSTRAINT schedule_exceptions_pkey PRIMARY KEY (id);


--
-- Name: schema_migrations schema_migrations_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.schema_migrations
    ADD CONSTRAINT schema_migrations_pkey PRIMARY KEY (version);


--
-- Name: search_analytics search_analytics_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.search_analytics
    ADD CONSTRAINT search_analytics_pkey PRIMARY KEY (id);


--
-- Name: search_index_events search_index_events_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.search_index_events
    ADD CONSTRAINT search_index_events_pkey PRIMARY KEY (id);


--
-- Name: security_alerts security_alerts_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.security_alerts
    ADD CONSTRAINT security_alerts_pkey PRIMARY KEY (id);


--
-- Name: security_audit_logs security_audit_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.security_audit_logs
    ADD CONSTRAINT security_audit_logs_pkey PRIMARY KEY (id);


--
-- Name: segment_definitions segment_definitions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.segment_definitions
    ADD CONSTRAINT segment_definitions_pkey PRIMARY KEY (id);


--
-- Name: segment_definitions segment_definitions_segment_key_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.segment_definitions
    ADD CONSTRAINT segment_definitions_segment_key_key UNIQUE (segment_key);


--
-- Name: service_health service_health_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.service_health
    ADD CONSTRAINT service_health_pkey PRIMARY KEY (id);


--
-- Name: session_activities session_activities_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.session_activities
    ADD CONSTRAINT session_activities_pkey PRIMARY KEY (id);


--
-- Name: sessions sessions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sessions
    ADD CONSTRAINT sessions_pkey PRIMARY KEY (id);


--
-- Name: sessions sessions_token_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sessions
    ADD CONSTRAINT sessions_token_key UNIQUE (token);


--
-- Name: settlement_batches settlement_batches_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.settlement_batches
    ADD CONSTRAINT settlement_batches_pkey PRIMARY KEY (id);


--
-- Name: settlement_items settlement_items_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.settlement_items
    ADD CONSTRAINT settlement_items_pkey PRIMARY KEY (id);


--
-- Name: settlement_reports settlement_reports_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.settlement_reports
    ADD CONSTRAINT settlement_reports_pkey PRIMARY KEY (id);


--
-- Name: settlement_reports settlement_reports_venue_id_settlement_date_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.settlement_reports
    ADD CONSTRAINT settlement_reports_venue_id_settlement_date_key UNIQUE (venue_id, settlement_date);


--
-- Name: settlements settlements_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.settlements
    ADD CONSTRAINT settlements_pkey PRIMARY KEY (id);


--
-- Name: sla_metrics sla_metrics_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sla_metrics
    ADD CONSTRAINT sla_metrics_pkey PRIMARY KEY (id);


--
-- Name: smart_contract_events smart_contract_events_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.smart_contract_events
    ADD CONSTRAINT smart_contract_events_pkey PRIMARY KEY (id);


--
-- Name: staff_certifications staff_certifications_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.staff_certifications
    ADD CONSTRAINT staff_certifications_pkey PRIMARY KEY (id);


--
-- Name: staff_schedules staff_schedules_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.staff_schedules
    ADD CONSTRAINT staff_schedules_pkey PRIMARY KEY (id);


--
-- Name: staff_training_records staff_training_records_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.staff_training_records
    ADD CONSTRAINT staff_training_records_pkey PRIMARY KEY (id);


--
-- Name: state_compliance_rules state_compliance_rules_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.state_compliance_rules
    ADD CONSTRAINT state_compliance_rules_pkey PRIMARY KEY (id);


--
-- Name: state_compliance_rules state_compliance_rules_state_code_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.state_compliance_rules
    ADD CONSTRAINT state_compliance_rules_state_code_key UNIQUE (state_code);


--
-- Name: subscriptions subscriptions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.subscriptions
    ADD CONSTRAINT subscriptions_pkey PRIMARY KEY (id);


--
-- Name: suspicious_sessions suspicious_sessions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.suspicious_sessions
    ADD CONSTRAINT suspicious_sessions_pkey PRIMARY KEY (id);


--
-- Name: sync_logs sync_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sync_logs
    ADD CONSTRAINT sync_logs_pkey PRIMARY KEY (id);


--
-- Name: tax_collections tax_collections_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tax_collections
    ADD CONSTRAINT tax_collections_pkey PRIMARY KEY (id);


--
-- Name: tax_form_recipients tax_form_recipients_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tax_form_recipients
    ADD CONSTRAINT tax_form_recipients_pkey PRIMARY KEY (id);


--
-- Name: tax_forms_1099 tax_forms_1099_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tax_forms_1099
    ADD CONSTRAINT tax_forms_1099_pkey PRIMARY KEY (id);


--
-- Name: tax_remittances tax_remittances_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tax_remittances
    ADD CONSTRAINT tax_remittances_pkey PRIMARY KEY (id);


--
-- Name: tax_reporting_requirements tax_reporting_requirements_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tax_reporting_requirements
    ADD CONSTRAINT tax_reporting_requirements_pkey PRIMARY KEY (id);


--
-- Name: tenants tenants_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tenants
    ADD CONSTRAINT tenants_pkey PRIMARY KEY (id);


--
-- Name: ticket_batch_operations ticket_batch_operations_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_batch_operations
    ADD CONSTRAINT ticket_batch_operations_pkey PRIMARY KEY (id);


--
-- Name: ticket_metadata ticket_metadata_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_metadata
    ADD CONSTRAINT ticket_metadata_pkey PRIMARY KEY (id);


--
-- Name: ticket_ownership_history ticket_ownership_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_ownership_history
    ADD CONSTRAINT ticket_ownership_history_pkey PRIMARY KEY (id);


--
-- Name: ticket_redemptions ticket_redemptions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_redemptions
    ADD CONSTRAINT ticket_redemptions_pkey PRIMARY KEY (id);


--
-- Name: ticket_refunds ticket_refunds_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_refunds
    ADD CONSTRAINT ticket_refunds_pkey PRIMARY KEY (id);


--
-- Name: ticket_resale_listings ticket_resale_listings_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_resale_listings
    ADD CONSTRAINT ticket_resale_listings_pkey PRIMARY KEY (id);


--
-- Name: ticket_reservations_backup ticket_reservations_backup_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_reservations_backup
    ADD CONSTRAINT ticket_reservations_backup_pkey PRIMARY KEY (id);


--
-- Name: ticket_reservations ticket_reservations_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_reservations
    ADD CONSTRAINT ticket_reservations_pkey PRIMARY KEY (id);


--
-- Name: ticket_scans ticket_scans_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_scans
    ADD CONSTRAINT ticket_scans_pkey PRIMARY KEY (id);


--
-- Name: ticket_transactions ticket_transactions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_transactions
    ADD CONSTRAINT ticket_transactions_pkey PRIMARY KEY (id);


--
-- Name: ticket_transfers ticket_transfers_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_transfers
    ADD CONSTRAINT ticket_transfers_pkey PRIMARY KEY (id);


--
-- Name: ticket_type_analytics ticket_type_analytics_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_type_analytics
    ADD CONSTRAINT ticket_type_analytics_pkey PRIMARY KEY (id);


--
-- Name: ticket_type_availability_schedules ticket_type_availability_schedules_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_type_availability_schedules
    ADD CONSTRAINT ticket_type_availability_schedules_pkey PRIMARY KEY (id);


--
-- Name: ticket_type_benefits ticket_type_benefits_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_type_benefits
    ADD CONSTRAINT ticket_type_benefits_pkey PRIMARY KEY (id);


--
-- Name: ticket_type_refund_policies ticket_type_refund_policies_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_type_refund_policies
    ADD CONSTRAINT ticket_type_refund_policies_pkey PRIMARY KEY (id);


--
-- Name: ticket_type_restrictions ticket_type_restrictions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_type_restrictions
    ADD CONSTRAINT ticket_type_restrictions_pkey PRIMARY KEY (id);


--
-- Name: ticket_type_transfer_policies ticket_type_transfer_policies_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_type_transfer_policies
    ADD CONSTRAINT ticket_type_transfer_policies_pkey PRIMARY KEY (id);


--
-- Name: ticket_types ticket_types_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_types
    ADD CONSTRAINT ticket_types_pkey PRIMARY KEY (id);


--
-- Name: ticket_validations ticket_validations_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_validations
    ADD CONSTRAINT ticket_validations_pkey PRIMARY KEY (id);


--
-- Name: tickets tickets_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tickets
    ADD CONSTRAINT tickets_pkey PRIMARY KEY (id);


--
-- Name: tos_acceptances tos_acceptances_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tos_acceptances
    ADD CONSTRAINT tos_acceptances_pkey PRIMARY KEY (id);


--
-- Name: transactions transactions_idempotency_key_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transactions
    ADD CONSTRAINT transactions_idempotency_key_key UNIQUE (idempotency_key);


--
-- Name: transactions transactions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transactions
    ADD CONSTRAINT transactions_pkey PRIMARY KEY (id);


--
-- Name: market_analytics unique_analytics; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.market_analytics
    ADD CONSTRAINT unique_analytics UNIQUE (analytics_type, scope_id, period, period_start);


--
-- Name: event_metadata unique_event_metadata; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_metadata
    ADD CONSTRAINT unique_event_metadata UNIQUE (event_id);


--
-- Name: event_capacity unique_event_section; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity
    ADD CONSTRAINT unique_event_section UNIQUE (event_id, section_name, schedule_id);


--
-- Name: ticket_metadata unique_ticket_metadata; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_metadata
    ADD CONSTRAINT unique_ticket_metadata UNIQUE (ticket_id);


--
-- Name: venue_integrations unique_venue_integration; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_integrations
    ADD CONSTRAINT unique_venue_integration UNIQUE (venue_id, integration_type);


--
-- Name: venue_settings unique_venue_settings; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_settings
    ADD CONSTRAINT unique_venue_settings UNIQUE (venue_id);


--
-- Name: venue_staff unique_venue_staff; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_staff
    ADD CONSTRAINT unique_venue_staff UNIQUE (venue_id, user_id);


--
-- Name: wallet_addresses unique_wallet_blockchain; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.wallet_addresses
    ADD CONSTRAINT unique_wallet_blockchain UNIQUE (wallet_address, blockchain);


--
-- Name: upload_sessions upload_sessions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.upload_sessions
    ADD CONSTRAINT upload_sessions_pkey PRIMARY KEY (id);


--
-- Name: event_capacity_by_tier uq_capacity_tier_unique; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_by_tier
    ADD CONSTRAINT uq_capacity_tier_unique UNIQUE (event_capacity_id, pricing_tier);


--
-- Name: event_capacity_by_type uq_capacity_type_unique; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_by_type
    ADD CONSTRAINT uq_capacity_type_unique UNIQUE (event_capacity_id, ticket_type_id);


--
-- Name: event_capacity_utilization_history uq_capacity_utilization_time; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_utilization_history
    ADD CONSTRAINT uq_capacity_utilization_time UNIQUE (event_capacity_id, date_recorded, hour_of_day, sales_channel);


--
-- Name: event_category_analytics uq_category_analytics_date; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_category_analytics
    ADD CONSTRAINT uq_category_analytics_date UNIQUE (category_id, analytics_date);


--
-- Name: event_category_attributes uq_category_attr_unique; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_category_attributes
    ADD CONSTRAINT uq_category_attr_unique UNIQUE (category_id, attribute_type, attribute_name);


--
-- Name: event_category_search_suggestions uq_category_suggestion_text; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_category_search_suggestions
    ADD CONSTRAINT uq_category_suggestion_text UNIQUE (category_id, suggestion_text);


--
-- Name: event_category_tags uq_category_tag_unique; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_category_tags
    ADD CONSTRAINT uq_category_tag_unique UNIQUE (category_id, tag_name);


--
-- Name: event_category_trending uq_category_trending_period; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_category_trending
    ADD CONSTRAINT uq_category_trending_period UNIQUE (category_id, trending_period, period_start);


--
-- Name: event_analytics_tracking uq_event_analytics_provider; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_analytics_tracking
    ADD CONSTRAINT uq_event_analytics_provider UNIQUE (event_id, analytics_provider, tracking_id);


--
-- Name: event_category_mappings uq_event_category_mapping; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_category_mappings
    ADD CONSTRAINT uq_event_category_mapping UNIQUE (event_id, category_id);


--
-- Name: event_custom_attributes uq_event_custom_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_custom_attributes
    ADD CONSTRAINT uq_event_custom_name UNIQUE (event_id, attribute_name);


--
-- Name: event_seo_metadata uq_event_seo_unique; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_seo_metadata
    ADD CONSTRAINT uq_event_seo_unique UNIQUE (event_id);


--
-- Name: event_social_media uq_event_social_platform; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_social_media
    ADD CONSTRAINT uq_event_social_platform UNIQUE (event_id, platform);


--
-- Name: event_metadata_templates uq_metadata_template_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_metadata_templates
    ADD CONSTRAINT uq_metadata_template_name UNIQUE (template_name);


--
-- Name: event_pricing_tiers uq_pricing_tier_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_tiers
    ADD CONSTRAINT uq_pricing_tier_name UNIQUE (event_pricing_id, tier_name);


--
-- Name: event_pricing_promo_codes uq_promo_code_unique; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_promo_codes
    ADD CONSTRAINT uq_promo_code_unique UNIQUE (event_pricing_id, promo_code);


--
-- Name: ticket_type_refund_policies uq_refund_policy_ticket_type; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_type_refund_policies
    ADD CONSTRAINT uq_refund_policy_ticket_type UNIQUE (ticket_type_id);


--
-- Name: ticket_type_analytics uq_ticket_analytics_date; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_type_analytics
    ADD CONSTRAINT uq_ticket_analytics_date UNIQUE (ticket_type_id, analytics_date);


--
-- Name: ticket_type_transfer_policies uq_transfer_policy_ticket_type; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_type_transfer_policies
    ADD CONSTRAINT uq_transfer_policy_ticket_type UNIQUE (ticket_type_id);


--
-- Name: venue_custom_categories uq_venue_category_unique; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_custom_categories
    ADD CONSTRAINT uq_venue_category_unique UNIQUE (venue_id, category_id);


--
-- Name: user_consents user_consents_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_consents
    ADD CONSTRAINT user_consents_pkey PRIMARY KEY (id);


--
-- Name: user_permissions user_permissions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_permissions
    ADD CONSTRAINT user_permissions_pkey PRIMARY KEY (id);


--
-- Name: user_permissions user_permissions_user_id_permission_id_venue_id_event_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_permissions
    ADD CONSTRAINT user_permissions_user_id_permission_id_venue_id_event_id_key UNIQUE (user_id, permission_id, venue_id, event_id);


--
-- Name: user_privacy_settings user_privacy_settings_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_privacy_settings
    ADD CONSTRAINT user_privacy_settings_pkey PRIMARY KEY (id);


--
-- Name: user_roles user_roles_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_roles
    ADD CONSTRAINT user_roles_pkey PRIMARY KEY (id);


--
-- Name: user_roles user_roles_user_id_role_id_venue_id_event_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_roles
    ADD CONSTRAINT user_roles_user_id_role_id_venue_id_event_id_key UNIQUE (user_id, role_id, venue_id, event_id);


--
-- Name: user_sessions user_sessions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_sessions
    ADD CONSTRAINT user_sessions_pkey PRIMARY KEY (id);


--
-- Name: users users_email_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_email_key UNIQUE (email);


--
-- Name: users users_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


--
-- Name: users users_referral_code_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_referral_code_key UNIQUE (referral_code);


--
-- Name: users users_username_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_username_key UNIQUE (username);


--
-- Name: venue_analytics venue_analytics_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_analytics
    ADD CONSTRAINT venue_analytics_pkey PRIMARY KEY (id);


--
-- Name: venue_balances venue_balances_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_balances
    ADD CONSTRAINT venue_balances_pkey PRIMARY KEY (id);


--
-- Name: venue_balances venue_balances_venue_id_balance_type_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_balances
    ADD CONSTRAINT venue_balances_venue_id_balance_type_key UNIQUE (venue_id, balance_type);


--
-- Name: venue_blackout_dates venue_blackout_dates_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_blackout_dates
    ADD CONSTRAINT venue_blackout_dates_pkey PRIMARY KEY (id);


--
-- Name: venue_compliance venue_compliance_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_compliance
    ADD CONSTRAINT venue_compliance_pkey PRIMARY KEY (id);


--
-- Name: venue_custom_categories venue_custom_categories_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_custom_categories
    ADD CONSTRAINT venue_custom_categories_pkey PRIMARY KEY (id);


--
-- Name: venue_documents venue_documents_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_documents
    ADD CONSTRAINT venue_documents_pkey PRIMARY KEY (id);


--
-- Name: venue_integrations venue_integrations_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_integrations
    ADD CONSTRAINT venue_integrations_pkey PRIMARY KEY (id);


--
-- Name: venue_layouts venue_layouts_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_layouts
    ADD CONSTRAINT venue_layouts_pkey PRIMARY KEY (id);


--
-- Name: venue_notification_templates venue_notification_templates_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_notification_templates
    ADD CONSTRAINT venue_notification_templates_pkey PRIMARY KEY (id);


--
-- Name: venue_notification_templates venue_notification_templates_unique_type; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_notification_templates
    ADD CONSTRAINT venue_notification_templates_unique_type UNIQUE (venue_id, template_type, template_name);


--
-- Name: venue_operating_hours venue_operating_hours_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_operating_hours
    ADD CONSTRAINT venue_operating_hours_pkey PRIMARY KEY (id);


--
-- Name: venue_operating_hours venue_operating_hours_venue_id_day_of_week_effective_from_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_operating_hours
    ADD CONSTRAINT venue_operating_hours_venue_id_day_of_week_effective_from_key UNIQUE (venue_id, day_of_week, effective_from);


--
-- Name: venue_payout_accounts venue_payout_accounts_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_payout_accounts
    ADD CONSTRAINT venue_payout_accounts_pkey PRIMARY KEY (id);


--
-- Name: venue_policies venue_policies_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_policies
    ADD CONSTRAINT venue_policies_pkey PRIMARY KEY (id);


--
-- Name: venue_policies venue_policies_unique_type; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_policies
    ADD CONSTRAINT venue_policies_unique_type UNIQUE (venue_id, policy_type, effective_from);


--
-- Name: venue_pricing_rules venue_pricing_rules_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_pricing_rules
    ADD CONSTRAINT venue_pricing_rules_pkey PRIMARY KEY (id);


--
-- Name: venue_settings venue_settings_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_settings
    ADD CONSTRAINT venue_settings_pkey PRIMARY KEY (id);


--
-- Name: venue_staff venue_staff_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_staff
    ADD CONSTRAINT venue_staff_pkey PRIMARY KEY (id);


--
-- Name: venues venues_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venues
    ADD CONSTRAINT venues_pkey PRIMARY KEY (id);


--
-- Name: wallet_addresses wallet_addresses_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.wallet_addresses
    ADD CONSTRAINT wallet_addresses_pkey PRIMARY KEY (id);


--
-- Name: webhook_deliveries webhook_deliveries_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.webhook_deliveries
    ADD CONSTRAINT webhook_deliveries_pkey PRIMARY KEY (id);


--
-- Name: webhook_endpoints webhook_endpoints_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.webhook_endpoints
    ADD CONSTRAINT webhook_endpoints_pkey PRIMARY KEY (id);


--
-- Name: webhook_events webhook_events_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.webhook_events
    ADD CONSTRAINT webhook_events_pkey PRIMARY KEY (id);


--
-- Name: webhook_inbox webhook_inbox_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.webhook_inbox
    ADD CONSTRAINT webhook_inbox_pkey PRIMARY KEY (id);


--
-- Name: idx_audit_log_changed_at; Type: INDEX; Schema: audit; Owner: postgres
--

CREATE INDEX idx_audit_log_changed_at ON audit.audit_log USING btree (changed_at);


--
-- Name: idx_audit_log_table_name; Type: INDEX; Schema: audit; Owner: postgres
--

CREATE INDEX idx_audit_log_table_name ON audit.audit_log USING btree (table_name);


--
-- Name: idx_audit_log_user_id; Type: INDEX; Schema: audit; Owner: postgres
--

CREATE INDEX idx_audit_log_user_id ON audit.audit_log USING btree (user_id);


--
-- Name: idx_aml_checks_check_status; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_aml_checks_check_status ON compliance.aml_checks USING btree (check_status);


--
-- Name: idx_aml_checks_created_at; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_aml_checks_created_at ON compliance.aml_checks USING btree (created_at DESC);


--
-- Name: idx_aml_checks_customer_profile_id; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_aml_checks_customer_profile_id ON compliance.aml_checks USING btree (customer_profile_id);


--
-- Name: idx_aml_checks_event_id; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_aml_checks_event_id ON compliance.aml_checks USING btree (event_id) WHERE (event_id IS NOT NULL);


--
-- Name: idx_aml_checks_flagged; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_aml_checks_flagged ON compliance.aml_checks USING btree (customer_profile_id, created_at DESC) WHERE ((check_status)::text = ANY (ARRAY[('flagged'::character varying)::text, ('escalated'::character varying)::text]));


--
-- Name: idx_aml_checks_high_risk; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_aml_checks_high_risk ON compliance.aml_checks USING btree (risk_score DESC, check_status) WHERE (risk_score >= 70);


--
-- Name: idx_aml_checks_investigation; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_aml_checks_investigation ON compliance.aml_checks USING btree (investigation_status, investigator_id) WHERE (investigation_status IS NOT NULL);


--
-- Name: idx_aml_checks_last_reviewed; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_aml_checks_last_reviewed ON compliance.aml_checks USING btree (last_reviewed_at DESC) WHERE (last_reviewed_at IS NOT NULL);


--
-- Name: idx_aml_checks_risk_level; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_aml_checks_risk_level ON compliance.aml_checks USING btree (risk_level);


--
-- Name: idx_aml_checks_risk_score; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_aml_checks_risk_score ON compliance.aml_checks USING btree (risk_score DESC);


--
-- Name: idx_aml_checks_rule_scores; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_aml_checks_rule_scores ON compliance.aml_checks USING gin (rule_scores);


--
-- Name: idx_aml_checks_sar_filed; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_aml_checks_sar_filed ON compliance.aml_checks USING btree (sar_filed, created_at DESC) WHERE (sar_filed = true);


--
-- Name: idx_aml_checks_tenant_created; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_aml_checks_tenant_created ON compliance.aml_checks USING btree (tenant_id, created_at) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_aml_checks_tenant_id; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_aml_checks_tenant_id ON compliance.aml_checks USING btree (tenant_id) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_aml_checks_transaction_id; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_aml_checks_transaction_id ON compliance.aml_checks USING btree (transaction_id) WHERE (transaction_id IS NOT NULL);


--
-- Name: idx_compliance_reports_amendments; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_compliance_reports_amendments ON compliance.compliance_reports USING btree (original_report_id) WHERE (is_amendment = true);


--
-- Name: idx_compliance_reports_created_at; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_compliance_reports_created_at ON compliance.compliance_reports USING btree (created_at DESC);


--
-- Name: idx_compliance_reports_destruction; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_compliance_reports_destruction ON compliance.compliance_reports USING btree (destruction_date) WHERE ((destruction_date IS NOT NULL) AND (archived = false));


--
-- Name: idx_compliance_reports_due_date; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_compliance_reports_due_date ON compliance.compliance_reports USING btree (due_date);


--
-- Name: idx_compliance_reports_findings; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_compliance_reports_findings ON compliance.compliance_reports USING gin (findings_details);


--
-- Name: idx_compliance_reports_pending; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_compliance_reports_pending ON compliance.compliance_reports USING btree (due_date, status) WHERE ((status)::text = ANY (ARRAY[('draft'::character varying)::text, ('pending_review'::character varying)::text, ('approved'::character varying)::text]));


--
-- Name: idx_compliance_reports_period; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_compliance_reports_period ON compliance.compliance_reports USING btree (period_start, period_end);


--
-- Name: idx_compliance_reports_regulator; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_compliance_reports_regulator ON compliance.compliance_reports USING btree (regulator);


--
-- Name: idx_compliance_reports_report_data; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_compliance_reports_report_data ON compliance.compliance_reports USING gin (report_data);


--
-- Name: idx_compliance_reports_report_type; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_compliance_reports_report_type ON compliance.compliance_reports USING btree (report_type);


--
-- Name: idx_compliance_reports_status; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_compliance_reports_status ON compliance.compliance_reports USING btree (status);


--
-- Name: idx_compliance_reports_submitted_at; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_compliance_reports_submitted_at ON compliance.compliance_reports USING btree (submitted_at DESC) WHERE (submitted_at IS NOT NULL);


--
-- Name: idx_compliance_reports_tenant_created; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_compliance_reports_tenant_created ON compliance.compliance_reports USING btree (tenant_id, created_at) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_compliance_reports_tenant_id; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_compliance_reports_tenant_id ON compliance.compliance_reports USING btree (tenant_id) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_compliance_reports_updated_at; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_compliance_reports_updated_at ON compliance.compliance_reports USING btree (updated_at DESC);


--
-- Name: idx_data_retention_active; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_data_retention_active ON compliance.data_retention USING btree (is_active, policy_type) WHERE (is_active = true);


--
-- Name: idx_data_retention_anonymization; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_data_retention_anonymization ON compliance.data_retention USING gin (anonymization_rules);


--
-- Name: idx_data_retention_compliance; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_data_retention_compliance ON compliance.data_retention USING btree (compliance_status, last_compliance_check);


--
-- Name: idx_data_retention_created_at; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_data_retention_created_at ON compliance.data_retention USING btree (created_at DESC);


--
-- Name: idx_data_retention_data_category; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_data_retention_data_category ON compliance.data_retention USING btree (data_category);


--
-- Name: idx_data_retention_data_type; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_data_retention_data_type ON compliance.data_retention USING btree (data_type);


--
-- Name: idx_data_retention_exceptions; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_data_retention_exceptions ON compliance.data_retention USING gin (exception_criteria);


--
-- Name: idx_data_retention_legal_hold; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_data_retention_legal_hold ON compliance.data_retention USING btree (legal_hold) WHERE (legal_hold = true);


--
-- Name: idx_data_retention_next_purge; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_data_retention_next_purge ON compliance.data_retention USING btree (next_purge_date) WHERE ((next_purge_date IS NOT NULL) AND (is_active = true));


--
-- Name: idx_data_retention_policy_name; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_data_retention_policy_name ON compliance.data_retention USING btree (policy_name);


--
-- Name: idx_data_retention_tables; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_data_retention_tables ON compliance.data_retention USING gin (table_names);


--
-- Name: idx_data_retention_tenant_created; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_data_retention_tenant_created ON compliance.data_retention USING btree (tenant_id, created_at) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_data_retention_tenant_id; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_data_retention_tenant_id ON compliance.data_retention USING btree (tenant_id) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_data_retention_updated_at; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_data_retention_updated_at ON compliance.data_retention USING btree (updated_at DESC);


--
-- Name: idx_kyc_records_customer_profile_id; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_kyc_records_customer_profile_id ON compliance.kyc_records USING btree (customer_profile_id);


--
-- Name: idx_kyc_records_deletion_scheduled; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_kyc_records_deletion_scheduled ON compliance.kyc_records USING btree (deletion_scheduled_at) WHERE (deletion_scheduled_at IS NOT NULL);


--
-- Name: idx_kyc_records_expires_at; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_kyc_records_expires_at ON compliance.kyc_records USING btree (expires_at) WHERE (expires_at IS NOT NULL);


--
-- Name: idx_kyc_records_manual_review; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_kyc_records_manual_review ON compliance.kyc_records USING btree (requires_manual_review) WHERE (requires_manual_review = true);


--
-- Name: idx_kyc_records_provider; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_kyc_records_provider ON compliance.kyc_records USING btree (kyc_provider, provider_reference_id);


--
-- Name: idx_kyc_records_regulatory_flags; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_kyc_records_regulatory_flags ON compliance.kyc_records USING gin (regulatory_flags);


--
-- Name: idx_kyc_records_risk_factors; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_kyc_records_risk_factors ON compliance.kyc_records USING gin (risk_factors);


--
-- Name: idx_kyc_records_risk_score; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_kyc_records_risk_score ON compliance.kyc_records USING btree (risk_score) WHERE (risk_score > 50);


--
-- Name: idx_kyc_records_submitted_at; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_kyc_records_submitted_at ON compliance.kyc_records USING btree (submitted_at DESC);


--
-- Name: idx_kyc_records_tenant_created; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_kyc_records_tenant_created ON compliance.kyc_records USING btree (tenant_id, created_at) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_kyc_records_tenant_id; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_kyc_records_tenant_id ON compliance.kyc_records USING btree (tenant_id) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_kyc_records_verification_level; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_kyc_records_verification_level ON compliance.kyc_records USING btree (verification_level);


--
-- Name: idx_kyc_records_verification_status; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_kyc_records_verification_status ON compliance.kyc_records USING btree (verification_status);


--
-- Name: idx_sanctions_screening_created_at; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_sanctions_screening_created_at ON compliance.sanctions_screening USING btree (created_at DESC);


--
-- Name: idx_sanctions_screening_customer_profile_id; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_sanctions_screening_customer_profile_id ON compliance.sanctions_screening USING btree (customer_profile_id);


--
-- Name: idx_sanctions_screening_edd_required; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_sanctions_screening_edd_required ON compliance.sanctions_screening USING btree (requires_enhanced_due_diligence) WHERE (requires_enhanced_due_diligence = true);


--
-- Name: idx_sanctions_screening_false_positives; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_sanctions_screening_false_positives ON compliance.sanctions_screening USING btree (customer_profile_id, is_false_positive) WHERE (is_false_positive = true);


--
-- Name: idx_sanctions_screening_last_checked; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_sanctions_screening_last_checked ON compliance.sanctions_screening USING btree (last_checked_at DESC);


--
-- Name: idx_sanctions_screening_match_score; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_sanctions_screening_match_score ON compliance.sanctions_screening USING btree (match_score DESC);


--
-- Name: idx_sanctions_screening_matched_documents; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_sanctions_screening_matched_documents ON compliance.sanctions_screening USING gin (matched_documents);


--
-- Name: idx_sanctions_screening_matches; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_sanctions_screening_matches ON compliance.sanctions_screening USING btree (screening_status, match_score DESC) WHERE ((screening_status)::text = ANY (ARRAY[('potential_match'::character varying)::text, ('confirmed_match'::character varying)::text]));


--
-- Name: idx_sanctions_screening_next_check; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_sanctions_screening_next_check ON compliance.sanctions_screening USING btree (next_check_date) WHERE (next_check_date IS NOT NULL);


--
-- Name: idx_sanctions_screening_review_required; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_sanctions_screening_review_required ON compliance.sanctions_screening USING btree (review_required, created_at DESC) WHERE (review_required = true);


--
-- Name: idx_sanctions_screening_risk_rating; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_sanctions_screening_risk_rating ON compliance.sanctions_screening USING btree (risk_rating) WHERE (risk_rating IS NOT NULL);


--
-- Name: idx_sanctions_screening_status; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_sanctions_screening_status ON compliance.sanctions_screening USING btree (screening_status);


--
-- Name: idx_sanctions_screening_supporting_documents; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_sanctions_screening_supporting_documents ON compliance.sanctions_screening USING gin (supporting_documents);


--
-- Name: idx_sanctions_screening_tenant_created; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_sanctions_screening_tenant_created ON compliance.sanctions_screening USING btree (tenant_id, created_at) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_sanctions_screening_tenant_id; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_sanctions_screening_tenant_id ON compliance.sanctions_screening USING btree (tenant_id) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_sanctions_screening_type; Type: INDEX; Schema: compliance; Owner: postgres
--

CREATE INDEX idx_sanctions_screening_type ON compliance.sanctions_screening USING btree (screening_type);


--
-- Name: idx_api_credentials_capabilities; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_api_credentials_capabilities ON integrations.api_credentials USING gin (capabilities);


--
-- Name: idx_api_credentials_custom_endpoints; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_api_credentials_custom_endpoints ON integrations.api_credentials USING gin (custom_endpoints);


--
-- Name: idx_api_credentials_environment; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_api_credentials_environment ON integrations.api_credentials USING btree (environment);


--
-- Name: idx_api_credentials_is_active; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_api_credentials_is_active ON integrations.api_credentials USING btree (is_active);


--
-- Name: idx_api_credentials_oauth_expires; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_api_credentials_oauth_expires ON integrations.api_credentials USING btree (oauth_expires_at) WHERE (oauth_expires_at IS NOT NULL);


--
-- Name: idx_api_credentials_provider_name; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_api_credentials_provider_name ON integrations.api_credentials USING btree (provider_name);


--
-- Name: idx_api_credentials_provider_type; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_api_credentials_provider_type ON integrations.api_credentials USING btree (provider_type);


--
-- Name: idx_api_credentials_rotation_required; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_api_credentials_rotation_required ON integrations.api_credentials USING btree (rotation_required) WHERE (rotation_required = true);


--
-- Name: idx_api_credentials_tenant_created; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_api_credentials_tenant_created ON integrations.api_credentials USING btree (tenant_id, created_at) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_api_credentials_tenant_id; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_api_credentials_tenant_id ON integrations.api_credentials USING btree (tenant_id) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_api_credentials_verification_status; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_api_credentials_verification_status ON integrations.api_credentials USING btree (verification_status);


--
-- Name: idx_external_references_external; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_external_references_external ON integrations.external_references USING btree (external_system, external_entity_type, external_entity_id);


--
-- Name: idx_external_references_integration; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_external_references_integration ON integrations.external_references USING btree (integration_id);


--
-- Name: idx_external_references_internal; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_external_references_internal ON integrations.external_references USING btree (internal_entity_type, internal_entity_id);


--
-- Name: idx_external_references_mapped_fields; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_external_references_mapped_fields ON integrations.external_references USING gin (mapped_fields);


--
-- Name: idx_external_references_needs_sync; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_external_references_needs_sync ON integrations.external_references USING btree (needs_sync, last_synced_at) WHERE (needs_sync = true);


--
-- Name: idx_external_references_parent; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_external_references_parent ON integrations.external_references USING btree (parent_external_id) WHERE (parent_external_id IS NOT NULL);


--
-- Name: idx_external_references_quality_issues; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_external_references_quality_issues ON integrations.external_references USING gin (quality_issues);


--
-- Name: idx_external_references_related_entities; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_external_references_related_entities ON integrations.external_references USING gin (related_entities);


--
-- Name: idx_external_references_sync_status; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_external_references_sync_status ON integrations.external_references USING btree (sync_status, last_synced_at);


--
-- Name: idx_external_references_system; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_external_references_system ON integrations.external_references USING btree (external_system);


--
-- Name: idx_external_references_tenant_created; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_external_references_tenant_created ON integrations.external_references USING btree (tenant_id, created_at) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_external_references_tenant_id; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_external_references_tenant_id ON integrations.external_references USING btree (tenant_id) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_external_references_validation; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_external_references_validation ON integrations.external_references USING btree (is_validated, last_validated_at);


--
-- Name: idx_external_references_version_conflict; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_external_references_version_conflict ON integrations.external_references USING btree (version_conflict, external_system) WHERE (version_conflict = true);


--
-- Name: idx_integration_mappings_active_direction; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_integration_mappings_active_direction ON integrations.integration_mappings USING btree (is_active, sync_direction) WHERE (is_active = true);


--
-- Name: idx_integration_mappings_conditions; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_integration_mappings_conditions ON integrations.integration_mappings USING gin (conditions);


--
-- Name: idx_integration_mappings_entity_pair; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_integration_mappings_entity_pair ON integrations.integration_mappings USING btree (source_entity, target_entity);


--
-- Name: idx_integration_mappings_field_mappings; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_integration_mappings_field_mappings ON integrations.integration_mappings USING gin (field_mappings);


--
-- Name: idx_integration_mappings_integration_id; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_integration_mappings_integration_id ON integrations.integration_mappings USING btree (integration_id);


--
-- Name: idx_integration_mappings_integration_name; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_integration_mappings_integration_name ON integrations.integration_mappings USING btree (integration_name);


--
-- Name: idx_integration_mappings_is_active; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_integration_mappings_is_active ON integrations.integration_mappings USING btree (is_active);


--
-- Name: idx_integration_mappings_mapping_name; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_integration_mappings_mapping_name ON integrations.integration_mappings USING btree (mapping_name);


--
-- Name: idx_integration_mappings_source_entity; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_integration_mappings_source_entity ON integrations.integration_mappings USING btree (source_entity);


--
-- Name: idx_integration_mappings_sync_direction; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_integration_mappings_sync_direction ON integrations.integration_mappings USING btree (sync_direction);


--
-- Name: idx_integration_mappings_target_entity; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_integration_mappings_target_entity ON integrations.integration_mappings USING btree (target_entity);


--
-- Name: idx_integration_mappings_tenant_created; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_integration_mappings_tenant_created ON integrations.integration_mappings USING btree (tenant_id, created_at) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_integration_mappings_tenant_id; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_integration_mappings_tenant_id ON integrations.integration_mappings USING btree (tenant_id) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_integration_mappings_value_lookups; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_integration_mappings_value_lookups ON integrations.integration_mappings USING gin (value_lookup_table);


--
-- Name: idx_sync_logs_completed_at; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_sync_logs_completed_at ON integrations.sync_logs USING btree (completed_at DESC) WHERE (completed_at IS NOT NULL);


--
-- Name: idx_sync_logs_context; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_sync_logs_context ON integrations.sync_logs USING gin (context);


--
-- Name: idx_sync_logs_direction; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_sync_logs_direction ON integrations.sync_logs USING btree (direction);


--
-- Name: idx_sync_logs_error_details; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_sync_logs_error_details ON integrations.sync_logs USING gin (error_details);


--
-- Name: idx_sync_logs_errors; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_sync_logs_errors ON integrations.sync_logs USING btree (errors_count, first_error_at) WHERE (errors_count > 0);


--
-- Name: idx_sync_logs_failed; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_sync_logs_failed ON integrations.sync_logs USING btree (integration_name, started_at DESC) WHERE ((status)::text = 'failed'::text);


--
-- Name: idx_sync_logs_integration_name; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_sync_logs_integration_name ON integrations.sync_logs USING btree (integration_name);


--
-- Name: idx_sync_logs_retry_of; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_sync_logs_retry_of ON integrations.sync_logs USING btree (retry_of_sync_id) WHERE (retry_of_sync_id IS NOT NULL);


--
-- Name: idx_sync_logs_running; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_sync_logs_running ON integrations.sync_logs USING btree (started_at, integration_name) WHERE ((status)::text = 'running'::text);


--
-- Name: idx_sync_logs_started_at; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_sync_logs_started_at ON integrations.sync_logs USING btree (started_at DESC);


--
-- Name: idx_sync_logs_status; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_sync_logs_status ON integrations.sync_logs USING btree (status);


--
-- Name: idx_sync_logs_sync_id; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_sync_logs_sync_id ON integrations.sync_logs USING btree (sync_id);


--
-- Name: idx_sync_logs_sync_type; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_sync_logs_sync_type ON integrations.sync_logs USING btree (sync_type);


--
-- Name: idx_sync_logs_tags; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_sync_logs_tags ON integrations.sync_logs USING gin (tags);


--
-- Name: idx_sync_logs_tenant_created; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_sync_logs_tenant_created ON integrations.sync_logs USING btree (tenant_id, created_at) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_sync_logs_tenant_id; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_sync_logs_tenant_id ON integrations.sync_logs USING btree (tenant_id) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_webhook_endpoints_consecutive_failures; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_webhook_endpoints_consecutive_failures ON integrations.webhook_endpoints USING btree (consecutive_failures) WHERE (consecutive_failures > 0);


--
-- Name: idx_webhook_endpoints_custom_headers; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_webhook_endpoints_custom_headers ON integrations.webhook_endpoints USING gin (custom_headers);


--
-- Name: idx_webhook_endpoints_event_types; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_webhook_endpoints_event_types ON integrations.webhook_endpoints USING gin (event_types);


--
-- Name: idx_webhook_endpoints_filter_rules; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_webhook_endpoints_filter_rules ON integrations.webhook_endpoints USING gin (filter_rules);


--
-- Name: idx_webhook_endpoints_is_active; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_webhook_endpoints_is_active ON integrations.webhook_endpoints USING btree (is_active);


--
-- Name: idx_webhook_endpoints_is_paused; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_webhook_endpoints_is_paused ON integrations.webhook_endpoints USING btree (is_paused) WHERE (is_paused = true);


--
-- Name: idx_webhook_endpoints_name; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_webhook_endpoints_name ON integrations.webhook_endpoints USING btree (name);


--
-- Name: idx_webhook_endpoints_paused_until; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_webhook_endpoints_paused_until ON integrations.webhook_endpoints USING btree (paused_until) WHERE (paused_until IS NOT NULL);


--
-- Name: idx_webhook_endpoints_tags; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_webhook_endpoints_tags ON integrations.webhook_endpoints USING gin (tags);


--
-- Name: idx_webhook_endpoints_tenant_created; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_webhook_endpoints_tenant_created ON integrations.webhook_endpoints USING btree (tenant_id, created_at) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_webhook_endpoints_tenant_id; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_webhook_endpoints_tenant_id ON integrations.webhook_endpoints USING btree (tenant_id) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_webhook_endpoints_url; Type: INDEX; Schema: integrations; Owner: postgres
--

CREATE INDEX idx_webhook_endpoints_url ON integrations.webhook_endpoints USING btree (url);


--
-- Name: idx_settlements_status; Type: INDEX; Schema: marketplace; Owner: postgres
--

CREATE INDEX idx_settlements_status ON marketplace.royalty_settlements USING btree (status, created_at);


--
-- Name: idx_settlements_venue; Type: INDEX; Schema: marketplace; Owner: postgres
--

CREATE INDEX idx_settlements_venue ON marketplace.royalty_settlements USING btree (venue_id, settlement_period_start DESC);


--
-- Name: idx_campaigns_ab_tests; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_campaigns_ab_tests ON notifications.campaigns USING btree (is_ab_test, created_at DESC) WHERE (is_ab_test = true);


--
-- Name: idx_campaigns_active; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_campaigns_active ON notifications.campaigns USING btree (scheduled_at, status) WHERE ((status)::text = ANY (ARRAY[('scheduled'::character varying)::text, ('active'::character varying)::text]));


--
-- Name: idx_campaigns_budget; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_campaigns_budget ON notifications.campaigns USING btree (budget_amount, spent_amount) WHERE (budget_amount > (0)::numeric);


--
-- Name: idx_campaigns_completed_at; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_campaigns_completed_at ON notifications.campaigns USING btree (completed_at DESC) WHERE (completed_at IS NOT NULL);


--
-- Name: idx_campaigns_created_by; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_campaigns_created_by ON notifications.campaigns USING btree (created_by, created_at DESC);


--
-- Name: idx_campaigns_metadata; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_campaigns_metadata ON notifications.campaigns USING gin (metadata);


--
-- Name: idx_campaigns_pending_approval; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_campaigns_pending_approval ON notifications.campaigns USING btree (created_at, requires_approval) WHERE ((requires_approval = true) AND (approved_at IS NULL));


--
-- Name: idx_campaigns_performance; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_campaigns_performance ON notifications.campaigns USING btree (sends_count DESC, opens_count DESC, clicks_count DESC) WHERE ((status)::text = 'completed'::text);


--
-- Name: idx_campaigns_scheduled_at; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_campaigns_scheduled_at ON notifications.campaigns USING btree (scheduled_at) WHERE (scheduled_at IS NOT NULL);


--
-- Name: idx_campaigns_slug; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_campaigns_slug ON notifications.campaigns USING btree (slug);


--
-- Name: idx_campaigns_started_at; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_campaigns_started_at ON notifications.campaigns USING btree (started_at DESC) WHERE (started_at IS NOT NULL);


--
-- Name: idx_campaigns_status; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_campaigns_status ON notifications.campaigns USING btree (status);


--
-- Name: idx_campaigns_tags; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_campaigns_tags ON notifications.campaigns USING gin (tags);


--
-- Name: idx_campaigns_tenant_created; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_campaigns_tenant_created ON notifications.campaigns USING btree (tenant_id, created_at) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_campaigns_tenant_id; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_campaigns_tenant_id ON notifications.campaigns USING btree (tenant_id) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_campaigns_type; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_campaigns_type ON notifications.campaigns USING btree (type);


--
-- Name: idx_delivery_tracking_batch; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_delivery_tracking_batch ON notifications.delivery_tracking USING btree (batch_id) WHERE (batch_id IS NOT NULL);


--
-- Name: idx_delivery_tracking_campaign_id; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_delivery_tracking_campaign_id ON notifications.delivery_tracking USING btree (campaign_id) WHERE (campaign_id IS NOT NULL);


--
-- Name: idx_delivery_tracking_cost; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_delivery_tracking_cost ON notifications.delivery_tracking USING btree (actual_cost DESC) WHERE (actual_cost > (0)::numeric);


--
-- Name: idx_delivery_tracking_delivered_at; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_delivery_tracking_delivered_at ON notifications.delivery_tracking USING btree (delivered_at DESC) WHERE (delivered_at IS NOT NULL);


--
-- Name: idx_delivery_tracking_failed_bounced; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_delivery_tracking_failed_bounced ON notifications.delivery_tracking USING btree (status, bounce_type, is_retryable, retry_after) WHERE ((status)::text = ANY (ARRAY[('failed'::character varying)::text, ('bounced'::character varying)::text]));


--
-- Name: idx_delivery_tracking_message_id; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_delivery_tracking_message_id ON notifications.delivery_tracking USING btree (message_id);


--
-- Name: idx_delivery_tracking_notification_history_id; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_delivery_tracking_notification_history_id ON notifications.delivery_tracking USING btree (notification_history_id);


--
-- Name: idx_delivery_tracking_platform; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_delivery_tracking_platform ON notifications.delivery_tracking USING btree (platform) WHERE (platform IS NOT NULL);


--
-- Name: idx_delivery_tracking_provider; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_delivery_tracking_provider ON notifications.delivery_tracking USING btree (provider_name, provider_account);


--
-- Name: idx_delivery_tracking_provider_events; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_delivery_tracking_provider_events ON notifications.delivery_tracking USING gin (provider_events);


--
-- Name: idx_delivery_tracking_queued_at; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_delivery_tracking_queued_at ON notifications.delivery_tracking USING btree (queued_at DESC);


--
-- Name: idx_delivery_tracking_retry; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_delivery_tracking_retry ON notifications.delivery_tracking USING btree (retry_after, is_retryable) WHERE ((is_retryable = true) AND (retry_after IS NOT NULL));


--
-- Name: idx_delivery_tracking_status; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_delivery_tracking_status ON notifications.delivery_tracking USING btree (status);


--
-- Name: idx_delivery_tracking_tenant_created; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_delivery_tracking_tenant_created ON notifications.delivery_tracking USING btree (tenant_id, created_at) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_delivery_tracking_tenant_id; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_delivery_tracking_tenant_id ON notifications.delivery_tracking USING btree (tenant_id) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_delivery_tracking_webhook_data; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_delivery_tracking_webhook_data ON notifications.delivery_tracking USING gin (webhook_data);


--
-- Name: idx_notification_history_campaign_id; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_history_campaign_id ON notifications.notification_history USING btree (campaign_id) WHERE (campaign_id IS NOT NULL);


--
-- Name: idx_notification_history_channel; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_history_channel ON notifications.notification_history USING btree (channel);


--
-- Name: idx_notification_history_context; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_history_context ON notifications.notification_history USING gin (context);


--
-- Name: idx_notification_history_created_at; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_history_created_at ON notifications.notification_history USING btree (created_at DESC);


--
-- Name: idx_notification_history_customer_profile_id; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_history_customer_profile_id ON notifications.notification_history USING btree (customer_profile_id);


--
-- Name: idx_notification_history_delivered_at; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_history_delivered_at ON notifications.notification_history USING btree (delivered_at DESC) WHERE (delivered_at IS NOT NULL);


--
-- Name: idx_notification_history_engagement; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_history_engagement ON notifications.notification_history USING btree (opened_at, clicked_at) WHERE ((opened_at IS NOT NULL) OR (clicked_at IS NOT NULL));


--
-- Name: idx_notification_history_failed; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_history_failed ON notifications.notification_history USING btree (failed_at DESC, customer_profile_id) WHERE ((status)::text = 'failed'::text);


--
-- Name: idx_notification_history_pending; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_history_pending ON notifications.notification_history USING btree (created_at, id) WHERE ((status)::text = 'pending'::text);


--
-- Name: idx_notification_history_provider; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_history_provider ON notifications.notification_history USING btree (provider, provider_message_id) WHERE (provider IS NOT NULL);


--
-- Name: idx_notification_history_retry; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_history_retry ON notifications.notification_history USING btree (next_retry_at, retry_count) WHERE ((next_retry_at IS NOT NULL) AND ((status)::text = 'failed'::text));


--
-- Name: idx_notification_history_sent_at; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_history_sent_at ON notifications.notification_history USING btree (sent_at DESC) WHERE (sent_at IS NOT NULL);


--
-- Name: idx_notification_history_status; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_history_status ON notifications.notification_history USING btree (status);


--
-- Name: idx_notification_history_tags; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_history_tags ON notifications.notification_history USING gin (tags);


--
-- Name: idx_notification_history_template_id; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_history_template_id ON notifications.notification_history USING btree (template_id) WHERE (template_id IS NOT NULL);


--
-- Name: idx_notification_history_tenant_created; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_history_tenant_created ON notifications.notification_history USING btree (tenant_id, created_at) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_notification_history_tenant_id; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_history_tenant_id ON notifications.notification_history USING btree (tenant_id) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_notification_preferences_active; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_preferences_active ON notifications.notification_preferences USING btree (customer_profile_id) WHERE ((all_notifications_enabled = true) AND (unsubscribed_all = false));


--
-- Name: idx_notification_preferences_customer_profile_id; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_preferences_customer_profile_id ON notifications.notification_preferences USING btree (customer_profile_id);


--
-- Name: idx_notification_preferences_email_enabled; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_preferences_email_enabled ON notifications.notification_preferences USING btree (customer_profile_id) WHERE ((email_enabled = true) AND (all_notifications_enabled = true));


--
-- Name: idx_notification_preferences_engagement; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_preferences_engagement ON notifications.notification_preferences USING btree (last_email_open DESC, last_sms_click DESC) WHERE ((last_email_open IS NOT NULL) OR (last_sms_click IS NOT NULL));


--
-- Name: idx_notification_preferences_language; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_preferences_language ON notifications.notification_preferences USING btree (notification_language);


--
-- Name: idx_notification_preferences_marketing; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_preferences_marketing ON notifications.notification_preferences USING btree (customer_profile_id) WHERE ((marketing_enabled = true) AND (all_notifications_enabled = true));


--
-- Name: idx_notification_preferences_push_enabled; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_preferences_push_enabled ON notifications.notification_preferences USING btree (customer_profile_id) WHERE ((push_enabled = true) AND (all_notifications_enabled = true));


--
-- Name: idx_notification_preferences_sms_enabled; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_preferences_sms_enabled ON notifications.notification_preferences USING btree (customer_profile_id) WHERE ((sms_enabled = true) AND (all_notifications_enabled = true));


--
-- Name: idx_notification_preferences_tenant_created; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_preferences_tenant_created ON notifications.notification_preferences USING btree (tenant_id, created_at) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_notification_preferences_tenant_id; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_preferences_tenant_id ON notifications.notification_preferences USING btree (tenant_id) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_notification_preferences_unsubscribe_token; Type: INDEX; Schema: notifications; Owner: postgres
--

CREATE INDEX idx_notification_preferences_unsubscribe_token ON notifications.notification_preferences USING btree (unsubscribe_token) WHERE (unsubscribe_token IS NOT NULL);


--
-- Name: idx_audit_alerts_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_audit_alerts_active ON public.audit_log_alerts USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_audit_alerts_last_triggered; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_audit_alerts_last_triggered ON public.audit_log_alerts USING btree (last_triggered_at);


--
-- Name: idx_audit_logs_action; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_audit_logs_action ON public.audit_logs USING btree (action);


--
-- Name: idx_audit_logs_created_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_audit_logs_created_at ON public.audit_logs USING btree (created_at);


--
-- Name: idx_audit_logs_created_at_desc; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_audit_logs_created_at_desc ON public.audit_logs USING btree (created_at DESC);


--
-- Name: idx_audit_logs_lookup; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_audit_logs_lookup ON public.audit_logs USING btree (table_name, record_id, created_at DESC);


--
-- Name: idx_audit_logs_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_audit_logs_user_id ON public.audit_logs USING btree (user_id) WHERE (user_id IS NOT NULL);


--
-- Name: idx_audit_logs_user_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_audit_logs_user_time ON public.audit_logs USING btree (user_id, created_at DESC) WHERE (user_id IS NOT NULL);


--
-- Name: idx_audit_summaries_created_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_audit_summaries_created_at ON public.audit_log_summaries USING btree (created_at);


--
-- Name: idx_audit_summaries_date_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_audit_summaries_date_type ON public.audit_log_summaries USING btree (summary_date, summary_type);


--
-- Name: idx_availability_schedules_release; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_availability_schedules_release ON public.ticket_type_availability_schedules USING btree (release_date, is_processed);


--
-- Name: idx_availability_schedules_ticket_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_availability_schedules_ticket_type ON public.ticket_type_availability_schedules USING btree (ticket_type_id);


--
-- Name: idx_batch_operations_event; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_batch_operations_event ON public.ticket_batch_operations USING btree (event_id);


--
-- Name: idx_batch_operations_initiator; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_batch_operations_initiator ON public.ticket_batch_operations USING btree (initiated_by);


--
-- Name: idx_batch_operations_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_batch_operations_status ON public.ticket_batch_operations USING btree (status);


--
-- Name: idx_batch_operations_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_batch_operations_type ON public.ticket_batch_operations USING btree (operation_type);


--
-- Name: idx_blockchain_transactions_block_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_blockchain_transactions_block_time ON public.blockchain_transactions USING btree (block_time);


--
-- Name: idx_blockchain_transactions_from_wallet; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_blockchain_transactions_from_wallet ON public.blockchain_transactions USING btree (from_wallet);


--
-- Name: idx_blockchain_transactions_signature; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_blockchain_transactions_signature ON public.blockchain_transactions USING btree (transaction_signature);


--
-- Name: idx_blockchain_transactions_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_blockchain_transactions_status ON public.blockchain_transactions USING btree (status);


--
-- Name: idx_blockchain_transactions_status_created; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_blockchain_transactions_status_created ON public.blockchain_transactions USING btree (status, created_at);


--
-- Name: idx_blockchain_transactions_ticket_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_blockchain_transactions_ticket_id ON public.blockchain_transactions USING btree (ticket_id);


--
-- Name: idx_blockchain_transactions_to_wallet; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_blockchain_transactions_to_wallet ON public.blockchain_transactions USING btree (to_wallet);


--
-- Name: idx_blockchain_transactions_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_blockchain_transactions_type ON public.blockchain_transactions USING btree (type);


--
-- Name: idx_capacity_alerts_event; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_capacity_alerts_event ON public.event_capacity_alerts USING btree (event_capacity_id);


--
-- Name: idx_capacity_alerts_level; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_capacity_alerts_level ON public.event_capacity_alerts USING btree (alert_level);


--
-- Name: idx_capacity_alerts_unresolved; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_capacity_alerts_unresolved ON public.event_capacity_alerts USING btree (resolved_at) WHERE (resolved_at IS NULL);


--
-- Name: idx_capacity_by_tier_event; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_capacity_by_tier_event ON public.event_capacity_by_tier USING btree (event_capacity_id);


--
-- Name: idx_capacity_by_tier_priority; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_capacity_by_tier_priority ON public.event_capacity_by_tier USING btree (tier_priority);


--
-- Name: idx_capacity_by_type_event; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_capacity_by_type_event ON public.event_capacity_by_type USING btree (event_capacity_id);


--
-- Name: idx_capacity_by_type_ticket; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_capacity_by_type_ticket ON public.event_capacity_by_type USING btree (ticket_type_id);


--
-- Name: idx_capacity_holds_event; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_capacity_holds_event ON public.event_capacity_holds USING btree (event_capacity_id);


--
-- Name: idx_capacity_holds_expires; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_capacity_holds_expires ON public.event_capacity_holds USING btree (expires_at);


--
-- Name: idx_capacity_holds_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_capacity_holds_status ON public.event_capacity_holds USING btree (status);


--
-- Name: idx_capacity_reservations_event; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_capacity_reservations_event ON public.event_capacity_reservations USING btree (event_capacity_id);


--
-- Name: idx_capacity_reservations_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_capacity_reservations_type ON public.event_capacity_reservations USING btree (reservation_type);


--
-- Name: idx_capacity_snapshots_event; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_capacity_snapshots_event ON public.event_capacity_snapshots USING btree (event_capacity_id);


--
-- Name: idx_capacity_snapshots_timestamp; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_capacity_snapshots_timestamp ON public.event_capacity_snapshots USING btree (snapshot_timestamp);


--
-- Name: idx_capacity_utilization_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_capacity_utilization_date ON public.event_capacity_utilization_history USING btree (date_recorded);


--
-- Name: idx_capacity_utilization_event; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_capacity_utilization_event ON public.event_capacity_utilization_history USING btree (event_capacity_id);


--
-- Name: idx_category_analytics_category; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_category_analytics_category ON public.event_category_analytics USING btree (category_id);


--
-- Name: idx_category_analytics_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_category_analytics_date ON public.event_category_analytics USING btree (analytics_date);


--
-- Name: idx_category_attributes_category; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_category_attributes_category ON public.event_category_attributes USING btree (category_id);


--
-- Name: idx_category_attributes_name; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_category_attributes_name ON public.event_category_attributes USING btree (attribute_name);


--
-- Name: idx_category_attributes_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_category_attributes_type ON public.event_category_attributes USING btree (attribute_type);


--
-- Name: idx_category_suggestions_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_category_suggestions_active ON public.event_category_search_suggestions USING btree (is_active);


--
-- Name: idx_category_suggestions_category; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_category_suggestions_category ON public.event_category_search_suggestions USING btree (category_id);


--
-- Name: idx_category_suggestions_text; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_category_suggestions_text ON public.event_category_search_suggestions USING btree (suggestion_text);


--
-- Name: idx_category_tags_category; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_category_tags_category ON public.event_category_tags USING btree (category_id);


--
-- Name: idx_category_tags_name; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_category_tags_name ON public.event_category_tags USING btree (tag_name);


--
-- Name: idx_category_tags_search; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_category_tags_search ON public.event_category_tags USING gin (to_tsvector('english'::regconfig, (tag_name)::text));


--
-- Name: idx_category_tags_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_category_tags_type ON public.event_category_tags USING btree (tag_type);


--
-- Name: idx_category_tags_weight; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_category_tags_weight ON public.event_category_tags USING btree (search_weight DESC);


--
-- Name: idx_category_trending_category; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_category_trending_category ON public.event_category_trending USING btree (category_id);


--
-- Name: idx_category_trending_period; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_category_trending_period ON public.event_category_trending USING btree (trending_period, period_start);


--
-- Name: idx_category_trending_score; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_category_trending_score ON public.event_category_trending USING btree (trending_score DESC);


--
-- Name: idx_comms_log_email; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_comms_log_email ON public.communications_log USING btree (recipient_email);


--
-- Name: idx_compliance_inspections_compliance_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_compliance_inspections_compliance_id ON public.compliance_inspections USING btree (compliance_id) WHERE (compliance_id IS NOT NULL);


--
-- Name: idx_compliance_inspections_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_compliance_inspections_date ON public.compliance_inspections USING btree (inspection_date);


--
-- Name: idx_compliance_inspections_followup; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_compliance_inspections_followup ON public.compliance_inspections USING btree (follow_up_date) WHERE (follow_up_inspection_required = true);


--
-- Name: idx_compliance_inspections_result; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_compliance_inspections_result ON public.compliance_inspections USING btree (overall_result);


--
-- Name: idx_compliance_inspections_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_compliance_inspections_venue_id ON public.compliance_inspections USING btree (venue_id);


--
-- Name: idx_compliance_inspections_violations; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_compliance_inspections_violations ON public.compliance_inspections USING btree (violations_found) WHERE (violations_found > 0);


--
-- Name: idx_compliance_reminders_compliance_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_compliance_reminders_compliance_id ON public.compliance_reminders USING btree (compliance_id);


--
-- Name: idx_compliance_reminders_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_compliance_reminders_date ON public.compliance_reminders USING btree (reminder_date);


--
-- Name: idx_compliance_reminders_pending; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_compliance_reminders_pending ON public.compliance_reminders USING btree (is_sent, reminder_date) WHERE (is_sent = false);


--
-- Name: idx_compliance_reminders_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_compliance_reminders_venue_id ON public.compliance_reminders USING btree (venue_id);


--
-- Name: idx_compliance_violations_compliance_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_compliance_violations_compliance_id ON public.compliance_violations USING btree (compliance_id) WHERE (compliance_id IS NOT NULL);


--
-- Name: idx_compliance_violations_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_compliance_violations_date ON public.compliance_violations USING btree (violation_date);


--
-- Name: idx_compliance_violations_deadline; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_compliance_violations_deadline ON public.compliance_violations USING btree (remediation_deadline) WHERE (remediation_deadline IS NOT NULL);


--
-- Name: idx_compliance_violations_open; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_compliance_violations_open ON public.compliance_violations USING btree (venue_id, violation_status) WHERE (violation_status = 'open'::public.violation_status);


--
-- Name: idx_compliance_violations_severity; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_compliance_violations_severity ON public.compliance_violations USING btree (severity);


--
-- Name: idx_compliance_violations_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_compliance_violations_status ON public.compliance_violations USING btree (violation_status);


--
-- Name: idx_compliance_violations_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_compliance_violations_venue_id ON public.compliance_violations USING btree (venue_id);


--
-- Name: idx_customer_feedback_created_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_customer_feedback_created_at ON public.customer_feedback USING btree (created_at DESC);


--
-- Name: idx_customer_feedback_customer_profile_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_customer_feedback_customer_profile_id ON public.customer_feedback USING btree (customer_profile_id);


--
-- Name: idx_customer_feedback_event_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_customer_feedback_event_id ON public.customer_feedback USING btree (event_id) WHERE (event_id IS NOT NULL);


--
-- Name: idx_customer_feedback_featured; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_customer_feedback_featured ON public.customer_feedback USING btree (is_featured, created_at DESC) WHERE (is_featured = true);


--
-- Name: idx_customer_feedback_high_ratings; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_customer_feedback_high_ratings ON public.customer_feedback USING btree (overall_rating) WHERE ((overall_rating >= 4) AND ((status)::text = 'published'::text));


--
-- Name: idx_customer_feedback_low_ratings; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_customer_feedback_low_ratings ON public.customer_feedback USING btree (overall_rating) WHERE ((overall_rating <= 2) AND ((status)::text = 'published'::text));


--
-- Name: idx_customer_feedback_moderation; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_customer_feedback_moderation ON public.customer_feedback USING btree (moderation_status) WHERE ((moderation_status)::text = 'requires_review'::text);


--
-- Name: idx_customer_feedback_needs_response; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_customer_feedback_needs_response ON public.customer_feedback USING btree (venue_id, created_at DESC) WHERE ((venue_response IS NULL) AND ((type)::text = 'venue_review'::text));


--
-- Name: idx_customer_feedback_order_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_customer_feedback_order_id ON public.customer_feedback USING btree (order_id) WHERE (order_id IS NOT NULL);


--
-- Name: idx_customer_feedback_overall_rating; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_customer_feedback_overall_rating ON public.customer_feedback USING btree (overall_rating DESC) WHERE (overall_rating IS NOT NULL);


--
-- Name: idx_customer_feedback_recent_published; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_customer_feedback_recent_published ON public.customer_feedback USING btree (created_at DESC) WHERE ((status)::text = 'published'::text);


--
-- Name: idx_customer_feedback_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_customer_feedback_status ON public.customer_feedback USING btree (status);


--
-- Name: idx_customer_feedback_tenant_created; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_customer_feedback_tenant_created ON public.customer_feedback USING btree (tenant_id, created_at) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_customer_feedback_tenant_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_customer_feedback_tenant_id ON public.customer_feedback USING btree (tenant_id) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_customer_feedback_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_customer_feedback_type ON public.customer_feedback USING btree (type);


--
-- Name: idx_customer_feedback_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_customer_feedback_venue_id ON public.customer_feedback USING btree (venue_id) WHERE (venue_id IS NOT NULL);


--
-- Name: idx_customer_feedback_verified; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_customer_feedback_verified ON public.customer_feedback USING btree (is_verified_purchase) WHERE (is_verified_purchase = true);


--
-- Name: idx_customer_year; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_customer_year ON public.customer_tax_records USING btree (customer_id, year);


--
-- Name: idx_demand_factors_pricing_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_demand_factors_pricing_id ON public.event_pricing_demand_factors USING btree (event_pricing_id);


--
-- Name: idx_demand_factors_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_demand_factors_type ON public.event_pricing_demand_factors USING btree (factor_type);


--
-- Name: idx_dispute_evidence_dispute; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_dispute_evidence_dispute ON public.dispute_evidence_packs USING btree (dispute_id);


--
-- Name: idx_dispute_evidence_order; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_dispute_evidence_order ON public.dispute_evidence_packs USING btree (order_id);


--
-- Name: idx_disputes_priority; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_disputes_priority ON public.dispute_resolution USING btree (priority, created_at);


--
-- Name: idx_disputes_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_disputes_status ON public.dispute_resolution USING btree (status);


--
-- Name: idx_dynamic_rules_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_dynamic_rules_active ON public.event_pricing_dynamic_rules USING btree (is_active);


--
-- Name: idx_dynamic_rules_pricing_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_dynamic_rules_pricing_id ON public.event_pricing_dynamic_rules USING btree (event_pricing_id);


--
-- Name: idx_dynamic_rules_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_dynamic_rules_type ON public.event_pricing_dynamic_rules USING btree (rule_type);


--
-- Name: idx_escrow_auto_release; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_escrow_auto_release ON public.escrow USING btree (auto_release_at) WHERE ((status)::text = 'HELD'::text);


--
-- Name: idx_escrow_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_escrow_status ON public.escrow USING btree (status);


--
-- Name: idx_event_analytics_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_analytics_active ON public.event_analytics_tracking USING btree (is_active);


--
-- Name: idx_event_analytics_config; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_analytics_config ON public.event_analytics_tracking USING gin (config_parameters);


--
-- Name: idx_event_analytics_event_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_analytics_event_id ON public.event_analytics_tracking USING btree (event_id);


--
-- Name: idx_event_analytics_provider; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_analytics_provider ON public.event_analytics_tracking USING btree (analytics_provider);


--
-- Name: idx_event_capacity_available; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_capacity_available ON public.event_capacity USING btree (available_capacity);


--
-- Name: idx_event_capacity_event_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_capacity_event_id ON public.event_capacity USING btree (event_id);


--
-- Name: idx_event_capacity_schedule_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_capacity_schedule_id ON public.event_capacity USING btree (schedule_id);


--
-- Name: idx_event_categories_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_categories_active ON public.event_categories USING btree (is_active);


--
-- Name: idx_event_categories_featured; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_categories_featured ON public.event_categories USING btree (is_featured);


--
-- Name: idx_event_categories_parent; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_categories_parent ON public.event_categories USING btree (parent_id);


--
-- Name: idx_event_categories_slug; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_categories_slug ON public.event_categories USING btree (slug);


--
-- Name: idx_event_category_mappings_category; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_category_mappings_category ON public.event_category_mappings USING btree (category_id);


--
-- Name: idx_event_category_mappings_event; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_category_mappings_event ON public.event_category_mappings USING btree (event_id);


--
-- Name: idx_event_category_mappings_primary; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_category_mappings_primary ON public.event_category_mappings USING btree (is_primary_category);


--
-- Name: idx_event_custom_event_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_custom_event_id ON public.event_custom_attributes USING btree (event_id);


--
-- Name: idx_event_custom_json; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_custom_json ON public.event_custom_attributes USING gin (attribute_json);


--
-- Name: idx_event_custom_name; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_custom_name ON public.event_custom_attributes USING btree (attribute_name);


--
-- Name: idx_event_custom_public; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_custom_public ON public.event_custom_attributes USING btree (is_public);


--
-- Name: idx_event_custom_searchable; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_custom_searchable ON public.event_custom_attributes USING btree (is_searchable);


--
-- Name: idx_event_marketing_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_marketing_active ON public.event_marketing_campaigns USING btree (is_active);


--
-- Name: idx_event_marketing_dates; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_marketing_dates ON public.event_marketing_campaigns USING btree (start_date, end_date);


--
-- Name: idx_event_marketing_event_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_marketing_event_id ON public.event_marketing_campaigns USING btree (event_id);


--
-- Name: idx_event_marketing_metrics; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_marketing_metrics ON public.event_marketing_campaigns USING gin (performance_metrics);


--
-- Name: idx_event_marketing_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_marketing_type ON public.event_marketing_campaigns USING btree (campaign_type);


--
-- Name: idx_event_metadata_event_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_metadata_event_id ON public.event_metadata USING btree (event_id);


--
-- Name: idx_event_performers_event_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_performers_event_id ON public.event_performers USING btree (event_id);


--
-- Name: idx_event_performers_featured; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_performers_featured ON public.event_performers USING btree (featured) WHERE (featured = true);


--
-- Name: idx_event_performers_headliner; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_performers_headliner ON public.event_performers USING btree (headliner) WHERE (headliner = true);


--
-- Name: idx_event_performers_order; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_performers_order ON public.event_performers USING btree (event_id, performance_order);


--
-- Name: idx_event_performers_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_performers_type ON public.event_performers USING btree (performer_type);


--
-- Name: idx_event_pricing_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_pricing_active ON public.event_pricing USING btree (is_active, sales_start_at, sales_end_at);


--
-- Name: idx_event_pricing_capacity_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_pricing_capacity_id ON public.event_pricing USING btree (capacity_id);


--
-- Name: idx_event_pricing_event_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_pricing_event_id ON public.event_pricing USING btree (event_id);


--
-- Name: idx_event_pricing_schedule_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_pricing_schedule_id ON public.event_pricing USING btree (schedule_id);


--
-- Name: idx_event_production_critical; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_production_critical ON public.event_production_schedules USING btree (is_critical) WHERE (is_critical = true);


--
-- Name: idx_event_production_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_production_date ON public.event_production_schedules USING btree (scheduled_date);


--
-- Name: idx_event_production_event_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_production_event_id ON public.event_production_schedules USING btree (event_id);


--
-- Name: idx_event_production_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_production_status ON public.event_production_schedules USING btree (completion_status);


--
-- Name: idx_event_schedules_event_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_schedules_event_id ON public.event_schedules USING btree (event_id);


--
-- Name: idx_event_schedules_starts_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_schedules_starts_at ON public.event_schedules USING btree (starts_at);


--
-- Name: idx_event_schedules_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_schedules_status ON public.event_schedules USING btree (status);


--
-- Name: idx_event_schedules_upcoming; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_schedules_upcoming ON public.event_schedules USING btree (starts_at);


--
-- Name: idx_event_seo_canonical; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_seo_canonical ON public.event_seo_metadata USING btree (canonical_url);


--
-- Name: idx_event_seo_event_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_seo_event_id ON public.event_seo_metadata USING btree (event_id);


--
-- Name: idx_event_seo_schema; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_seo_schema ON public.event_seo_metadata USING gin (schema_markup);


--
-- Name: idx_event_seo_search; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_seo_search ON public.event_seo_metadata USING gin (to_tsvector('english'::regconfig, (((((COALESCE(meta_title, ''::character varying))::text || ' '::text) || (COALESCE(meta_description, ''::character varying))::text) || ' '::text) || COALESCE(meta_keywords, ''::text))));


--
-- Name: idx_event_sessions_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_sessions_date ON public.event_sessions USING btree (session_date);


--
-- Name: idx_event_sessions_event_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_sessions_event_id ON public.event_sessions USING btree (event_id);


--
-- Name: idx_event_sessions_keynote; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_sessions_keynote ON public.event_sessions USING btree (is_keynote) WHERE (is_keynote = true);


--
-- Name: idx_event_sessions_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_sessions_time ON public.event_sessions USING btree (session_date, start_time);


--
-- Name: idx_event_sessions_track; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_sessions_track ON public.event_sessions USING btree (session_track) WHERE (session_track IS NOT NULL);


--
-- Name: idx_event_social_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_social_active ON public.event_social_media USING btree (is_active);


--
-- Name: idx_event_social_event_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_social_event_id ON public.event_social_media USING btree (event_id);


--
-- Name: idx_event_social_platform; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_social_platform ON public.event_social_media USING btree (platform);


--
-- Name: idx_event_social_tracking; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_event_social_tracking ON public.event_social_media USING gin (tracking_parameters);


--
-- Name: idx_events_created_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_events_created_at ON public.events USING btree (created_at);


--
-- Name: idx_events_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_events_status ON public.events USING btree (status);


--
-- Name: idx_events_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_events_venue_id ON public.events USING btree (venue_id);


--
-- Name: idx_feedback_responses_feedback_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_feedback_responses_feedback_id ON public.feedback_responses USING btree (feedback_id);


--
-- Name: idx_feedback_responses_responder; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_feedback_responses_responder ON public.feedback_responses USING btree (responder_id, responder_type);


--
-- Name: idx_financial_reports_period; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_financial_reports_period ON public.financial_reports USING btree (period_start, period_end);


--
-- Name: idx_financial_reports_revenue; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_financial_reports_revenue ON public.financial_reports USING btree (gross_revenue DESC) WHERE (gross_revenue IS NOT NULL);


--
-- Name: idx_financial_reports_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_financial_reports_status ON public.financial_reports USING btree (status);


--
-- Name: idx_financial_reports_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_financial_reports_type ON public.financial_reports USING btree (report_type);


--
-- Name: idx_gas_fee_tracking_analytics; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_gas_fee_tracking_analytics ON public.gas_fee_tracking USING btree (created_at, total_fee_lamports, priority);


--
-- Name: idx_gas_fee_tracking_confirmation_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_gas_fee_tracking_confirmation_time ON public.gas_fee_tracking USING btree (confirmation_time_ms);


--
-- Name: idx_gas_fee_tracking_congestion; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_gas_fee_tracking_congestion ON public.gas_fee_tracking USING btree (network_congestion_level);


--
-- Name: idx_gas_fee_tracking_created_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_gas_fee_tracking_created_at ON public.gas_fee_tracking USING btree (created_at);


--
-- Name: idx_gas_fee_tracking_fee_payer; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_gas_fee_tracking_fee_payer ON public.gas_fee_tracking USING btree (fee_payer_wallet);


--
-- Name: idx_gas_fee_tracking_priority; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_gas_fee_tracking_priority ON public.gas_fee_tracking USING btree (priority);


--
-- Name: idx_gas_fee_tracking_reimbursable; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_gas_fee_tracking_reimbursable ON public.gas_fee_tracking USING btree (reimbursable, reimbursed) WHERE (reimbursable = true);


--
-- Name: idx_gas_fee_tracking_subsidized; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_gas_fee_tracking_subsidized ON public.gas_fee_tracking USING btree (subsidized, subsidy_amount) WHERE (subsidized = true);


--
-- Name: idx_gas_fee_tracking_total_fee; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_gas_fee_tracking_total_fee ON public.gas_fee_tracking USING btree (total_fee_lamports);


--
-- Name: idx_gas_fee_tracking_transaction_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_gas_fee_tracking_transaction_id ON public.gas_fee_tracking USING btree (transaction_id);


--
-- Name: idx_gdpr_customer; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_gdpr_customer ON public.gdpr_deletion_requests USING btree (customer_id);


--
-- Name: idx_gdpr_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_gdpr_status ON public.gdpr_deletion_requests USING btree (status);


--
-- Name: idx_group_discounts_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_group_discounts_active ON public.event_pricing_group_discounts USING btree (is_active);


--
-- Name: idx_group_discounts_pricing_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_group_discounts_pricing_id ON public.event_pricing_group_discounts USING btree (event_pricing_id);


--
-- Name: idx_idempotency_created; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_idempotency_created ON public.idempotency_keys USING btree (created_at);


--
-- Name: idx_integration_data_mappings_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_integration_data_mappings_active ON public.integration_data_mappings USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_integration_data_mappings_entity; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_integration_data_mappings_entity ON public.integration_data_mappings USING btree (data_entity);


--
-- Name: idx_integration_data_mappings_integration_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_integration_data_mappings_integration_id ON public.integration_data_mappings USING btree (integration_id);


--
-- Name: idx_integration_logs_correlation_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_integration_logs_correlation_id ON public.integration_logs USING btree (correlation_id) WHERE (correlation_id IS NOT NULL);


--
-- Name: idx_integration_logs_created_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_integration_logs_created_at ON public.integration_logs USING btree (created_at);


--
-- Name: idx_integration_logs_error; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_integration_logs_error ON public.integration_logs USING btree (created_at) WHERE ((log_level)::text = ANY (ARRAY[('error'::character varying)::text, ('fatal'::character varying)::text]));


--
-- Name: idx_integration_logs_integration_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_integration_logs_integration_id ON public.integration_logs USING btree (integration_id);


--
-- Name: idx_integration_logs_level; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_integration_logs_level ON public.integration_logs USING btree (log_level);


--
-- Name: idx_integration_logs_request_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_integration_logs_request_id ON public.integration_logs USING btree (request_id) WHERE (request_id IS NOT NULL);


--
-- Name: idx_integration_logs_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_integration_logs_type ON public.integration_logs USING btree (log_type);


--
-- Name: idx_integration_logs_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_integration_logs_venue_id ON public.integration_logs USING btree (venue_id);


--
-- Name: idx_integration_logs_webhook_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_integration_logs_webhook_id ON public.integration_logs USING btree (webhook_id) WHERE (webhook_id IS NOT NULL);


--
-- Name: idx_integration_schedules_enabled; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_integration_schedules_enabled ON public.integration_schedules USING btree (is_enabled) WHERE (is_enabled = true);


--
-- Name: idx_integration_schedules_integration_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_integration_schedules_integration_id ON public.integration_schedules USING btree (integration_id);


--
-- Name: idx_integration_schedules_next_run; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_integration_schedules_next_run ON public.integration_schedules USING btree (next_run_at) WHERE (is_enabled = true);


--
-- Name: idx_integration_webhooks_deliveries; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_integration_webhooks_deliveries ON public.integration_webhooks USING btree (last_delivery_at, consecutive_failures);


--
-- Name: idx_integration_webhooks_failures; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_integration_webhooks_failures ON public.integration_webhooks USING btree (consecutive_failures) WHERE (consecutive_failures > 0);


--
-- Name: idx_integration_webhooks_integration_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_integration_webhooks_integration_id ON public.integration_webhooks USING btree (integration_id);


--
-- Name: idx_integration_webhooks_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_integration_webhooks_status ON public.integration_webhooks USING btree (webhook_status);


--
-- Name: idx_integration_webhooks_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_integration_webhooks_venue_id ON public.integration_webhooks USING btree (venue_id);


--
-- Name: idx_integration_webhooks_verified; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_integration_webhooks_verified ON public.integration_webhooks USING btree (is_verified) WHERE (is_verified = true);


--
-- Name: idx_invoices_due_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invoices_due_date ON public.invoices USING btree (due_date);


--
-- Name: idx_invoices_number; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invoices_number ON public.invoices USING btree (invoice_number);


--
-- Name: idx_invoices_open; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invoices_open ON public.invoices USING btree (due_date, status) WHERE ((status)::text = 'open'::text);


--
-- Name: idx_invoices_pdf; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invoices_pdf ON public.invoices USING btree (pdf_generated_at) WHERE (pdf_url IS NOT NULL);


--
-- Name: idx_invoices_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invoices_status ON public.invoices USING btree (status);


--
-- Name: idx_invoices_subscription; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invoices_subscription ON public.invoices USING btree (subscription_id) WHERE (subscription_id IS NOT NULL);


--
-- Name: idx_invoices_subscription_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invoices_subscription_id ON public.invoices USING btree (subscription_id);


--
-- Name: idx_invoices_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invoices_user ON public.invoices USING btree (user_id) WHERE (user_id IS NOT NULL);


--
-- Name: idx_invoices_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invoices_user_id ON public.invoices USING btree (user_id);


--
-- Name: idx_layout_accessibility_available; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_accessibility_available ON public.layout_accessibility_features USING btree (is_available) WHERE (is_available = true);


--
-- Name: idx_layout_accessibility_layout_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_accessibility_layout_id ON public.layout_accessibility_features USING btree (layout_id);


--
-- Name: idx_layout_accessibility_section; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_accessibility_section ON public.layout_accessibility_features USING btree (section_id) WHERE (section_id IS NOT NULL);


--
-- Name: idx_layout_accessibility_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_accessibility_type ON public.layout_accessibility_features USING btree (feature_type);


--
-- Name: idx_layout_pricing_zones_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_pricing_zones_active ON public.layout_pricing_zones USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_layout_pricing_zones_layout_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_pricing_zones_layout_id ON public.layout_pricing_zones USING btree (layout_id);


--
-- Name: idx_layout_pricing_zones_tier; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_pricing_zones_tier ON public.layout_pricing_zones USING btree (pricing_tier);


--
-- Name: idx_layout_pricing_zones_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_pricing_zones_venue_id ON public.layout_pricing_zones USING btree (venue_id);


--
-- Name: idx_layout_seats_accessible; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_seats_accessible ON public.layout_seats USING btree (is_accessible) WHERE (is_accessible = true);


--
-- Name: idx_layout_seats_available; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_seats_available ON public.layout_seats USING btree (is_active, is_saleable, is_blocked);


--
-- Name: idx_layout_seats_companion; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_seats_companion ON public.layout_seats USING btree (is_companion) WHERE (is_companion = true);


--
-- Name: idx_layout_seats_layout_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_seats_layout_id ON public.layout_seats USING btree (layout_id);


--
-- Name: idx_layout_seats_position; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_seats_position ON public.layout_seats USING gin (seat_position) WHERE (seat_position IS NOT NULL);


--
-- Name: idx_layout_seats_pricing; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_seats_pricing ON public.layout_seats USING btree (pricing_tier);


--
-- Name: idx_layout_seats_row_seat; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_seats_row_seat ON public.layout_seats USING btree (section_id, row_identifier, seat_number);


--
-- Name: idx_layout_seats_section_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_seats_section_id ON public.layout_seats USING btree (section_id);


--
-- Name: idx_layout_seats_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_seats_type ON public.layout_seats USING btree (seat_type);


--
-- Name: idx_layout_seats_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_seats_venue_id ON public.layout_seats USING btree (venue_id);


--
-- Name: idx_layout_sections_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_sections_active ON public.layout_sections USING btree (is_active, is_saleable);


--
-- Name: idx_layout_sections_hierarchy; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_sections_hierarchy ON public.layout_sections USING btree (layout_id, section_level, display_order);


--
-- Name: idx_layout_sections_layout_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_sections_layout_id ON public.layout_sections USING btree (layout_id);


--
-- Name: idx_layout_sections_parent; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_sections_parent ON public.layout_sections USING btree (parent_section_id) WHERE (parent_section_id IS NOT NULL);


--
-- Name: idx_layout_sections_position; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_sections_position ON public.layout_sections USING gin (section_position) WHERE (section_position IS NOT NULL);


--
-- Name: idx_layout_sections_pricing; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_sections_pricing ON public.layout_sections USING btree (pricing_tier);


--
-- Name: idx_layout_sections_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_sections_type ON public.layout_sections USING btree (section_type);


--
-- Name: idx_layout_sections_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_layout_sections_venue_id ON public.layout_sections USING btree (venue_id);


--
-- Name: idx_listings_expires_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_listings_expires_at ON public.listings USING btree (expires_at) WHERE (expires_at IS NOT NULL);


--
-- Name: idx_listings_price; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_listings_price ON public.listings USING btree (price);


--
-- Name: idx_listings_seller_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_listings_seller_id ON public.listings USING btree (seller_id);


--
-- Name: idx_listings_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_listings_status ON public.listings USING btree (status) WHERE ((status)::text = 'ACTIVE'::text);


--
-- Name: idx_listings_ticket_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_listings_ticket_id ON public.listings USING btree (ticket_id);


--
-- Name: idx_loyalty_programs_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_loyalty_programs_active ON public.loyalty_programs USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_loyalty_programs_default; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_loyalty_programs_default ON public.loyalty_programs USING btree (is_default) WHERE (is_default = true);


--
-- Name: idx_loyalty_programs_tenant_created; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_loyalty_programs_tenant_created ON public.loyalty_programs USING btree (tenant_id, created_at) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_loyalty_programs_tenant_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_loyalty_programs_tenant_id ON public.loyalty_programs USING btree (tenant_id) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_loyalty_programs_tiers; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_loyalty_programs_tiers ON public.loyalty_programs USING gin (tiers);


--
-- Name: idx_market_analytics_lookup; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_market_analytics_lookup ON public.market_analytics USING btree (analytics_type, scope_id, period, period_start);


--
-- Name: idx_marketplace_tx_buyer_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_marketplace_tx_buyer_id ON public.marketplace_transactions USING btree (buyer_id);


--
-- Name: idx_marketplace_tx_listing_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_marketplace_tx_listing_id ON public.marketplace_transactions USING btree (listing_id);


--
-- Name: idx_marketplace_tx_seller_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_marketplace_tx_seller_id ON public.marketplace_transactions USING btree (seller_id);


--
-- Name: idx_marketplace_tx_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_marketplace_tx_status ON public.marketplace_transactions USING btree (status);


--
-- Name: idx_metadata_history_changed_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_metadata_history_changed_at ON public.event_metadata_history USING btree (changed_at);


--
-- Name: idx_metadata_history_event_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_metadata_history_event_id ON public.event_metadata_history USING btree (event_id);


--
-- Name: idx_metadata_history_metadata_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_metadata_history_metadata_id ON public.event_metadata_history USING btree (metadata_id);


--
-- Name: idx_metadata_templates_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_metadata_templates_active ON public.event_metadata_templates USING btree (is_active);


--
-- Name: idx_metadata_templates_category; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_metadata_templates_category ON public.event_metadata_templates USING btree (category_id);


--
-- Name: idx_metadata_templates_global; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_metadata_templates_global ON public.event_metadata_templates USING btree (is_global);


--
-- Name: idx_metadata_templates_venue; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_metadata_templates_venue ON public.event_metadata_templates USING btree (venue_id);


--
-- Name: idx_nft_metadata_attributes_gin; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_nft_metadata_attributes_gin ON public.nft_metadata USING gin (attributes);


--
-- Name: idx_nft_metadata_cache_expires; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_nft_metadata_cache_expires ON public.nft_metadata USING btree (cache_expires_at) WHERE (cache_expires_at IS NOT NULL);


--
-- Name: idx_nft_metadata_collection; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_nft_metadata_collection ON public.nft_metadata USING btree (collection_address) WHERE (collection_address IS NOT NULL);


--
-- Name: idx_nft_metadata_compressed; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_nft_metadata_compressed ON public.nft_metadata USING btree (tree_address, leaf_index) WHERE (is_compressed = true);


--
-- Name: idx_nft_metadata_creators_gin; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_nft_metadata_creators_gin ON public.nft_metadata USING gin (creators);


--
-- Name: idx_nft_metadata_mint_address; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX idx_nft_metadata_mint_address ON public.nft_metadata USING btree (mint_address);


--
-- Name: idx_nft_metadata_needs_sync; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_nft_metadata_needs_sync ON public.nft_metadata USING btree (last_synced_at, sync_status) WHERE (((sync_status)::text = ANY (ARRAY[('PENDING'::character varying)::text, ('FAILED'::character varying)::text, ('OUTDATED'::character varying)::text])) OR (force_refresh = true));


--
-- Name: idx_nft_metadata_sync_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_nft_metadata_sync_status ON public.nft_metadata USING btree (sync_status);


--
-- Name: idx_nft_metadata_ticket_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_nft_metadata_ticket_id ON public.nft_metadata USING btree (ticket_id);


--
-- Name: idx_nft_metadata_tree_address; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_nft_metadata_tree_address ON public.nft_metadata USING btree (tree_address) WHERE (tree_address IS NOT NULL);


--
-- Name: idx_notification_queue_pending; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_notification_queue_pending ON public.notification_queue USING btree (status, created_at) WHERE ((status)::text = 'pending'::text);


--
-- Name: idx_notifications_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_notifications_user_id ON public.notifications USING btree (user_id);


--
-- Name: idx_notifications_user_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_notifications_user_status ON public.notifications USING btree (user_id, status);


--
-- Name: idx_offers_buyer_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_offers_buyer_id ON public.offers USING btree (buyer_id);


--
-- Name: idx_offers_expires_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_offers_expires_at ON public.offers USING btree (expires_at);


--
-- Name: idx_offers_listing_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_offers_listing_id ON public.offers USING btree (listing_id);


--
-- Name: idx_offers_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_offers_status ON public.offers USING btree (status);


--
-- Name: idx_order_items_order_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_order_items_order_id ON public.order_items USING btree (order_id);


--
-- Name: idx_order_items_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_order_items_status ON public.order_items USING btree (status) WHERE ((status)::text <> 'FULFILLED'::text);


--
-- Name: idx_order_items_ticket_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_order_items_ticket_id ON public.order_items USING btree (ticket_id);


--
-- Name: idx_order_items_ticket_type_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_order_items_ticket_type_id ON public.order_items USING btree (ticket_type_id);


--
-- Name: idx_order_transitions_created_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_order_transitions_created_at ON public.order_state_transitions USING btree (created_at DESC);


--
-- Name: idx_order_transitions_order_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_order_transitions_order_id ON public.order_state_transitions USING btree (order_id);


--
-- Name: idx_order_transitions_to_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_order_transitions_to_status ON public.order_state_transitions USING btree (to_status);


--
-- Name: idx_orders_order_number; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX idx_orders_order_number ON public.orders USING btree (order_number);


--
-- Name: idx_ownership_history_current; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ownership_history_current ON public.ticket_ownership_history USING btree (is_current_owner) WHERE (is_current_owner = true);


--
-- Name: idx_ownership_history_dates; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ownership_history_dates ON public.ticket_ownership_history USING btree (owned_from, owned_until);


--
-- Name: idx_ownership_history_ticket; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ownership_history_ticket ON public.ticket_ownership_history USING btree (ticket_id);


--
-- Name: idx_ownership_history_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ownership_history_user ON public.ticket_ownership_history USING btree (owner_user_id);


--
-- Name: idx_payment_methods_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_payment_methods_active ON public.payment_methods USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_payment_methods_is_default; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_payment_methods_is_default ON public.payment_methods USING btree (user_id, is_default) WHERE (is_default = true);


--
-- Name: idx_payment_methods_risk; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_payment_methods_risk ON public.payment_methods USING btree (risk_score) WHERE (risk_score > 50);


--
-- Name: idx_payment_methods_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_payment_methods_type ON public.payment_methods USING btree (type);


--
-- Name: idx_payment_methods_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_payment_methods_user_id ON public.payment_methods USING btree (user_id);


--
-- Name: idx_payout_accounts_venue; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_payout_accounts_venue ON public.venue_payout_accounts USING btree (venue_id, is_active) WHERE (is_active = true);


--
-- Name: idx_pci_timestamp; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_pci_timestamp ON public.pci_access_logs USING btree ("timestamp");


--
-- Name: idx_pci_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_pci_user ON public.pci_access_logs USING btree (user_id);


--
-- Name: idx_permissions_tenant_created; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_permissions_tenant_created ON public.permissions USING btree (tenant_id, created_at) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_permissions_tenant_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_permissions_tenant_id ON public.permissions USING btree (tenant_id);


--
-- Name: idx_price_history_event_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_price_history_event_id ON public.price_history USING btree (event_id);


--
-- Name: idx_price_history_recorded_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_price_history_recorded_at ON public.price_history USING btree (recorded_at);


--
-- Name: idx_price_history_ticket_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_price_history_ticket_id ON public.price_history USING btree (ticket_id);


--
-- Name: idx_pricing_history_pricing_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_pricing_history_pricing_id ON public.event_pricing_history USING btree (event_pricing_id);


--
-- Name: idx_pricing_history_tier_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_pricing_history_tier_id ON public.event_pricing_history USING btree (tier_id);


--
-- Name: idx_pricing_history_timestamp; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_pricing_history_timestamp ON public.event_pricing_history USING btree (created_at);


--
-- Name: idx_pricing_history_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_pricing_history_type ON public.event_pricing_history USING btree (change_type);


--
-- Name: idx_pricing_schedules_effective; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_pricing_schedules_effective ON public.event_pricing_schedules USING btree (effective_from);


--
-- Name: idx_pricing_schedules_pricing_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_pricing_schedules_pricing_id ON public.event_pricing_schedules USING btree (event_pricing_id);


--
-- Name: idx_pricing_tiers_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_pricing_tiers_active ON public.event_pricing_tiers USING btree (is_active);


--
-- Name: idx_pricing_tiers_pricing_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_pricing_tiers_pricing_id ON public.event_pricing_tiers USING btree (event_pricing_id);


--
-- Name: idx_pricing_tiers_priority; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_pricing_tiers_priority ON public.event_pricing_tiers USING btree (tier_priority);


--
-- Name: idx_promo_codes_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_promo_codes_active ON public.event_pricing_promo_codes USING btree (is_active);


--
-- Name: idx_promo_codes_code; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_promo_codes_code ON public.event_pricing_promo_codes USING btree (promo_code);


--
-- Name: idx_promo_codes_pricing_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_promo_codes_pricing_id ON public.event_pricing_promo_codes USING btree (event_pricing_id);


--
-- Name: idx_psp_recon_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_psp_recon_date ON public.psp_reconciliations USING btree (reconciliation_date);


--
-- Name: idx_psp_recon_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_psp_recon_status ON public.psp_reconciliations USING btree (status);


--
-- Name: idx_refund_policies_ticket_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_refund_policies_ticket_type ON public.ticket_type_refund_policies USING btree (ticket_type_id);


--
-- Name: idx_refunds_created_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_refunds_created_at ON public.refunds USING btree (created_at);


--
-- Name: idx_refunds_pending_review; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_refunds_pending_review ON public.refunds USING btree (requested_at) WHERE ((status)::text = 'pending_review'::text);


--
-- Name: idx_refunds_provider; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_refunds_provider ON public.refunds USING btree (provider_refund_id) WHERE (provider_refund_id IS NOT NULL);


--
-- Name: idx_refunds_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_refunds_status ON public.refunds USING btree (status);


--
-- Name: idx_refunds_transaction_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_refunds_transaction_id ON public.refunds USING btree (transaction_id);


--
-- Name: idx_refunds_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_refunds_user ON public.refunds USING btree (user_id);


--
-- Name: idx_refunds_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_refunds_user_id ON public.refunds USING btree (user_id);


--
-- Name: idx_resale_listings_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_resale_listings_active ON public.ticket_resale_listings USING btree (status, expires_at) WHERE ((status)::text = 'ACTIVE'::text);


--
-- Name: idx_resale_listings_price; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_resale_listings_price ON public.ticket_resale_listings USING btree (listing_price);


--
-- Name: idx_resale_listings_seller; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_resale_listings_seller ON public.ticket_resale_listings USING btree (seller_user_id);


--
-- Name: idx_resale_listings_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_resale_listings_status ON public.ticket_resale_listings USING btree (status);


--
-- Name: idx_resale_listings_ticket; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_resale_listings_ticket ON public.ticket_resale_listings USING btree (ticket_id);


--
-- Name: idx_resale_shipping; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_resale_shipping ON public.ticket_resale_listings USING gin (shipping_options);


--
-- Name: idx_reservations_event_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_reservations_event_id ON public.reservations USING btree (event_id);


--
-- Name: idx_reservations_expires_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_reservations_expires_at ON public.reservations USING btree (expires_at) WHERE ((status)::text = 'ACTIVE'::text);


--
-- Name: idx_reservations_order_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_reservations_order_id ON public.reservations USING btree (order_id);


--
-- Name: idx_reservations_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_reservations_status ON public.reservations USING btree (status) WHERE ((status)::text = 'ACTIVE'::text);


--
-- Name: idx_reservations_ticket_type_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_reservations_ticket_type_id ON public.reservations USING btree (ticket_type_id);


--
-- Name: idx_reservations_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_reservations_user_id ON public.reservations USING btree (user_id);


--
-- Name: idx_role_permissions_event_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_role_permissions_event_id ON public.role_permissions USING btree (event_id) WHERE (event_id IS NOT NULL);


--
-- Name: idx_role_permissions_permission_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_role_permissions_permission_id ON public.role_permissions USING btree (permission_id);


--
-- Name: idx_role_permissions_role_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_role_permissions_role_id ON public.role_permissions USING btree (role_id);


--
-- Name: idx_role_permissions_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_role_permissions_venue_id ON public.role_permissions USING btree (venue_id) WHERE (venue_id IS NOT NULL);


--
-- Name: idx_roles_created_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_roles_created_at ON public.roles USING btree (created_at) WHERE (deleted_at IS NULL);


--
-- Name: idx_roles_deleted_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_roles_deleted_at ON public.roles USING btree (deleted_at) WHERE (deleted_at IS NOT NULL);


--
-- Name: idx_roles_tenant_created; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_roles_tenant_created ON public.roles USING btree (tenant_id, created_at) WHERE (tenant_id IS NOT NULL);


--
-- Name: idx_roles_tenant_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_roles_tenant_id ON public.roles USING btree (tenant_id);


--
-- Name: idx_royalties_batch_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_royalties_batch_id ON public.royalties USING btree (batch_id) WHERE (batch_id IS NOT NULL);


--
-- Name: idx_royalties_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_royalties_status ON public.royalties USING btree (status);


--
-- Name: idx_royalties_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_royalties_venue_id ON public.royalties USING btree (venue_id);


--
-- Name: idx_schedule_activities_critical; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_schedule_activities_critical ON public.schedule_activities USING btree (is_critical) WHERE (is_critical = true);


--
-- Name: idx_schedule_activities_dependencies; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_schedule_activities_dependencies ON public.schedule_activities USING btree (depends_on_activity_id) WHERE (depends_on_activity_id IS NOT NULL);


--
-- Name: idx_schedule_activities_order; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_schedule_activities_order ON public.schedule_activities USING btree (schedule_id, activity_order);


--
-- Name: idx_schedule_activities_schedule_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_schedule_activities_schedule_id ON public.schedule_activities USING btree (schedule_id);


--
-- Name: idx_schedule_activities_start_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_schedule_activities_start_time ON public.schedule_activities USING btree (scheduled_start_time);


--
-- Name: idx_schedule_activities_timeframe; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_schedule_activities_timeframe ON public.schedule_activities USING btree (scheduled_start_time, scheduled_end_time);


--
-- Name: idx_schedule_activities_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_schedule_activities_type ON public.schedule_activities USING btree (activity_type);


--
-- Name: idx_schedule_conflicts_conflicting_schedule; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_schedule_conflicts_conflicting_schedule ON public.schedule_conflicts USING btree (conflicting_schedule_id);


--
-- Name: idx_schedule_conflicts_primary_schedule; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_schedule_conflicts_primary_schedule ON public.schedule_conflicts USING btree (primary_schedule_id);


--
-- Name: idx_schedule_conflicts_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_schedule_conflicts_status ON public.schedule_conflicts USING btree (conflict_status);


--
-- Name: idx_schedule_conflicts_timeframe; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_schedule_conflicts_timeframe ON public.schedule_conflicts USING btree (conflict_start, conflict_end);


--
-- Name: idx_schedule_conflicts_unresolved; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_schedule_conflicts_unresolved ON public.schedule_conflicts USING btree (conflict_status) WHERE ((conflict_status)::text = 'unresolved'::text);


--
-- Name: idx_schedule_exceptions_approval; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_schedule_exceptions_approval ON public.schedule_exceptions USING btree (requires_approval, approved_at);


--
-- Name: idx_schedule_exceptions_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_schedule_exceptions_date ON public.schedule_exceptions USING btree (exception_date);


--
-- Name: idx_schedule_exceptions_schedule_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_schedule_exceptions_schedule_id ON public.schedule_exceptions USING btree (schedule_id);


--
-- Name: idx_schedule_exceptions_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_schedule_exceptions_type ON public.schedule_exceptions USING btree (exception_type);


--
-- Name: idx_segment_definitions_criteria; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_segment_definitions_criteria ON public.segment_definitions USING gin (criteria);


--
-- Name: idx_segment_definitions_key; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_segment_definitions_key ON public.segment_definitions USING btree (segment_key) WHERE (is_active = true);


--
-- Name: idx_segment_definitions_metadata; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_segment_definitions_metadata ON public.segment_definitions USING gin (metadata);


--
-- Name: idx_segment_definitions_priority; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_segment_definitions_priority ON public.segment_definitions USING btree (priority) WHERE (is_active = true);


--
-- Name: idx_segment_definitions_system; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_segment_definitions_system ON public.segment_definitions USING btree (is_system) WHERE (is_system = true);


--
-- Name: idx_segment_definitions_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_segment_definitions_type ON public.segment_definitions USING btree (segment_type) WHERE (is_active = true);


--
-- Name: idx_session_activities_session_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_session_activities_session_id ON public.session_activities USING btree (session_id);


--
-- Name: idx_session_activities_suspicious; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_session_activities_suspicious ON public.session_activities USING btree (is_suspicious) WHERE (is_suspicious = true);


--
-- Name: idx_session_activities_timestamp; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_session_activities_timestamp ON public.session_activities USING btree ("timestamp");


--
-- Name: idx_session_activities_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_session_activities_type ON public.session_activities USING btree (activity_type);


--
-- Name: idx_sessions_created_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_sessions_created_at ON public.sessions USING btree (created_at);


--
-- Name: idx_sessions_expires_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_sessions_expires_at ON public.sessions USING btree (expires_at);


--
-- Name: idx_sessions_ip_address; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_sessions_ip_address ON public.sessions USING btree (ip_address);


--
-- Name: idx_sessions_tenant_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_sessions_tenant_id ON public.sessions USING btree (tenant_id);


--
-- Name: idx_sessions_token; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_sessions_token ON public.sessions USING btree (token);


--
-- Name: idx_sessions_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_sessions_user_id ON public.sessions USING btree (user_id);


--
-- Name: idx_settlement_pending_overdue; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_settlement_pending_overdue ON public.settlement_pending_view USING btree (is_overdue) WHERE (is_overdue = true);


--
-- Name: idx_settlement_pending_venue; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_settlement_pending_venue ON public.settlement_pending_view USING btree (venue_id);


--
-- Name: idx_settlement_reports_venue_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_settlement_reports_venue_date ON public.settlement_reports USING btree (venue_id, settlement_date);


--
-- Name: idx_settlements_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_settlements_date ON public.settlements USING btree (settlement_date);


--
-- Name: idx_settlements_discrepancies; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_settlements_discrepancies ON public.settlements USING btree (discrepancy_amount) WHERE (discrepancy_amount <> 0);


--
-- Name: idx_settlements_pending; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_settlements_pending ON public.settlements USING btree (status, created_at) WHERE ((status)::text = ANY (ARRAY[('pending'::character varying)::text, ('processing'::character varying)::text]));


--
-- Name: idx_settlements_provider; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_settlements_provider ON public.settlements USING btree (provider);


--
-- Name: idx_settlements_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_settlements_status ON public.settlements USING btree (status);


--
-- Name: idx_smart_contract_events_block_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_smart_contract_events_block_time ON public.smart_contract_events USING btree (block_time);


--
-- Name: idx_smart_contract_events_category; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_smart_contract_events_category ON public.smart_contract_events USING btree (category);


--
-- Name: idx_smart_contract_events_data_gin; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_smart_contract_events_data_gin ON public.smart_contract_events USING gin (event_data);


--
-- Name: idx_smart_contract_events_event_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_smart_contract_events_event_id ON public.smart_contract_events USING btree (event_id) WHERE (event_id IS NOT NULL);


--
-- Name: idx_smart_contract_events_event_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_smart_contract_events_event_type ON public.smart_contract_events USING btree (event_type);


--
-- Name: idx_smart_contract_events_indexed_gin; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_smart_contract_events_indexed_gin ON public.smart_contract_events USING gin (indexed_fields);


--
-- Name: idx_smart_contract_events_program_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_smart_contract_events_program_id ON public.smart_contract_events USING btree (program_id);


--
-- Name: idx_smart_contract_events_ticket_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_smart_contract_events_ticket_id ON public.smart_contract_events USING btree (ticket_id) WHERE (ticket_id IS NOT NULL);


--
-- Name: idx_smart_contract_events_transaction; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_smart_contract_events_transaction ON public.smart_contract_events USING btree (transaction_signature);


--
-- Name: idx_smart_contract_events_type_processed; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_smart_contract_events_type_processed ON public.smart_contract_events USING btree (event_type, processed);


--
-- Name: idx_smart_contract_events_unprocessed; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_smart_contract_events_unprocessed ON public.smart_contract_events USING btree (created_at, retry_count) WHERE (processed = false);


--
-- Name: idx_smart_contract_events_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_smart_contract_events_venue_id ON public.smart_contract_events USING btree (venue_id) WHERE (venue_id IS NOT NULL);


--
-- Name: idx_smart_contract_events_wallet; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_smart_contract_events_wallet ON public.smart_contract_events USING btree (wallet_address) WHERE (wallet_address IS NOT NULL);


--
-- Name: idx_staff_certs_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_staff_certs_active ON public.staff_certifications USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_staff_certs_expiry; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_staff_certs_expiry ON public.staff_certifications USING btree (expiry_date) WHERE (expiry_date IS NOT NULL);


--
-- Name: idx_staff_certs_staff_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_staff_certs_staff_id ON public.staff_certifications USING btree (venue_staff_id);


--
-- Name: idx_staff_certs_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_staff_certs_type ON public.staff_certifications USING btree (certification_type);


--
-- Name: idx_staff_schedules_actual_times; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_staff_schedules_actual_times ON public.staff_schedules USING btree (actual_start_time, actual_end_time) WHERE (actual_start_time IS NOT NULL);


--
-- Name: idx_staff_schedules_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_staff_schedules_date ON public.staff_schedules USING btree (schedule_date);


--
-- Name: idx_staff_schedules_event; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_staff_schedules_event ON public.staff_schedules USING btree (event_id) WHERE (event_id IS NOT NULL);


--
-- Name: idx_staff_schedules_staff_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_staff_schedules_staff_date ON public.staff_schedules USING btree (venue_staff_id, schedule_date);


--
-- Name: idx_staff_schedules_staff_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_staff_schedules_staff_id ON public.staff_schedules USING btree (venue_staff_id);


--
-- Name: idx_staff_schedules_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_staff_schedules_status ON public.staff_schedules USING btree (schedule_status);


--
-- Name: idx_staff_schedules_times; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_staff_schedules_times ON public.staff_schedules USING btree (start_time, end_time);


--
-- Name: idx_staff_schedules_venue_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_staff_schedules_venue_date ON public.staff_schedules USING btree (venue_id, schedule_date);


--
-- Name: idx_staff_schedules_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_staff_schedules_venue_id ON public.staff_schedules USING btree (venue_id);


--
-- Name: idx_staff_training_mandatory; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_staff_training_mandatory ON public.staff_training_records USING btree (is_mandatory) WHERE (is_mandatory = true);


--
-- Name: idx_staff_training_renewal; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_staff_training_renewal ON public.staff_training_records USING btree (next_renewal_date) WHERE (next_renewal_date IS NOT NULL);


--
-- Name: idx_staff_training_staff_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_staff_training_staff_id ON public.staff_training_records USING btree (venue_staff_id);


--
-- Name: idx_staff_training_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_staff_training_status ON public.staff_training_records USING btree (completion_status);


--
-- Name: idx_staff_training_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_staff_training_type ON public.staff_training_records USING btree (training_type);


--
-- Name: idx_subscriptions_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_subscriptions_active ON public.subscriptions USING btree (user_id, status) WHERE ((status)::text = 'active'::text);


--
-- Name: idx_subscriptions_cancel_pending; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_subscriptions_cancel_pending ON public.subscriptions USING btree (cancel_at_period_end) WHERE (cancel_at_period_end = true);


--
-- Name: idx_subscriptions_current_period; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_subscriptions_current_period ON public.subscriptions USING btree (current_period_end);


--
-- Name: idx_subscriptions_discount_expiring; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_subscriptions_discount_expiring ON public.subscriptions USING btree (discount_end_date) WHERE (discount_end_date IS NOT NULL);


--
-- Name: idx_subscriptions_payment_method; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_subscriptions_payment_method ON public.subscriptions USING btree (payment_method_id);


--
-- Name: idx_subscriptions_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_subscriptions_status ON public.subscriptions USING btree (status);


--
-- Name: idx_subscriptions_trial_ending; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_subscriptions_trial_ending ON public.subscriptions USING btree (trial_end) WHERE (((status)::text = 'trialing'::text) AND (trial_end IS NOT NULL));


--
-- Name: idx_subscriptions_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_subscriptions_user_id ON public.subscriptions USING btree (user_id);


--
-- Name: idx_surge_thresholds_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_surge_thresholds_active ON public.event_pricing_surge_thresholds USING btree (is_active);


--
-- Name: idx_surge_thresholds_pricing_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_surge_thresholds_pricing_id ON public.event_pricing_surge_thresholds USING btree (event_pricing_id);


--
-- Name: idx_suspicious_sessions_investigated; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_suspicious_sessions_investigated ON public.suspicious_sessions USING btree (investigated);


--
-- Name: idx_suspicious_sessions_session_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_suspicious_sessions_session_id ON public.suspicious_sessions USING btree (session_id);


--
-- Name: idx_suspicious_sessions_timestamp; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_suspicious_sessions_timestamp ON public.suspicious_sessions USING btree (detection_timestamp);


--
-- Name: idx_suspicious_sessions_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_suspicious_sessions_user_id ON public.suspicious_sessions USING btree (user_id);


--
-- Name: idx_ticket_analytics_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_analytics_date ON public.ticket_type_analytics USING btree (analytics_date);


--
-- Name: idx_ticket_analytics_type_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_analytics_type_id ON public.ticket_type_analytics USING btree (ticket_type_id);


--
-- Name: idx_ticket_benefits_category; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_benefits_category ON public.ticket_type_benefits USING btree (benefit_category);


--
-- Name: idx_ticket_benefits_highlighted; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_benefits_highlighted ON public.ticket_type_benefits USING btree (is_highlighted) WHERE (is_highlighted = true);


--
-- Name: idx_ticket_benefits_type_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_benefits_type_id ON public.ticket_type_benefits USING btree (ticket_type_id);


--
-- Name: idx_ticket_metadata_access_level; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_metadata_access_level ON public.ticket_metadata USING gin (((attributes -> 'Access Level'::text)));


--
-- Name: idx_ticket_metadata_attributes; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_metadata_attributes ON public.ticket_metadata USING gin (attributes);


--
-- Name: idx_ticket_metadata_event_name; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_metadata_event_name ON public.ticket_metadata USING gin (((attributes -> 'Event Name'::text)));


--
-- Name: idx_ticket_metadata_properties; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_metadata_properties ON public.ticket_metadata USING gin (properties);


--
-- Name: idx_ticket_metadata_search; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_metadata_search ON public.ticket_metadata USING gin (to_tsvector('english'::regconfig, (((COALESCE(name, ''::character varying))::text || ' '::text) || COALESCE(description, ''::text))));


--
-- Name: idx_ticket_metadata_ticket_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_metadata_ticket_id ON public.ticket_metadata USING btree (ticket_id);


--
-- Name: idx_ticket_metadata_venue; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_metadata_venue ON public.ticket_metadata USING gin (((attributes -> 'Venue'::text)));


--
-- Name: idx_ticket_redemptions_event_schedule; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_redemptions_event_schedule ON public.ticket_redemptions USING btree (event_schedule_id);


--
-- Name: idx_ticket_redemptions_redeemed_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_redemptions_redeemed_at ON public.ticket_redemptions USING btree (redeemed_at);


--
-- Name: idx_ticket_redemptions_ticket_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_redemptions_ticket_id ON public.ticket_redemptions USING btree (ticket_id);


--
-- Name: idx_ticket_refunds_amount; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_refunds_amount ON public.ticket_refunds USING btree (refund_amount, status);


--
-- Name: idx_ticket_refunds_requested_by; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_refunds_requested_by ON public.ticket_refunds USING btree (requested_by_user_id);


--
-- Name: idx_ticket_refunds_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_refunds_status ON public.ticket_refunds USING btree (status);


--
-- Name: idx_ticket_refunds_status_requested; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_refunds_status_requested ON public.ticket_refunds USING btree (requested_at DESC) WHERE ((status)::text = 'requested'::text);


--
-- Name: idx_ticket_refunds_ticket_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_refunds_ticket_id ON public.ticket_refunds USING btree (ticket_id);


--
-- Name: idx_ticket_restrictions_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_restrictions_active ON public.ticket_type_restrictions USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_ticket_restrictions_rule; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_restrictions_rule ON public.ticket_type_restrictions USING gin (restriction_rule);


--
-- Name: idx_ticket_restrictions_type_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_restrictions_type_id ON public.ticket_type_restrictions USING btree (ticket_type_id);


--
-- Name: idx_ticket_scans_ticket; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_scans_ticket ON public.ticket_scans USING btree (ticket_id);


--
-- Name: idx_ticket_transactions_created_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_transactions_created_at ON public.ticket_transactions USING btree (created_at);


--
-- Name: idx_ticket_transactions_pending; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_transactions_pending ON public.ticket_transactions USING btree (created_at) WHERE ((status)::text = 'pending'::text);


--
-- Name: idx_ticket_transactions_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_transactions_status ON public.ticket_transactions USING btree (status);


--
-- Name: idx_ticket_transactions_ticket_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_transactions_ticket_id ON public.ticket_transactions USING btree (ticket_id);


--
-- Name: idx_ticket_transactions_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_transactions_type ON public.ticket_transactions USING btree (transaction_type);


--
-- Name: idx_ticket_transfers_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_transfers_active ON public.ticket_transfers USING btree (created_at, expires_at) WHERE ((status)::text = ANY (ARRAY[('initiated'::character varying)::text, ('pending_approval'::character varying)::text]));


--
-- Name: idx_ticket_transfers_created_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_transfers_created_at ON public.ticket_transfers USING btree (created_at DESC);


--
-- Name: idx_ticket_transfers_expires; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_transfers_expires ON public.ticket_transfers USING btree (expires_at) WHERE ((expires_at IS NOT NULL) AND ((status)::text = ANY (ARRAY[('initiated'::character varying)::text, ('pending_approval'::character varying)::text])));


--
-- Name: idx_ticket_transfers_from_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_transfers_from_user ON public.ticket_transfers USING btree (from_user_id);


--
-- Name: idx_ticket_transfers_pending; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_transfers_pending ON public.ticket_transfers USING btree (status, expires_at) WHERE ((status)::text = 'PENDING'::text);


--
-- Name: idx_ticket_transfers_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_transfers_status ON public.ticket_transfers USING btree (status);


--
-- Name: idx_ticket_transfers_ticket_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_transfers_ticket_id ON public.ticket_transfers USING btree (ticket_id);


--
-- Name: idx_ticket_transfers_to_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_transfers_to_user ON public.ticket_transfers USING btree (to_user_id);


--
-- Name: idx_ticket_transfers_transaction; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_transfers_transaction ON public.ticket_transfers USING btree (transaction_id) WHERE (transaction_id IS NOT NULL);


--
-- Name: idx_ticket_transfers_user_history; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_transfers_user_history ON public.ticket_transfers USING btree (from_user_id, status, created_at DESC);


--
-- Name: idx_ticket_transfers_user_incoming; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_transfers_user_incoming ON public.ticket_transfers USING btree (to_user_id, status, created_at DESC);


--
-- Name: idx_ticket_types_availability; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_types_availability ON public.ticket_types USING btree (available_quantity) WHERE (available_quantity > 0);


--
-- Name: idx_ticket_types_event_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_types_event_id ON public.ticket_types USING btree (event_id);


--
-- Name: idx_ticket_validations_fraud; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_validations_fraud ON public.ticket_validations USING btree (fraud_flags) WHERE (array_length(fraud_flags, 1) > 0);


--
-- Name: idx_ticket_validations_location; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_validations_location ON public.ticket_validations USING btree (validation_location);


--
-- Name: idx_ticket_validations_result; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_validations_result ON public.ticket_validations USING btree (validation_result);


--
-- Name: idx_ticket_validations_ticket; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_validations_ticket ON public.ticket_validations USING btree (ticket_id);


--
-- Name: idx_ticket_validations_validated_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ticket_validations_validated_at ON public.ticket_validations USING btree (validated_at);


--
-- Name: idx_tickets_event_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_tickets_event_id ON public.tickets USING btree (event_id);


--
-- Name: idx_tickets_mint_address; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_tickets_mint_address ON public.tickets USING btree (mint_address) WHERE (mint_address IS NOT NULL);


--
-- Name: idx_tickets_original_purchaser; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_tickets_original_purchaser ON public.tickets USING btree (original_purchaser_id);


--
-- Name: idx_tickets_owner_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_tickets_owner_id ON public.tickets USING btree (owner_id);


--
-- Name: idx_tickets_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_tickets_status ON public.tickets USING btree (status);


--
-- Name: idx_tickets_ticket_type_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_tickets_ticket_type_id ON public.tickets USING btree (ticket_type_id);


--
-- Name: idx_tickets_transferable; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_tickets_transferable ON public.tickets USING btree (is_transferable, transfer_locked_until) WHERE (is_transferable = true);


--
-- Name: idx_tickets_type_status_available; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_tickets_type_status_available ON public.tickets USING btree (ticket_type_id, status) WHERE (status = ANY (ARRAY['AVAILABLE'::public.ticket_status, 'SOLD'::public.ticket_status]));


--
-- Name: idx_tos_email; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_tos_email ON public.tos_acceptances USING btree (user_email);


--
-- Name: idx_transactions_created_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_transactions_created_at ON public.transactions USING btree (created_at);


--
-- Name: idx_transactions_high_risk; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_transactions_high_risk ON public.transactions USING btree (risk_score, created_at) WHERE (risk_score > 70);


--
-- Name: idx_transactions_idempotency; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_transactions_idempotency ON public.transactions USING btree (idempotency_key);


--
-- Name: idx_transactions_payment_method; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_transactions_payment_method ON public.transactions USING btree (payment_method_id);


--
-- Name: idx_transactions_provider; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_transactions_provider ON public.transactions USING btree (provider);


--
-- Name: idx_transactions_provider_tx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_transactions_provider_tx ON public.transactions USING btree (provider_transaction_id) WHERE (provider_transaction_id IS NOT NULL);


--
-- Name: idx_transactions_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_transactions_status ON public.transactions USING btree (status);


--
-- Name: idx_transactions_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_transactions_type ON public.transactions USING btree (type);


--
-- Name: idx_transactions_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_transactions_user_id ON public.transactions USING btree (user_id);


--
-- Name: idx_transfer_policies_ticket_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_transfer_policies_ticket_type ON public.ticket_type_transfer_policies USING btree (ticket_type_id);


--
-- Name: idx_user_permissions_event_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_user_permissions_event_id ON public.user_permissions USING btree (event_id) WHERE ((event_id IS NOT NULL) AND (is_active = true));


--
-- Name: idx_user_permissions_expires_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_user_permissions_expires_at ON public.user_permissions USING btree (expires_at) WHERE ((expires_at IS NOT NULL) AND (is_active = true));


--
-- Name: idx_user_permissions_granted; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_user_permissions_granted ON public.user_permissions USING btree (is_granted) WHERE (is_active = true);


--
-- Name: idx_user_permissions_permission_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_user_permissions_permission_id ON public.user_permissions USING btree (permission_id) WHERE (is_active = true);


--
-- Name: idx_user_permissions_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_user_permissions_user_id ON public.user_permissions USING btree (user_id) WHERE (is_active = true);


--
-- Name: idx_user_permissions_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_user_permissions_venue_id ON public.user_permissions USING btree (venue_id) WHERE ((venue_id IS NOT NULL) AND (is_active = true));


--
-- Name: idx_user_roles_event_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_user_roles_event_id ON public.user_roles USING btree (event_id) WHERE ((event_id IS NOT NULL) AND (is_active = true));


--
-- Name: idx_user_roles_expires_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_user_roles_expires_at ON public.user_roles USING btree (expires_at) WHERE ((expires_at IS NOT NULL) AND (is_active = true));


--
-- Name: idx_user_roles_role_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_user_roles_role_id ON public.user_roles USING btree (role_id) WHERE (is_active = true);


--
-- Name: idx_user_roles_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_user_roles_user_id ON public.user_roles USING btree (user_id) WHERE (is_active = true);


--
-- Name: idx_user_roles_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_user_roles_venue_id ON public.user_roles USING btree (venue_id) WHERE ((venue_id IS NOT NULL) AND (is_active = true));


--
-- Name: idx_users_country_code; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_country_code ON public.users USING btree (country_code) WHERE (country_code IS NOT NULL);


--
-- Name: idx_users_created_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_created_at ON public.users USING btree (created_at) WHERE (deleted_at IS NULL);


--
-- Name: idx_users_deleted_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_deleted_at ON public.users USING btree (deleted_at) WHERE (deleted_at IS NULL);


--
-- Name: idx_users_display_name; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_display_name ON public.users USING btree (display_name) WHERE (display_name IS NOT NULL);


--
-- Name: idx_users_email; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_email ON public.users USING btree (email);


--
-- Name: idx_users_email_verification_token; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_email_verification_token ON public.users USING btree (email_verification_token) WHERE (email_verification_token IS NOT NULL);


--
-- Name: idx_users_email_verified; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_email_verified ON public.users USING btree (email_verified) WHERE (deleted_at IS NULL);


--
-- Name: idx_users_last_login_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_last_login_at ON public.users USING btree (last_login_at) WHERE (deleted_at IS NULL);


--
-- Name: idx_users_metadata_gin; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_metadata_gin ON public.users USING gin (metadata);


--
-- Name: idx_users_password_reset_token; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_password_reset_token ON public.users USING btree (password_reset_token) WHERE (password_reset_token IS NOT NULL);


--
-- Name: idx_users_permissions_gin; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_permissions_gin ON public.users USING gin (permissions);


--
-- Name: idx_users_phone; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_phone ON public.users USING btree (phone) WHERE (phone IS NOT NULL);


--
-- Name: idx_users_preferences_gin; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_preferences_gin ON public.users USING gin (preferences);


--
-- Name: idx_users_referral_code; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_referral_code ON public.users USING btree (referral_code) WHERE (referral_code IS NOT NULL);


--
-- Name: idx_users_referred_by; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_referred_by ON public.users USING btree (referred_by) WHERE (referred_by IS NOT NULL);


--
-- Name: idx_users_role; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_role ON public.users USING btree (role);


--
-- Name: idx_users_role_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_role_status ON public.users USING btree (role, status) WHERE (deleted_at IS NULL);


--
-- Name: idx_users_search; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_search ON public.users USING gin (to_tsvector('english'::regconfig, (((((((((COALESCE(username, ''::character varying))::text || ' '::text) || (COALESCE(display_name, ''::character varying))::text) || ' '::text) || (COALESCE(first_name, ''::character varying))::text) || ' '::text) || (COALESCE(last_name, ''::character varying))::text) || ' '::text) || (COALESCE(email, ''::character varying))::text)));


--
-- Name: idx_users_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_status ON public.users USING btree (status);


--
-- Name: idx_users_status_created_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_status_created_at ON public.users USING btree (status, created_at);


--
-- Name: idx_users_timezone; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_timezone ON public.users USING btree (timezone);


--
-- Name: idx_users_two_factor_enabled; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_two_factor_enabled ON public.users USING btree (two_factor_enabled) WHERE (deleted_at IS NULL);


--
-- Name: idx_users_username; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_username ON public.users USING btree (username) WHERE (username IS NOT NULL);


--
-- Name: idx_validation_data; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_validation_data ON public.ticket_validations USING gin (validation_data);


--
-- Name: idx_validations_ticket_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_validations_ticket_date ON public.ticket_validations USING btree (ticket_id, validated_at DESC);


--
-- Name: idx_venue_balances_venue; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_balances_venue ON public.venue_balances USING btree (venue_id);


--
-- Name: idx_venue_blackout_dates; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_blackout_dates ON public.venue_blackout_dates USING btree (start_date, end_date);


--
-- Name: idx_venue_blackout_recurring; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_blackout_recurring ON public.venue_blackout_dates USING btree (is_recurring) WHERE (is_recurring = true);


--
-- Name: idx_venue_blackout_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_blackout_type ON public.venue_blackout_dates USING btree (blackout_type);


--
-- Name: idx_venue_blackout_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_blackout_venue_id ON public.venue_blackout_dates USING btree (venue_id);


--
-- Name: idx_venue_categories_category; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_categories_category ON public.venue_custom_categories USING btree (category_id);


--
-- Name: idx_venue_categories_enabled; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_categories_enabled ON public.venue_custom_categories USING btree (is_enabled);


--
-- Name: idx_venue_categories_venue; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_categories_venue ON public.venue_custom_categories USING btree (venue_id);


--
-- Name: idx_venue_hours_day; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_hours_day ON public.venue_operating_hours USING btree (day_of_week);


--
-- Name: idx_venue_hours_effective; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_hours_effective ON public.venue_operating_hours USING btree (effective_from, effective_until);


--
-- Name: idx_venue_hours_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_hours_venue_id ON public.venue_operating_hours USING btree (venue_id);


--
-- Name: idx_venue_integrations_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_integrations_active ON public.venue_integrations USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_venue_integrations_last_sync; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_integrations_last_sync ON public.venue_integrations USING btree (last_sync_at) WHERE (last_sync_at IS NOT NULL);


--
-- Name: idx_venue_integrations_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_integrations_type ON public.venue_integrations USING btree (integration_type);


--
-- Name: idx_venue_integrations_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_integrations_venue_id ON public.venue_integrations USING btree (venue_id);


--
-- Name: idx_venue_layouts_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_layouts_active ON public.venue_layouts USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_venue_layouts_default; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_layouts_default ON public.venue_layouts USING btree (venue_id) WHERE (is_default = true);


--
-- Name: idx_venue_layouts_one_default; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX idx_venue_layouts_one_default ON public.venue_layouts USING btree (venue_id) WHERE (is_default = true);


--
-- Name: idx_venue_layouts_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_layouts_venue_id ON public.venue_layouts USING btree (venue_id);


--
-- Name: idx_venue_notifications_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_notifications_active ON public.venue_notification_templates USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_venue_notifications_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_notifications_type ON public.venue_notification_templates USING btree (template_type);


--
-- Name: idx_venue_notifications_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_notifications_venue_id ON public.venue_notification_templates USING btree (venue_id);


--
-- Name: idx_venue_policies_effective; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_policies_effective ON public.venue_policies USING btree (effective_from, effective_until);


--
-- Name: idx_venue_policies_rules; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_policies_rules ON public.venue_policies USING gin (policy_rules) WHERE (policy_rules IS NOT NULL);


--
-- Name: idx_venue_policies_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_policies_type ON public.venue_policies USING btree (policy_type);


--
-- Name: idx_venue_policies_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_policies_venue_id ON public.venue_policies USING btree (venue_id);


--
-- Name: idx_venue_pricing_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_pricing_active ON public.venue_pricing_rules USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_venue_pricing_conditions; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_pricing_conditions ON public.venue_pricing_rules USING gin (conditions);


--
-- Name: idx_venue_pricing_effective; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_pricing_effective ON public.venue_pricing_rules USING btree (effective_from, effective_until);


--
-- Name: idx_venue_pricing_priority; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_pricing_priority ON public.venue_pricing_rules USING btree (priority DESC);


--
-- Name: idx_venue_pricing_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_pricing_type ON public.venue_pricing_rules USING btree (rule_type);


--
-- Name: idx_venue_pricing_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_pricing_venue_id ON public.venue_pricing_rules USING btree (venue_id);


--
-- Name: idx_venue_settings_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_settings_venue_id ON public.venue_settings USING btree (venue_id);


--
-- Name: idx_venue_staff_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_staff_active ON public.venue_staff USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_venue_staff_role; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_staff_role ON public.venue_staff USING btree (role);


--
-- Name: idx_venue_staff_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_staff_user_id ON public.venue_staff USING btree (user_id);


--
-- Name: idx_venue_staff_venue_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venue_staff_venue_id ON public.venue_staff USING btree (venue_id);


--
-- Name: idx_venues_created_by; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_venues_created_by ON public.venues USING btree (created_by);


--
-- Name: idx_wallet_addresses_address; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_wallet_addresses_address ON public.wallet_addresses USING btree (wallet_address);


--
-- Name: idx_wallet_addresses_blockchain; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_wallet_addresses_blockchain ON public.wallet_addresses USING btree (blockchain);


--
-- Name: idx_wallet_addresses_blocked; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_wallet_addresses_blocked ON public.wallet_addresses USING btree (is_blocked) WHERE (is_blocked = true);


--
-- Name: idx_wallet_addresses_last_used; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_wallet_addresses_last_used ON public.wallet_addresses USING btree (last_used_at);


--
-- Name: idx_wallet_addresses_one_primary; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX idx_wallet_addresses_one_primary ON public.wallet_addresses USING btree (user_id, blockchain) WHERE (is_primary = true);


--
-- Name: idx_wallet_addresses_primary; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_wallet_addresses_primary ON public.wallet_addresses USING btree (user_id, is_primary) WHERE (is_primary = true);


--
-- Name: idx_wallet_addresses_risk; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_wallet_addresses_risk ON public.wallet_addresses USING btree (risk_score) WHERE (risk_score > 50);


--
-- Name: idx_wallet_addresses_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_wallet_addresses_user_id ON public.wallet_addresses USING btree (user_id);


--
-- Name: idx_wallet_addresses_verified; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_wallet_addresses_verified ON public.wallet_addresses USING btree (is_verified) WHERE (is_verified = true);


--
-- Name: idx_webhook_events_provider_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_webhook_events_provider_type ON public.webhook_events USING btree (provider, event_type);


--
-- Name: unique_reporting_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX unique_reporting_idx ON public.tax_reporting_requirements USING btree (COALESCE(customer_id, ''::character varying), COALESCE(venue_id, ''::character varying), year, form_type);


--
-- Name: uq_tickets_ticket_code_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX uq_tickets_ticket_code_idx ON public.tickets USING btree (ticket_code) WHERE (ticket_code IS NOT NULL);


--
-- Name: aml_checks calculate_aml_risk_score_trigger; Type: TRIGGER; Schema: compliance; Owner: postgres
--

CREATE TRIGGER calculate_aml_risk_score_trigger BEFORE INSERT OR UPDATE ON compliance.aml_checks FOR EACH ROW EXECUTE FUNCTION compliance.calculate_aml_risk_score();


--
-- Name: sanctions_screening calculate_next_check_date_trigger; Type: TRIGGER; Schema: compliance; Owner: postgres
--

CREATE TRIGGER calculate_next_check_date_trigger BEFORE INSERT OR UPDATE ON compliance.sanctions_screening FOR EACH ROW EXECUTE FUNCTION compliance.calculate_next_check_date();


--
-- Name: data_retention calculate_next_purge_date_trigger; Type: TRIGGER; Schema: compliance; Owner: postgres
--

CREATE TRIGGER calculate_next_purge_date_trigger BEFORE INSERT OR UPDATE ON compliance.data_retention FOR EACH ROW EXECUTE FUNCTION compliance.calculate_next_purge_date();


--
-- Name: kyc_records check_kyc_expiry_trigger; Type: TRIGGER; Schema: compliance; Owner: postgres
--

CREATE TRIGGER check_kyc_expiry_trigger BEFORE INSERT OR UPDATE ON compliance.kyc_records FOR EACH ROW EXECUTE FUNCTION compliance.check_kyc_expiry();


--
-- Name: compliance_reports prevent_submitted_report_changes_trigger; Type: TRIGGER; Schema: compliance; Owner: postgres
--

CREATE TRIGGER prevent_submitted_report_changes_trigger BEFORE UPDATE ON compliance.compliance_reports FOR EACH ROW EXECUTE FUNCTION compliance.prevent_submitted_report_changes();


--
-- Name: aml_checks update_aml_checks_updated_at; Type: TRIGGER; Schema: compliance; Owner: postgres
--

CREATE TRIGGER update_aml_checks_updated_at BEFORE UPDATE ON compliance.aml_checks FOR EACH ROW EXECUTE FUNCTION compliance.update_aml_checks_updated_at();


--
-- Name: compliance_reports update_compliance_reports_updated_at; Type: TRIGGER; Schema: compliance; Owner: postgres
--

CREATE TRIGGER update_compliance_reports_updated_at BEFORE UPDATE ON compliance.compliance_reports FOR EACH ROW EXECUTE FUNCTION compliance.update_compliance_reports_updated_at();


--
-- Name: data_retention update_data_retention_updated_at; Type: TRIGGER; Schema: compliance; Owner: postgres
--

CREATE TRIGGER update_data_retention_updated_at BEFORE UPDATE ON compliance.data_retention FOR EACH ROW EXECUTE FUNCTION compliance.update_data_retention_updated_at();


--
-- Name: kyc_records update_kyc_records_updated_at; Type: TRIGGER; Schema: compliance; Owner: postgres
--

CREATE TRIGGER update_kyc_records_updated_at BEFORE UPDATE ON compliance.kyc_records FOR EACH ROW EXECUTE FUNCTION compliance.update_kyc_records_updated_at();


--
-- Name: sanctions_screening update_sanctions_screening_updated_at; Type: TRIGGER; Schema: compliance; Owner: postgres
--

CREATE TRIGGER update_sanctions_screening_updated_at BEFORE UPDATE ON compliance.sanctions_screening FOR EACH ROW EXECUTE FUNCTION compliance.update_sanctions_screening_updated_at();


--
-- Name: sync_logs calculate_sync_duration_trigger; Type: TRIGGER; Schema: integrations; Owner: postgres
--

CREATE TRIGGER calculate_sync_duration_trigger BEFORE INSERT OR UPDATE ON integrations.sync_logs FOR EACH ROW EXECUTE FUNCTION integrations.calculate_sync_duration();


--
-- Name: external_references check_needs_sync_trigger; Type: TRIGGER; Schema: integrations; Owner: postgres
--

CREATE TRIGGER check_needs_sync_trigger BEFORE UPDATE ON integrations.external_references FOR EACH ROW EXECUTE FUNCTION integrations.check_needs_sync();


--
-- Name: api_credentials update_api_credentials_updated_at; Type: TRIGGER; Schema: integrations; Owner: postgres
--

CREATE TRIGGER update_api_credentials_updated_at BEFORE UPDATE ON integrations.api_credentials FOR EACH ROW EXECUTE FUNCTION integrations.update_api_credentials_updated_at();


--
-- Name: external_references update_external_references_updated_at; Type: TRIGGER; Schema: integrations; Owner: postgres
--

CREATE TRIGGER update_external_references_updated_at BEFORE UPDATE ON integrations.external_references FOR EACH ROW EXECUTE FUNCTION integrations.update_external_references_updated_at();


--
-- Name: integration_mappings update_integration_mappings_updated_at; Type: TRIGGER; Schema: integrations; Owner: postgres
--

CREATE TRIGGER update_integration_mappings_updated_at BEFORE UPDATE ON integrations.integration_mappings FOR EACH ROW EXECUTE FUNCTION integrations.update_integration_mappings_updated_at();


--
-- Name: sync_logs update_sync_logs_updated_at; Type: TRIGGER; Schema: integrations; Owner: postgres
--

CREATE TRIGGER update_sync_logs_updated_at BEFORE UPDATE ON integrations.sync_logs FOR EACH ROW EXECUTE FUNCTION integrations.update_sync_logs_updated_at();


--
-- Name: webhook_endpoints update_webhook_endpoints_updated_at; Type: TRIGGER; Schema: integrations; Owner: postgres
--

CREATE TRIGGER update_webhook_endpoints_updated_at BEFORE UPDATE ON integrations.webhook_endpoints FOR EACH ROW EXECUTE FUNCTION integrations.update_webhook_endpoints_updated_at();


--
-- Name: webhook_endpoints webhook_circuit_breaker_trigger; Type: TRIGGER; Schema: integrations; Owner: postgres
--

CREATE TRIGGER webhook_circuit_breaker_trigger BEFORE UPDATE ON integrations.webhook_endpoints FOR EACH ROW EXECUTE FUNCTION integrations.webhook_circuit_breaker();


--
-- Name: notification_preferences set_unsubscribe_token_on_insert; Type: TRIGGER; Schema: notifications; Owner: postgres
--

CREATE TRIGGER set_unsubscribe_token_on_insert BEFORE INSERT ON notifications.notification_preferences FOR EACH ROW EXECUTE FUNCTION notifications.set_unsubscribe_token();


--
-- Name: campaigns update_campaign_audience_count; Type: TRIGGER; Schema: notifications; Owner: postgres
--

CREATE TRIGGER update_campaign_audience_count BEFORE INSERT OR UPDATE ON notifications.campaigns FOR EACH ROW EXECUTE FUNCTION notifications.update_campaign_audience_count();


--
-- Name: campaigns update_campaigns_updated_at; Type: TRIGGER; Schema: notifications; Owner: postgres
--

CREATE TRIGGER update_campaigns_updated_at BEFORE UPDATE ON notifications.campaigns FOR EACH ROW EXECUTE FUNCTION notifications.update_campaigns_updated_at();


--
-- Name: delivery_tracking update_delivery_tracking_updated_at; Type: TRIGGER; Schema: notifications; Owner: postgres
--

CREATE TRIGGER update_delivery_tracking_updated_at BEFORE UPDATE ON notifications.delivery_tracking FOR EACH ROW EXECUTE FUNCTION notifications.update_delivery_tracking_updated_at();


--
-- Name: notification_history update_notification_history_updated_at; Type: TRIGGER; Schema: notifications; Owner: postgres
--

CREATE TRIGGER update_notification_history_updated_at BEFORE UPDATE ON notifications.notification_history FOR EACH ROW EXECUTE FUNCTION notifications.update_updated_at_column();


--
-- Name: notification_preferences update_notification_preferences_updated_at; Type: TRIGGER; Schema: notifications; Owner: postgres
--

CREATE TRIGGER update_notification_preferences_updated_at BEFORE UPDATE ON notifications.notification_preferences FOR EACH ROW EXECUTE FUNCTION notifications.update_notification_preferences_updated_at();


--
-- Name: invoices calculate_invoice_totals_trigger; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER calculate_invoice_totals_trigger BEFORE INSERT OR UPDATE OF line_items ON public.invoices FOR EACH ROW EXECUTE FUNCTION public.calculate_invoice_totals();


--
-- Name: financial_reports calculate_report_metrics_trigger; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER calculate_report_metrics_trigger BEFORE INSERT OR UPDATE ON public.financial_reports FOR EACH ROW EXECUTE FUNCTION public.calculate_report_metrics();


--
-- Name: ticket_refunds check_auto_approval_before_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER check_auto_approval_before_insert BEFORE INSERT ON public.ticket_refunds FOR EACH ROW EXECUTE FUNCTION public.check_auto_approval();


--
-- Name: refunds check_refund_auto_approval_trigger; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER check_refund_auto_approval_trigger BEFORE INSERT OR UPDATE OF status ON public.refunds FOR EACH ROW EXECUTE FUNCTION public.check_refund_auto_approval();


--
-- Name: customer_profiles create_preferences_for_new_customer; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER create_preferences_for_new_customer AFTER INSERT ON public.customer_profiles FOR EACH ROW EXECUTE FUNCTION public.create_default_preferences();


--
-- Name: invoices generate_invoice_number_before_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER generate_invoice_number_before_insert BEFORE INSERT ON public.invoices FOR EACH ROW WHEN ((new.invoice_number IS NULL)) EXECUTE FUNCTION public.generate_invoice_number();


--
-- Name: settlements generate_settlement_number_before_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER generate_settlement_number_before_insert BEFORE INSERT ON public.settlements FOR EACH ROW EXECUTE FUNCTION public.generate_settlement_number();


--
-- Name: transactions generate_transaction_reference_before_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER generate_transaction_reference_before_insert BEFORE INSERT ON public.transactions FOR EACH ROW EXECUTE FUNCTION public.generate_transaction_reference();


--
-- Name: payment_methods manage_default_payment_method_trigger; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER manage_default_payment_method_trigger BEFORE INSERT OR UPDATE ON public.payment_methods FOR EACH ROW EXECUTE FUNCTION public.manage_default_payment_method();


--
-- Name: invoices manage_invoice_status_trigger; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER manage_invoice_status_trigger BEFORE INSERT OR UPDATE ON public.invoices FOR EACH ROW EXECUTE FUNCTION public.manage_invoice_status();


--
-- Name: financial_reports manage_report_generation_trigger; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER manage_report_generation_trigger BEFORE INSERT OR UPDATE ON public.financial_reports FOR EACH ROW EXECUTE FUNCTION public.manage_report_generation();


--
-- Name: subscriptions manage_subscription_lifecycle_trigger; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER manage_subscription_lifecycle_trigger BEFORE INSERT OR UPDATE ON public.subscriptions FOR EACH ROW EXECUTE FUNCTION public.manage_subscription_lifecycle();


--
-- Name: refunds process_refund_workflow_trigger; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER process_refund_workflow_trigger BEFORE INSERT OR UPDATE ON public.refunds FOR EACH ROW EXECUTE FUNCTION public.process_refund_workflow();


--
-- Name: events trg_audit_events; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_audit_events AFTER INSERT OR DELETE OR UPDATE ON public.events FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_simple();


--
-- Name: listings trg_audit_listings; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_audit_listings AFTER INSERT OR DELETE OR UPDATE ON public.listings FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_simple();


--
-- Name: tickets trg_audit_tickets; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_audit_tickets AFTER INSERT OR DELETE OR UPDATE ON public.tickets FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_simple();


--
-- Name: transactions trg_audit_transactions; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_audit_transactions AFTER INSERT OR DELETE OR UPDATE ON public.transactions FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_simple();


--
-- Name: users trg_audit_users; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_audit_users AFTER INSERT OR DELETE OR UPDATE ON public.users FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_simple();


--
-- Name: transactions trg_calculate_fees; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_calculate_fees BEFORE INSERT OR UPDATE OF amount ON public.transactions FOR EACH ROW EXECUTE FUNCTION public.calculate_transaction_fees();


--
-- Name: event_capacity_by_tier trg_capacity_by_tier_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_capacity_by_tier_updated BEFORE UPDATE ON public.event_capacity_by_tier FOR EACH ROW EXECUTE FUNCTION public.update_capacity_timestamp();


--
-- Name: event_capacity_by_type trg_capacity_by_type_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_capacity_by_type_updated BEFORE UPDATE ON public.event_capacity_by_type FOR EACH ROW EXECUTE FUNCTION public.update_capacity_timestamp();


--
-- Name: tickets trg_check_ticket_availability; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_check_ticket_availability BEFORE INSERT ON public.tickets FOR EACH ROW EXECUTE FUNCTION public.check_ticket_availability();


--
-- Name: event_pricing_dynamic_rules trg_dynamic_rules_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_dynamic_rules_updated BEFORE UPDATE ON public.event_pricing_dynamic_rules FOR EACH ROW EXECUTE FUNCTION public.update_pricing_timestamp();


--
-- Name: event_analytics_tracking trg_event_analytics_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_event_analytics_updated BEFORE UPDATE ON public.event_analytics_tracking FOR EACH ROW EXECUTE FUNCTION public.update_metadata_timestamp();


--
-- Name: event_capacity trg_event_capacity_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_event_capacity_updated BEFORE UPDATE ON public.event_capacity FOR EACH ROW EXECUTE FUNCTION public.update_capacity_timestamp();


--
-- Name: event_categories trg_event_categories_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_event_categories_updated BEFORE UPDATE ON public.event_categories FOR EACH ROW EXECUTE FUNCTION public.update_category_timestamp();


--
-- Name: event_category_mappings trg_event_category_mapping_tag_usage; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_event_category_mapping_tag_usage AFTER INSERT OR DELETE ON public.event_category_mappings FOR EACH ROW EXECUTE FUNCTION public.update_tag_usage();


--
-- Name: event_custom_attributes trg_event_custom_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_event_custom_updated BEFORE UPDATE ON public.event_custom_attributes FOR EACH ROW EXECUTE FUNCTION public.update_metadata_timestamp();


--
-- Name: event_marketing_campaigns trg_event_marketing_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_event_marketing_updated BEFORE UPDATE ON public.event_marketing_campaigns FOR EACH ROW EXECUTE FUNCTION public.update_metadata_timestamp();


--
-- Name: event_metadata trg_event_metadata_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_event_metadata_updated BEFORE UPDATE ON public.event_metadata FOR EACH ROW EXECUTE FUNCTION public.update_metadata_timestamp();


--
-- Name: event_pricing trg_event_pricing_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_event_pricing_updated BEFORE UPDATE ON public.event_pricing FOR EACH ROW EXECUTE FUNCTION public.update_pricing_timestamp();


--
-- Name: event_seo_metadata trg_event_seo_last_modified; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_event_seo_last_modified BEFORE UPDATE ON public.event_seo_metadata FOR EACH ROW EXECUTE FUNCTION public.update_seo_last_modified();


--
-- Name: event_seo_metadata trg_event_seo_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_event_seo_updated BEFORE UPDATE ON public.event_seo_metadata FOR EACH ROW EXECUTE FUNCTION public.update_metadata_timestamp();


--
-- Name: event_social_media trg_event_social_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_event_social_updated BEFORE UPDATE ON public.event_social_media FOR EACH ROW EXECUTE FUNCTION public.update_metadata_timestamp();


--
-- Name: event_metadata_templates trg_metadata_templates_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_metadata_templates_updated BEFORE UPDATE ON public.event_metadata_templates FOR EACH ROW EXECUTE FUNCTION public.update_metadata_timestamp();


--
-- Name: listings trg_notify_listing; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_notify_listing AFTER INSERT ON public.listings FOR EACH ROW EXECUTE FUNCTION public.generate_ticket_notification();


--
-- Name: offers trg_prevent_self_purchase; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_prevent_self_purchase BEFORE INSERT ON public.offers FOR EACH ROW EXECUTE FUNCTION public.prevent_self_purchase();


--
-- Name: event_pricing_tiers trg_pricing_tier_change_log; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_pricing_tier_change_log AFTER UPDATE ON public.event_pricing_tiers FOR EACH ROW EXECUTE FUNCTION public.log_pricing_changes();


--
-- Name: event_pricing_tiers trg_pricing_tiers_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_pricing_tiers_updated BEFORE UPDATE ON public.event_pricing_tiers FOR EACH ROW EXECUTE FUNCTION public.update_pricing_timestamp();


--
-- Name: ticket_type_refund_policies trg_refund_policies_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_refund_policies_updated BEFORE UPDATE ON public.ticket_type_refund_policies FOR EACH ROW EXECUTE FUNCTION public.update_ticket_type_timestamp();


--
-- Name: ticket_resale_listings trg_resale_listings_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_resale_listings_updated BEFORE UPDATE ON public.ticket_resale_listings FOR EACH ROW EXECUTE FUNCTION public.update_ticket_timestamp();


--
-- Name: tickets trg_ticket_identifiers; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_ticket_identifiers BEFORE INSERT ON public.tickets FOR EACH ROW EXECUTE FUNCTION public.generate_ticket_identifiers();


--
-- Name: tickets trg_ticket_initial_ownership; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_ticket_initial_ownership AFTER INSERT ON public.tickets FOR EACH ROW EXECUTE FUNCTION public.create_initial_ownership();


--
-- Name: ticket_types trg_ticket_type_slug_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_ticket_type_slug_insert BEFORE INSERT ON public.ticket_types FOR EACH ROW EXECUTE FUNCTION public.set_ticket_type_slug();


--
-- Name: ticket_types trg_ticket_type_slug_update; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_ticket_type_slug_update BEFORE UPDATE ON public.ticket_types FOR EACH ROW EXECUTE FUNCTION public.update_ticket_type_slug();


--
-- Name: ticket_types trg_ticket_types_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_ticket_types_updated BEFORE UPDATE ON public.ticket_types FOR EACH ROW EXECUTE FUNCTION public.update_ticket_type_timestamp();


--
-- Name: tickets trg_tickets_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_tickets_updated BEFORE UPDATE ON public.tickets FOR EACH ROW EXECUTE FUNCTION public.update_ticket_timestamp();


--
-- Name: listings trg_track_price_history; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_track_price_history AFTER INSERT OR UPDATE OF price ON public.listings FOR EACH ROW EXECUTE FUNCTION public.track_listing_price_history();


--
-- Name: ticket_type_transfer_policies trg_transfer_policies_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_transfer_policies_updated BEFORE UPDATE ON public.ticket_type_transfer_policies FOR EACH ROW EXECUTE FUNCTION public.update_ticket_type_timestamp();


--
-- Name: tickets trg_update_event_stats; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_update_event_stats AFTER INSERT OR DELETE OR UPDATE ON public.tickets FOR EACH ROW EXECUTE FUNCTION public.update_event_ticket_stats();


--
-- Name: transactions trg_update_user_stats; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_update_user_stats AFTER INSERT OR UPDATE ON public.transactions FOR EACH ROW WHEN (((new.type)::text = 'purchase'::text)) EXECUTE FUNCTION public.update_user_purchase_stats();


--
-- Name: events trg_update_venue_stats; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_update_venue_stats AFTER INSERT OR DELETE ON public.events FOR EACH ROW EXECUTE FUNCTION public.update_venue_event_count();


--
-- Name: listings trg_validate_ticket_ownership; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_validate_ticket_ownership BEFORE INSERT ON public.listings FOR EACH ROW EXECUTE FUNCTION public.validate_ticket_ownership();


--
-- Name: tickets trg_validate_ticket_status; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_validate_ticket_status BEFORE UPDATE OF status ON public.tickets FOR EACH ROW WHEN ((old.status IS DISTINCT FROM new.status)) EXECUTE FUNCTION public.validate_ticket_status_transition();


--
-- Name: venue_custom_categories trg_venue_categories_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_venue_categories_updated BEFORE UPDATE ON public.venue_custom_categories FOR EACH ROW EXECUTE FUNCTION public.update_category_timestamp();


--
-- Name: schedule_activities trigger_activity_timing_update; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_activity_timing_update BEFORE INSERT OR UPDATE ON public.schedule_activities FOR EACH ROW EXECUTE FUNCTION public.update_activity_timing();


--
-- Name: audit_logs trigger_audit_record_processing; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_audit_record_processing BEFORE INSERT OR UPDATE ON public.audit_logs FOR EACH ROW EXECUTE FUNCTION public.process_audit_record();


--
-- Name: audit_logs trigger_audit_tampering_detection; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_audit_tampering_detection BEFORE UPDATE ON public.audit_logs FOR EACH ROW EXECUTE FUNCTION public.detect_audit_tampering();


--
-- Name: marketplace_transactions trigger_calculate_royalties; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_calculate_royalties AFTER UPDATE ON public.marketplace_transactions FOR EACH ROW EXECUTE FUNCTION public.calculate_royalties();


--
-- Name: staff_certifications trigger_certification_expiry_check; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_certification_expiry_check BEFORE INSERT OR UPDATE ON public.staff_certifications FOR EACH ROW EXECUTE FUNCTION public.check_certification_expiry();


--
-- Name: marketplace_transactions trigger_create_escrow; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_create_escrow AFTER INSERT ON public.marketplace_transactions FOR EACH ROW EXECUTE FUNCTION public.create_escrow_hold();


--
-- Name: events trigger_create_event_metadata; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_create_event_metadata AFTER INSERT ON public.events FOR EACH ROW EXECUTE FUNCTION public.create_event_metadata();


--
-- Name: tickets trigger_create_ticket_metadata; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_create_ticket_metadata AFTER INSERT ON public.tickets FOR EACH ROW EXECUTE FUNCTION public.create_ticket_metadata();


--
-- Name: venues trigger_create_venue_settings; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_create_venue_settings AFTER INSERT ON public.venues FOR EACH ROW EXECUTE FUNCTION public.create_default_venue_settings();


--
-- Name: payment_methods trigger_ensure_one_default_payment; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_ensure_one_default_payment BEFORE INSERT OR UPDATE OF is_default ON public.payment_methods FOR EACH ROW WHEN ((new.is_default = true)) EXECUTE FUNCTION public.ensure_one_default_payment_method();


--
-- Name: wallet_addresses trigger_ensure_one_primary_wallet; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_ensure_one_primary_wallet BEFORE INSERT OR UPDATE OF is_primary ON public.wallet_addresses FOR EACH ROW WHEN ((new.is_primary = true)) EXECUTE FUNCTION public.ensure_one_primary_wallet();


--
-- Name: events trigger_event_metadata_update; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_event_metadata_update BEFORE INSERT OR UPDATE ON public.events FOR EACH ROW EXECUTE FUNCTION public.update_event_metadata();


--
-- Name: events trigger_generate_event_slug; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_generate_event_slug BEFORE INSERT OR UPDATE OF name ON public.events FOR EACH ROW EXECUTE FUNCTION public.generate_event_slug();


--
-- Name: invoices trigger_generate_invoice_number; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_generate_invoice_number BEFORE INSERT ON public.invoices FOR EACH ROW WHEN ((new.invoice_number IS NULL)) EXECUTE FUNCTION public.generate_invoice_number();


--
-- Name: tickets trigger_generate_qr_code; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_generate_qr_code BEFORE INSERT OR UPDATE OF ticket_code ON public.tickets FOR EACH ROW EXECUTE FUNCTION public.generate_qr_code_data();


--
-- Name: users trigger_generate_referral_code; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_generate_referral_code BEFORE INSERT ON public.users FOR EACH ROW EXECUTE FUNCTION public.generate_user_referral_code();


--
-- Name: venues trigger_generate_venue_slug; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_generate_venue_slug BEFORE INSERT OR UPDATE OF name ON public.venues FOR EACH ROW EXECUTE FUNCTION public.generate_venue_slug();


--
-- Name: users trigger_increment_referral_count; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_increment_referral_count AFTER UPDATE OF email_verified ON public.users FOR EACH ROW WHEN (((new.email_verified = true) AND (old.email_verified = false))) EXECUTE FUNCTION public.increment_referral_count();


--
-- Name: venue_integrations trigger_integration_metrics_update; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_integration_metrics_update BEFORE UPDATE ON public.venue_integrations FOR EACH ROW EXECUTE FUNCTION public.update_integration_metrics();


--
-- Name: venue_layouts trigger_layout_accessibility_validation; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_layout_accessibility_validation BEFORE INSERT OR UPDATE ON public.venue_layouts FOR EACH ROW EXECUTE FUNCTION public.validate_layout_accessibility();


--
-- Name: layout_sections trigger_layout_capacity_update; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_layout_capacity_update AFTER INSERT OR DELETE OR UPDATE ON public.layout_sections FOR EACH ROW EXECUTE FUNCTION public.update_layout_capacity();


--
-- Name: event_performers trigger_performer_order_update; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_performer_order_update BEFORE INSERT OR UPDATE ON public.event_performers FOR EACH ROW EXECUTE FUNCTION public.update_performer_order();


--
-- Name: permissions trigger_permissions_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_permissions_updated_at BEFORE UPDATE ON public.permissions FOR EACH ROW EXECUTE FUNCTION public.update_permissions_updated_at();


--
-- Name: role_permissions trigger_role_permissions_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_role_permissions_updated_at BEFORE UPDATE ON public.role_permissions FOR EACH ROW EXECUTE FUNCTION public.update_permissions_updated_at();


--
-- Name: roles trigger_roles_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_roles_updated_at BEFORE UPDATE ON public.roles FOR EACH ROW EXECUTE FUNCTION public.update_roles_updated_at();


--
-- Name: event_schedules trigger_schedule_conflict_detection; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_schedule_conflict_detection AFTER INSERT OR UPDATE ON public.event_schedules FOR EACH ROW EXECUTE FUNCTION public.detect_schedule_conflicts();


--
-- Name: staff_schedules trigger_schedule_hours_calculation; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_schedule_hours_calculation BEFORE INSERT OR UPDATE ON public.staff_schedules FOR EACH ROW EXECUTE FUNCTION public.calculate_schedule_hours();


--
-- Name: event_schedules trigger_schedule_metadata_update; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_schedule_metadata_update BEFORE INSERT OR UPDATE ON public.event_schedules FOR EACH ROW EXECUTE FUNCTION public.update_schedule_metadata();


--
-- Name: layout_seats trigger_seat_code_generation; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_seat_code_generation BEFORE INSERT OR UPDATE ON public.layout_seats FOR EACH ROW EXECUTE FUNCTION public.generate_seat_code();


--
-- Name: sessions trigger_session_activity; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_session_activity BEFORE UPDATE ON public.sessions FOR EACH ROW EXECUTE FUNCTION public.update_session_activity();


--
-- Name: event_sessions trigger_session_duration_calculation; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_session_duration_calculation BEFORE INSERT OR UPDATE ON public.event_sessions FOR EACH ROW EXECUTE FUNCTION public.calculate_session_duration();


--
-- Name: suspicious_sessions trigger_suspicious_sessions_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_suspicious_sessions_updated_at BEFORE UPDATE ON public.suspicious_sessions FOR EACH ROW EXECUTE FUNCTION public.update_suspicious_sessions_updated_at();


--
-- Name: listings trigger_track_listing_price; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_track_listing_price AFTER INSERT OR UPDATE OF price ON public.listings FOR EACH ROW EXECUTE FUNCTION public.track_price_history();


--
-- Name: orders trigger_track_order_state; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_track_order_state BEFORE UPDATE ON public.orders FOR EACH ROW EXECUTE FUNCTION public.track_order_state_change();


--
-- Name: event_capacity trigger_update_available_capacity; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_available_capacity BEFORE INSERT OR UPDATE OF sold_count, pending_count, reserved_capacity, total_capacity ON public.event_capacity FOR EACH ROW EXECUTE FUNCTION public.update_available_capacity();


--
-- Name: blockchain_transactions trigger_update_blockchain_transactions_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_blockchain_transactions_timestamp BEFORE UPDATE ON public.blockchain_transactions FOR EACH ROW EXECUTE FUNCTION public.update_blockchain_transactions_updated_at();


--
-- Name: dispute_resolution trigger_update_disputes_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_disputes_timestamp BEFORE UPDATE ON public.dispute_resolution FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: escrow trigger_update_escrow_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_escrow_timestamp BEFORE UPDATE ON public.escrow FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: event_capacity trigger_update_event_capacity_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_event_capacity_timestamp BEFORE UPDATE ON public.event_capacity FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: event_categories trigger_update_event_categories_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_event_categories_timestamp BEFORE UPDATE ON public.event_categories FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: event_metadata trigger_update_event_metadata_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_event_metadata_timestamp BEFORE UPDATE ON public.event_metadata FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: event_pricing trigger_update_event_pricing_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_event_pricing_timestamp BEFORE UPDATE ON public.event_pricing FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: event_schedules trigger_update_event_schedules_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_event_schedules_timestamp BEFORE UPDATE ON public.event_schedules FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: events trigger_update_events_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_events_timestamp BEFORE UPDATE ON public.events FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: financial_reports trigger_update_financial_reports_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_financial_reports_timestamp BEFORE UPDATE ON public.financial_reports FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: fraud_prevention_rules trigger_update_fraud_rules_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_fraud_rules_timestamp BEFORE UPDATE ON public.fraud_prevention_rules FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: gas_fee_tracking trigger_update_gas_fee_tracking_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_gas_fee_tracking_timestamp BEFORE UPDATE ON public.gas_fee_tracking FOR EACH ROW EXECUTE FUNCTION public.update_gas_fee_tracking_updated_at();


--
-- Name: invoices trigger_update_invoices_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_invoices_timestamp BEFORE UPDATE ON public.invoices FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: listings trigger_update_listings_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_listings_timestamp BEFORE UPDATE ON public.listings FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: marketplace_transactions trigger_update_marketplace_tx_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_marketplace_tx_timestamp BEFORE UPDATE ON public.marketplace_transactions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: nft_metadata trigger_update_nft_metadata_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_nft_metadata_timestamp BEFORE UPDATE ON public.nft_metadata FOR EACH ROW EXECUTE FUNCTION public.update_nft_metadata_updated_at();


--
-- Name: offers trigger_update_offers_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_offers_timestamp BEFORE UPDATE ON public.offers FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: order_items trigger_update_order_totals; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_order_totals AFTER INSERT OR DELETE OR UPDATE ON public.order_items FOR EACH ROW EXECUTE FUNCTION public.update_order_totals();


--
-- Name: payment_methods trigger_update_payment_methods_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_payment_methods_timestamp BEFORE UPDATE ON public.payment_methods FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: refunds trigger_update_refunds_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_refunds_timestamp BEFORE UPDATE ON public.refunds FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: royalties trigger_update_royalties_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_royalties_timestamp BEFORE UPDATE ON public.royalties FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: settlements trigger_update_settlements_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_settlements_timestamp BEFORE UPDATE ON public.settlements FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: transactions trigger_update_subscription_on_payment; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_subscription_on_payment AFTER UPDATE OF status ON public.transactions FOR EACH ROW WHEN ((((new.status)::text = 'succeeded'::text) AND ((old.status)::text <> 'succeeded'::text))) EXECUTE FUNCTION public.update_subscription_on_payment();


--
-- Name: subscriptions trigger_update_subscriptions_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_subscriptions_timestamp BEFORE UPDATE ON public.subscriptions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: ticket_metadata trigger_update_ticket_metadata_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_ticket_metadata_timestamp BEFORE UPDATE ON public.ticket_metadata FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: ticket_redemptions trigger_update_ticket_on_redemption; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_ticket_on_redemption AFTER INSERT ON public.ticket_redemptions FOR EACH ROW EXECUTE FUNCTION public.update_ticket_on_redemption();


--
-- Name: ticket_refunds trigger_update_ticket_refunds_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_ticket_refunds_timestamp BEFORE UPDATE ON public.ticket_refunds FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: tickets trigger_update_ticket_supply; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_ticket_supply AFTER INSERT OR DELETE ON public.tickets FOR EACH ROW EXECUTE FUNCTION public.update_ticket_type_supply();


--
-- Name: ticket_transfers trigger_update_ticket_transfers_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_ticket_transfers_timestamp BEFORE UPDATE ON public.ticket_transfers FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: ticket_types trigger_update_ticket_types_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_ticket_types_timestamp BEFORE UPDATE ON public.ticket_types FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: tickets trigger_update_tickets_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_tickets_timestamp BEFORE UPDATE ON public.tickets FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: transactions trigger_update_transactions_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_transactions_timestamp BEFORE UPDATE ON public.transactions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: users trigger_update_users_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_users_timestamp BEFORE UPDATE ON public.users FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: venue_integrations trigger_update_venue_integrations_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_venue_integrations_timestamp BEFORE UPDATE ON public.venue_integrations FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: venue_layouts trigger_update_venue_layouts_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_venue_layouts_timestamp BEFORE UPDATE ON public.venue_layouts FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: venue_settings trigger_update_venue_settings_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_venue_settings_timestamp BEFORE UPDATE ON public.venue_settings FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: venue_staff trigger_update_venue_staff_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_venue_staff_timestamp BEFORE UPDATE ON public.venue_staff FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: venues trigger_update_venues_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_venues_timestamp BEFORE UPDATE ON public.venues FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: wallet_addresses trigger_update_wallet_addresses_timestamp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_wallet_addresses_timestamp BEFORE UPDATE ON public.wallet_addresses FOR EACH ROW EXECUTE FUNCTION public.update_wallet_addresses_updated_at();


--
-- Name: user_permissions trigger_user_permissions_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_user_permissions_updated_at BEFORE UPDATE ON public.user_permissions FOR EACH ROW EXECUTE FUNCTION public.update_permissions_updated_at();


--
-- Name: user_roles trigger_user_roles_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_user_roles_updated_at BEFORE UPDATE ON public.user_roles FOR EACH ROW EXECUTE FUNCTION public.update_roles_updated_at();


--
-- Name: users trigger_users_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_users_updated_at BEFORE UPDATE ON public.users FOR EACH ROW EXECUTE FUNCTION public.update_users_updated_at();


--
-- Name: venue_operating_hours trigger_venue_hours_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_venue_hours_updated_at BEFORE UPDATE ON public.venue_operating_hours FOR EACH ROW EXECUTE FUNCTION public.update_venue_hours_updated_at();


--
-- Name: venue_integrations trigger_venue_integration_status; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_venue_integration_status BEFORE INSERT OR UPDATE ON public.venue_integrations FOR EACH ROW EXECUTE FUNCTION public.update_venue_integration_status();


--
-- Name: venues trigger_venue_metadata_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_venue_metadata_insert BEFORE INSERT ON public.venues FOR EACH ROW EXECUTE FUNCTION public.update_venue_metadata();


--
-- Name: venues trigger_venue_metadata_update; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_venue_metadata_update BEFORE UPDATE ON public.venues FOR EACH ROW EXECUTE FUNCTION public.update_venue_metadata();


--
-- Name: venue_policies trigger_venue_policy_version; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_venue_policy_version BEFORE INSERT OR UPDATE ON public.venue_policies FOR EACH ROW EXECUTE FUNCTION public.update_venue_policy_version();


--
-- Name: venue_settings trigger_venue_setting_metadata; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_venue_setting_metadata BEFORE INSERT OR UPDATE ON public.venue_settings FOR EACH ROW EXECUTE FUNCTION public.update_venue_setting_metadata();


--
-- Name: venue_staff trigger_venue_staff_metadata; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_venue_staff_metadata BEFORE INSERT OR UPDATE ON public.venue_staff FOR EACH ROW EXECUTE FUNCTION public.update_venue_staff_metadata();


--
-- Name: compliance_violations trigger_violation_metrics_update; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_violation_metrics_update BEFORE INSERT OR UPDATE ON public.compliance_violations FOR EACH ROW EXECUTE FUNCTION public.update_violation_metrics();


--
-- Name: integration_webhooks trigger_webhook_metrics_update; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_webhook_metrics_update BEFORE UPDATE ON public.integration_webhooks FOR EACH ROW EXECUTE FUNCTION public.update_webhook_metrics();


--
-- Name: customer_feedback update_customer_feedback_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_customer_feedback_updated_at BEFORE UPDATE ON public.customer_feedback FOR EACH ROW EXECUTE FUNCTION public.update_customer_feedback_updated_at();


--
-- Name: customer_preferences update_customer_preferences_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_customer_preferences_updated_at BEFORE UPDATE ON public.customer_preferences FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: customer_profiles update_customer_profiles_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_customer_profiles_updated_at BEFORE UPDATE ON public.customer_profiles FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: customer_feedback update_entity_ratings_trigger; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_entity_ratings_trigger AFTER INSERT OR UPDATE OF status, overall_rating ON public.customer_feedback FOR EACH ROW WHEN (((new.status)::text = 'published'::text)) EXECUTE FUNCTION public.update_entity_average_ratings();


--
-- Name: feedback_responses update_feedback_responses_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_feedback_responses_updated_at BEFORE UPDATE ON public.feedback_responses FOR EACH ROW EXECUTE FUNCTION public.update_feedback_responses_updated_at();


--
-- Name: invoices update_invoices_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_invoices_updated_at BEFORE UPDATE ON public.invoices FOR EACH ROW EXECUTE FUNCTION public.update_invoices_updated_at();


--
-- Name: loyalty_programs update_loyalty_programs_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_loyalty_programs_updated_at BEFORE UPDATE ON public.loyalty_programs FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: payment_methods update_payment_methods_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_payment_methods_updated_at BEFORE UPDATE ON public.payment_methods FOR EACH ROW EXECUTE FUNCTION public.update_payment_methods_updated_at();


--
-- Name: refunds update_refunds_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_refunds_updated_at BEFORE UPDATE ON public.refunds FOR EACH ROW EXECUTE FUNCTION public.update_refunds_updated_at();


--
-- Name: segment_definitions update_segment_definitions_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_segment_definitions_updated_at BEFORE UPDATE ON public.segment_definitions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: settlements update_settlement_status_timestamps_trigger; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_settlement_status_timestamps_trigger BEFORE UPDATE OF status ON public.settlements FOR EACH ROW EXECUTE FUNCTION public.update_settlement_status_timestamps();


--
-- Name: settlements update_settlements_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_settlements_updated_at BEFORE UPDATE ON public.settlements FOR EACH ROW EXECUTE FUNCTION public.update_settlements_updated_at();


--
-- Name: subscriptions update_subscriptions_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_subscriptions_updated_at BEFORE UPDATE ON public.subscriptions FOR EACH ROW EXECUTE FUNCTION public.update_subscriptions_updated_at();


--
-- Name: ticket_metadata update_ticket_metadata_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_ticket_metadata_updated_at BEFORE UPDATE ON public.ticket_metadata FOR EACH ROW EXECUTE FUNCTION public.update_ticket_metadata_updated_at();


--
-- Name: ticket_refunds update_ticket_refunds_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_ticket_refunds_updated_at BEFORE UPDATE ON public.ticket_refunds FOR EACH ROW EXECUTE FUNCTION public.update_ticket_refunds_updated_at();


--
-- Name: ticket_transactions update_ticket_transactions_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_ticket_transactions_updated_at BEFORE UPDATE ON public.ticket_transactions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: transactions update_transaction_status_timestamps_trigger; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_transaction_status_timestamps_trigger BEFORE UPDATE OF status ON public.transactions FOR EACH ROW EXECUTE FUNCTION public.update_transaction_status_timestamps();


--
-- Name: transactions update_transactions_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_transactions_updated_at BEFORE UPDATE ON public.transactions FOR EACH ROW EXECUTE FUNCTION public.update_transactions_updated_at();


--
-- Name: ticket_metadata validate_metadata_before_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER validate_metadata_before_insert BEFORE INSERT OR UPDATE ON public.ticket_metadata FOR EACH ROW EXECUTE FUNCTION public.validate_metadata_attributes();


--
-- Name: ticket_redemptions validate_redemption_before_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER validate_redemption_before_insert BEFORE INSERT ON public.ticket_redemptions FOR EACH ROW EXECUTE FUNCTION public.validate_redemption();


--
-- Name: ticket_transfers validate_transfer_status_before_update; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER validate_transfer_status_before_update BEFORE UPDATE OF status ON public.ticket_transfers FOR EACH ROW EXECUTE FUNCTION public.validate_transfer_status_transition();


--
-- Name: royalty_settlements fk_settlements_venue; Type: FK CONSTRAINT; Schema: marketplace; Owner: postgres
--

ALTER TABLE ONLY marketplace.royalty_settlements
    ADD CONSTRAINT fk_settlements_venue FOREIGN KEY (venue_id) REFERENCES public.venues(id) ON DELETE RESTRICT;


--
-- Name: aml_checks aml_checks_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.aml_checks
    ADD CONSTRAINT aml_checks_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: analytics_events analytics_events_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.analytics_events
    ADD CONSTRAINT analytics_events_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: api_credentials api_credentials_api_key_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.api_credentials
    ADD CONSTRAINT api_credentials_api_key_id_fkey FOREIGN KEY (api_key_id) REFERENCES public.api_keys(id);


--
-- Name: api_keys api_keys_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.api_keys
    ADD CONSTRAINT api_keys_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: audit_log_entries audit_log_entries_log_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.audit_log_entries
    ADD CONSTRAINT audit_log_entries_log_id_fkey FOREIGN KEY (log_id) REFERENCES public.audit_log(id);


--
-- Name: audit_log audit_log_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.audit_log
    ADD CONSTRAINT audit_log_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: commissions commissions_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.commissions
    ADD CONSTRAINT commissions_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: customer_analytics customer_analytics_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.customer_analytics
    ADD CONSTRAINT customer_analytics_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: customer_ltv customer_ltv_customer_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.customer_ltv
    ADD CONSTRAINT customer_ltv_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.users(id);


--
-- Name: data_deletion_requests data_deletion_requests_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.data_deletion_requests
    ADD CONSTRAINT data_deletion_requests_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: data_export_requests data_export_requests_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.data_export_requests
    ADD CONSTRAINT data_export_requests_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: dispute_evidence_packs dispute_evidence_packs_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dispute_evidence_packs
    ADD CONSTRAINT dispute_evidence_packs_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.orders(id);


--
-- Name: dispute_messages dispute_messages_dispute_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dispute_messages
    ADD CONSTRAINT dispute_messages_dispute_id_fkey FOREIGN KEY (dispute_id) REFERENCES public.dispute_resolution(id);


--
-- Name: dispute_resolution dispute_resolution_escrow_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dispute_resolution
    ADD CONSTRAINT dispute_resolution_escrow_id_fkey FOREIGN KEY (escrow_id) REFERENCES public.escrow(id);


--
-- Name: dispute_resolution dispute_resolution_initiator_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dispute_resolution
    ADD CONSTRAINT dispute_resolution_initiator_id_fkey FOREIGN KEY (initiator_id) REFERENCES public.users(id);


--
-- Name: dispute_resolution dispute_resolution_marketplace_transaction_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dispute_resolution
    ADD CONSTRAINT dispute_resolution_marketplace_transaction_id_fkey FOREIGN KEY (marketplace_transaction_id) REFERENCES public.marketplace_transactions(id);


--
-- Name: dispute_resolution dispute_resolution_resolved_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dispute_resolution
    ADD CONSTRAINT dispute_resolution_resolved_by_fkey FOREIGN KEY (resolved_by) REFERENCES public.users(id);


--
-- Name: dispute_resolution dispute_resolution_respondent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dispute_resolution
    ADD CONSTRAINT dispute_resolution_respondent_id_fkey FOREIGN KEY (respondent_id) REFERENCES public.users(id);


--
-- Name: escrow escrow_buyer_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.escrow
    ADD CONSTRAINT escrow_buyer_id_fkey FOREIGN KEY (buyer_id) REFERENCES public.users(id);


--
-- Name: escrow escrow_marketplace_transaction_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.escrow
    ADD CONSTRAINT escrow_marketplace_transaction_id_fkey FOREIGN KEY (marketplace_transaction_id) REFERENCES public.marketplace_transactions(id);


--
-- Name: escrow escrow_payment_transaction_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.escrow
    ADD CONSTRAINT escrow_payment_transaction_id_fkey FOREIGN KEY (payment_transaction_id) REFERENCES public.transactions(id);


--
-- Name: escrow escrow_release_transaction_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.escrow
    ADD CONSTRAINT escrow_release_transaction_id_fkey FOREIGN KEY (release_transaction_id) REFERENCES public.transactions(id);


--
-- Name: escrow escrow_seller_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.escrow
    ADD CONSTRAINT escrow_seller_id_fkey FOREIGN KEY (seller_id) REFERENCES public.users(id);


--
-- Name: event_analytics event_analytics_event_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_analytics
    ADD CONSTRAINT event_analytics_event_id_fkey FOREIGN KEY (event_id) REFERENCES public.events(id);


--
-- Name: event_capacity event_capacity_event_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity
    ADD CONSTRAINT event_capacity_event_id_fkey FOREIGN KEY (event_id) REFERENCES public.events(id) ON DELETE CASCADE;


--
-- Name: event_capacity event_capacity_schedule_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity
    ADD CONSTRAINT event_capacity_schedule_id_fkey FOREIGN KEY (schedule_id) REFERENCES public.event_schedules(id) ON DELETE CASCADE;


--
-- Name: event_categories event_categories_parent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_categories
    ADD CONSTRAINT event_categories_parent_id_fkey FOREIGN KEY (parent_id) REFERENCES public.event_categories(id) ON DELETE CASCADE;


--
-- Name: event_metadata event_metadata_event_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_metadata
    ADD CONSTRAINT event_metadata_event_id_fkey FOREIGN KEY (event_id) REFERENCES public.events(id) ON DELETE CASCADE;


--
-- Name: event_performance event_performance_event_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_performance
    ADD CONSTRAINT event_performance_event_id_fkey FOREIGN KEY (event_id) REFERENCES public.events(id);


--
-- Name: event_performers event_performers_event_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_performers
    ADD CONSTRAINT event_performers_event_id_fkey FOREIGN KEY (event_id) REFERENCES public.events(id) ON DELETE CASCADE;


--
-- Name: event_pricing event_pricing_capacity_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing
    ADD CONSTRAINT event_pricing_capacity_id_fkey FOREIGN KEY (capacity_id) REFERENCES public.event_capacity(id) ON DELETE CASCADE;


--
-- Name: event_pricing event_pricing_event_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing
    ADD CONSTRAINT event_pricing_event_id_fkey FOREIGN KEY (event_id) REFERENCES public.events(id) ON DELETE CASCADE;


--
-- Name: event_pricing event_pricing_schedule_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing
    ADD CONSTRAINT event_pricing_schedule_id_fkey FOREIGN KEY (schedule_id) REFERENCES public.event_schedules(id) ON DELETE CASCADE;


--
-- Name: event_production_schedules event_production_schedules_event_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_production_schedules
    ADD CONSTRAINT event_production_schedules_event_id_fkey FOREIGN KEY (event_id) REFERENCES public.events(id) ON DELETE CASCADE;


--
-- Name: event_schedules event_schedules_event_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_schedules
    ADD CONSTRAINT event_schedules_event_id_fkey FOREIGN KEY (event_id) REFERENCES public.events(id) ON DELETE CASCADE;


--
-- Name: event_sessions event_sessions_event_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_sessions
    ADD CONSTRAINT event_sessions_event_id_fkey FOREIGN KEY (event_id) REFERENCES public.events(id) ON DELETE CASCADE;


--
-- Name: event_tiers event_tiers_event_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_tiers
    ADD CONSTRAINT event_tiers_event_id_fkey FOREIGN KEY (event_id) REFERENCES public.events(id);


--
-- Name: events events_venue_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.events
    ADD CONSTRAINT events_venue_id_fkey FOREIGN KEY (venue_id) REFERENCES public.venues(id);


--
-- Name: failed_login_attempts failed_login_attempts_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.failed_login_attempts
    ADD CONSTRAINT failed_login_attempts_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: feedback_responses feedback_responses_feedback_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.feedback_responses
    ADD CONSTRAINT feedback_responses_feedback_id_fkey FOREIGN KEY (feedback_id) REFERENCES public.customer_feedback(id) ON DELETE CASCADE;


--
-- Name: file_access_logs file_access_logs_file_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.file_access_logs
    ADD CONSTRAINT file_access_logs_file_id_fkey FOREIGN KEY (file_id) REFERENCES public.files(id) ON DELETE CASCADE;


--
-- Name: file_access_logs file_access_logs_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.file_access_logs
    ADD CONSTRAINT file_access_logs_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: file_versions file_versions_file_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.file_versions
    ADD CONSTRAINT file_versions_file_id_fkey FOREIGN KEY (file_id) REFERENCES public.files(id) ON DELETE CASCADE;


--
-- Name: files files_uploader_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.files
    ADD CONSTRAINT files_uploader_id_fkey FOREIGN KEY (uploader_id) REFERENCES public.users(id);


--
-- Name: ticket_type_availability_schedules fk_availability_schedule_creator; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_type_availability_schedules
    ADD CONSTRAINT fk_availability_schedule_creator FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: ticket_type_availability_schedules fk_availability_schedule_ticket_type; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_type_availability_schedules
    ADD CONSTRAINT fk_availability_schedule_ticket_type FOREIGN KEY (ticket_type_id) REFERENCES public.ticket_types(id) ON DELETE CASCADE;


--
-- Name: ticket_batch_operations fk_batch_event; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_batch_operations
    ADD CONSTRAINT fk_batch_event FOREIGN KEY (event_id) REFERENCES public.events(id) ON DELETE CASCADE;


--
-- Name: ticket_batch_operations fk_batch_initiator; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_batch_operations
    ADD CONSTRAINT fk_batch_initiator FOREIGN KEY (initiated_by) REFERENCES public.users(id) ON DELETE RESTRICT;


--
-- Name: ticket_batch_operations fk_batch_target_user; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_batch_operations
    ADD CONSTRAINT fk_batch_target_user FOREIGN KEY (target_user_id) REFERENCES public.users(id);


--
-- Name: ticket_batch_operations fk_batch_ticket_type; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_batch_operations
    ADD CONSTRAINT fk_batch_ticket_type FOREIGN KEY (ticket_type_id) REFERENCES public.ticket_types(id) ON DELETE CASCADE;


--
-- Name: ticket_type_benefits fk_benefit_ticket_type; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_type_benefits
    ADD CONSTRAINT fk_benefit_ticket_type FOREIGN KEY (ticket_type_id) REFERENCES public.ticket_types(id) ON DELETE CASCADE;


--
-- Name: event_capacity_alerts fk_capacity_alert_ack_user; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_alerts
    ADD CONSTRAINT fk_capacity_alert_ack_user FOREIGN KEY (acknowledged_by) REFERENCES public.users(id);


--
-- Name: event_capacity_alerts fk_capacity_alert_main; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_alerts
    ADD CONSTRAINT fk_capacity_alert_main FOREIGN KEY (event_capacity_id) REFERENCES public.event_capacity(id) ON DELETE CASCADE;


--
-- Name: event_capacity_holds fk_capacity_hold_creator; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_holds
    ADD CONSTRAINT fk_capacity_hold_creator FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: event_capacity_holds fk_capacity_hold_main; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_holds
    ADD CONSTRAINT fk_capacity_hold_main FOREIGN KEY (event_capacity_id) REFERENCES public.event_capacity(id) ON DELETE CASCADE;


--
-- Name: event_capacity_holds fk_capacity_hold_releaser; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_holds
    ADD CONSTRAINT fk_capacity_hold_releaser FOREIGN KEY (released_by) REFERENCES public.users(id);


--
-- Name: event_capacity_holds fk_capacity_hold_type; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_holds
    ADD CONSTRAINT fk_capacity_hold_type FOREIGN KEY (ticket_type_id) REFERENCES public.ticket_types(id);


--
-- Name: event_capacity_reservations fk_capacity_reservation_main; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_reservations
    ADD CONSTRAINT fk_capacity_reservation_main FOREIGN KEY (event_capacity_id) REFERENCES public.event_capacity(id) ON DELETE CASCADE;


--
-- Name: event_capacity_reservations fk_capacity_reservation_user; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_reservations
    ADD CONSTRAINT fk_capacity_reservation_user FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: event_capacity_snapshots fk_capacity_snapshot_main; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_snapshots
    ADD CONSTRAINT fk_capacity_snapshot_main FOREIGN KEY (event_capacity_id) REFERENCES public.event_capacity(id) ON DELETE CASCADE;


--
-- Name: event_capacity_by_tier fk_capacity_tier_main; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_by_tier
    ADD CONSTRAINT fk_capacity_tier_main FOREIGN KEY (event_capacity_id) REFERENCES public.event_capacity(id) ON DELETE CASCADE;


--
-- Name: event_capacity_by_type fk_capacity_type_main; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_by_type
    ADD CONSTRAINT fk_capacity_type_main FOREIGN KEY (event_capacity_id) REFERENCES public.event_capacity(id) ON DELETE CASCADE;


--
-- Name: event_capacity_by_type fk_capacity_type_ticket; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_by_type
    ADD CONSTRAINT fk_capacity_type_ticket FOREIGN KEY (ticket_type_id) REFERENCES public.ticket_types(id) ON DELETE CASCADE;


--
-- Name: event_capacity_utilization_history fk_capacity_utilization_main; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_utilization_history
    ADD CONSTRAINT fk_capacity_utilization_main FOREIGN KEY (event_capacity_id) REFERENCES public.event_capacity(id) ON DELETE CASCADE;


--
-- Name: event_category_analytics fk_category_analytics_category; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_category_analytics
    ADD CONSTRAINT fk_category_analytics_category FOREIGN KEY (category_id) REFERENCES public.event_categories(id) ON DELETE CASCADE;


--
-- Name: event_category_attributes fk_category_attr_category; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_category_attributes
    ADD CONSTRAINT fk_category_attr_category FOREIGN KEY (category_id) REFERENCES public.event_categories(id) ON DELETE CASCADE;


--
-- Name: event_category_search_suggestions fk_category_suggestion_category; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_category_search_suggestions
    ADD CONSTRAINT fk_category_suggestion_category FOREIGN KEY (category_id) REFERENCES public.event_categories(id) ON DELETE CASCADE;


--
-- Name: event_category_tags fk_category_tag_category; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_category_tags
    ADD CONSTRAINT fk_category_tag_category FOREIGN KEY (category_id) REFERENCES public.event_categories(id) ON DELETE CASCADE;


--
-- Name: event_category_trending fk_category_trending_category; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_category_trending
    ADD CONSTRAINT fk_category_trending_category FOREIGN KEY (category_id) REFERENCES public.event_categories(id) ON DELETE CASCADE;


--
-- Name: event_pricing_demand_factors fk_demand_factor_pricing; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_demand_factors
    ADD CONSTRAINT fk_demand_factor_pricing FOREIGN KEY (event_pricing_id) REFERENCES public.event_pricing(id) ON DELETE CASCADE;


--
-- Name: event_pricing_dynamic_rules fk_dynamic_rule_creator; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_dynamic_rules
    ADD CONSTRAINT fk_dynamic_rule_creator FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: event_pricing_dynamic_rules fk_dynamic_rule_pricing; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_dynamic_rules
    ADD CONSTRAINT fk_dynamic_rule_pricing FOREIGN KEY (event_pricing_id) REFERENCES public.event_pricing(id) ON DELETE CASCADE;


--
-- Name: event_analytics_tracking fk_event_analytics_creator; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_analytics_tracking
    ADD CONSTRAINT fk_event_analytics_creator FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: event_analytics_tracking fk_event_analytics_event; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_analytics_tracking
    ADD CONSTRAINT fk_event_analytics_event FOREIGN KEY (event_id) REFERENCES public.events(id) ON DELETE CASCADE;


--
-- Name: event_category_mappings fk_event_category_category; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_category_mappings
    ADD CONSTRAINT fk_event_category_category FOREIGN KEY (category_id) REFERENCES public.event_categories(id) ON DELETE CASCADE;


--
-- Name: event_category_mappings fk_event_category_event; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_category_mappings
    ADD CONSTRAINT fk_event_category_event FOREIGN KEY (event_id) REFERENCES public.events(id) ON DELETE CASCADE;


--
-- Name: event_category_mappings fk_event_category_user; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_category_mappings
    ADD CONSTRAINT fk_event_category_user FOREIGN KEY (assigned_by_user) REFERENCES public.users(id);


--
-- Name: event_custom_attributes fk_event_custom_creator; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_custom_attributes
    ADD CONSTRAINT fk_event_custom_creator FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: event_custom_attributes fk_event_custom_event; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_custom_attributes
    ADD CONSTRAINT fk_event_custom_event FOREIGN KEY (event_id) REFERENCES public.events(id) ON DELETE CASCADE;


--
-- Name: event_marketing_campaigns fk_event_marketing_creator; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_marketing_campaigns
    ADD CONSTRAINT fk_event_marketing_creator FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: event_marketing_campaigns fk_event_marketing_event; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_marketing_campaigns
    ADD CONSTRAINT fk_event_marketing_event FOREIGN KEY (event_id) REFERENCES public.events(id) ON DELETE CASCADE;


--
-- Name: event_seo_metadata fk_event_seo_event; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_seo_metadata
    ADD CONSTRAINT fk_event_seo_event FOREIGN KEY (event_id) REFERENCES public.events(id) ON DELETE CASCADE;


--
-- Name: event_social_media fk_event_social_event; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_social_media
    ADD CONSTRAINT fk_event_social_event FOREIGN KEY (event_id) REFERENCES public.events(id) ON DELETE CASCADE;


--
-- Name: event_pricing_group_discounts fk_group_discount_creator; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_group_discounts
    ADD CONSTRAINT fk_group_discount_creator FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: event_pricing_group_discounts fk_group_discount_pricing; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_group_discounts
    ADD CONSTRAINT fk_group_discount_pricing FOREIGN KEY (event_pricing_id) REFERENCES public.event_pricing(id) ON DELETE CASCADE;


--
-- Name: event_metadata_history fk_metadata_history_event; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_metadata_history
    ADD CONSTRAINT fk_metadata_history_event FOREIGN KEY (event_id) REFERENCES public.events(id) ON DELETE CASCADE;


--
-- Name: event_metadata_history fk_metadata_history_metadata; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_metadata_history
    ADD CONSTRAINT fk_metadata_history_metadata FOREIGN KEY (metadata_id) REFERENCES public.event_metadata(id) ON DELETE CASCADE;


--
-- Name: event_metadata_history fk_metadata_history_user; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_metadata_history
    ADD CONSTRAINT fk_metadata_history_user FOREIGN KEY (changed_by) REFERENCES public.users(id);


--
-- Name: event_metadata_templates fk_metadata_template_category; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_metadata_templates
    ADD CONSTRAINT fk_metadata_template_category FOREIGN KEY (category_id) REFERENCES public.event_categories(id) ON DELETE SET NULL;


--
-- Name: event_metadata_templates fk_metadata_template_creator; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_metadata_templates
    ADD CONSTRAINT fk_metadata_template_creator FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: event_metadata_templates fk_metadata_template_venue; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_metadata_templates
    ADD CONSTRAINT fk_metadata_template_venue FOREIGN KEY (venue_id) REFERENCES public.venues(id) ON DELETE SET NULL;


--
-- Name: event_capacity_oversell_policies fk_oversell_policy_creator; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_oversell_policies
    ADD CONSTRAINT fk_oversell_policy_creator FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: event_capacity_oversell_policies fk_oversell_policy_main; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_capacity_oversell_policies
    ADD CONSTRAINT fk_oversell_policy_main FOREIGN KEY (event_capacity_id) REFERENCES public.event_capacity(id) ON DELETE CASCADE;


--
-- Name: ticket_ownership_history fk_ownership_ticket; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_ownership_history
    ADD CONSTRAINT fk_ownership_ticket FOREIGN KEY (ticket_id) REFERENCES public.tickets(id) ON DELETE CASCADE;


--
-- Name: ticket_ownership_history fk_ownership_user; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_ownership_history
    ADD CONSTRAINT fk_ownership_user FOREIGN KEY (owner_user_id) REFERENCES public.users(id) ON DELETE RESTRICT;


--
-- Name: venue_payout_accounts fk_payout_accounts_venue; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_payout_accounts
    ADD CONSTRAINT fk_payout_accounts_venue FOREIGN KEY (venue_id) REFERENCES public.venues(id) ON DELETE CASCADE;


--
-- Name: event_pricing_history fk_pricing_history_main; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_history
    ADD CONSTRAINT fk_pricing_history_main FOREIGN KEY (event_pricing_id) REFERENCES public.event_pricing(id) ON DELETE CASCADE;


--
-- Name: event_pricing_history fk_pricing_history_tier; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_history
    ADD CONSTRAINT fk_pricing_history_tier FOREIGN KEY (tier_id) REFERENCES public.event_pricing_tiers(id) ON DELETE CASCADE;


--
-- Name: event_pricing_history fk_pricing_history_user; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_history
    ADD CONSTRAINT fk_pricing_history_user FOREIGN KEY (applied_by) REFERENCES public.users(id);


--
-- Name: event_pricing_schedules fk_pricing_schedule_creator; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_schedules
    ADD CONSTRAINT fk_pricing_schedule_creator FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: event_pricing_schedules fk_pricing_schedule_main; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_schedules
    ADD CONSTRAINT fk_pricing_schedule_main FOREIGN KEY (event_pricing_id) REFERENCES public.event_pricing(id) ON DELETE CASCADE;


--
-- Name: event_pricing_schedules fk_pricing_schedule_tier; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_schedules
    ADD CONSTRAINT fk_pricing_schedule_tier FOREIGN KEY (tier_id) REFERENCES public.event_pricing_tiers(id) ON DELETE CASCADE;


--
-- Name: event_pricing_tiers fk_pricing_tier_main; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_tiers
    ADD CONSTRAINT fk_pricing_tier_main FOREIGN KEY (event_pricing_id) REFERENCES public.event_pricing(id) ON DELETE CASCADE;


--
-- Name: event_pricing_promo_codes fk_promo_code_creator; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_promo_codes
    ADD CONSTRAINT fk_promo_code_creator FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: event_pricing_promo_codes fk_promo_code_pricing; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_promo_codes
    ADD CONSTRAINT fk_promo_code_pricing FOREIGN KEY (event_pricing_id) REFERENCES public.event_pricing(id) ON DELETE CASCADE;


--
-- Name: ticket_type_refund_policies fk_refund_policy_creator; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_type_refund_policies
    ADD CONSTRAINT fk_refund_policy_creator FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: ticket_type_refund_policies fk_refund_policy_ticket_type; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_type_refund_policies
    ADD CONSTRAINT fk_refund_policy_ticket_type FOREIGN KEY (ticket_type_id) REFERENCES public.ticket_types(id) ON DELETE CASCADE;


--
-- Name: ticket_resale_listings fk_resale_creator; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_resale_listings
    ADD CONSTRAINT fk_resale_creator FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: ticket_resale_listings fk_resale_seller; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_resale_listings
    ADD CONSTRAINT fk_resale_seller FOREIGN KEY (seller_user_id) REFERENCES public.users(id) ON DELETE RESTRICT;


--
-- Name: ticket_resale_listings fk_resale_ticket; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_resale_listings
    ADD CONSTRAINT fk_resale_ticket FOREIGN KEY (ticket_id) REFERENCES public.tickets(id) ON DELETE CASCADE;


--
-- Name: ticket_type_restrictions fk_restriction_creator; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_type_restrictions
    ADD CONSTRAINT fk_restriction_creator FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: ticket_type_restrictions fk_restriction_ticket_type; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_type_restrictions
    ADD CONSTRAINT fk_restriction_ticket_type FOREIGN KEY (ticket_type_id) REFERENCES public.ticket_types(id) ON DELETE CASCADE;


--
-- Name: event_pricing_surge_thresholds fk_surge_threshold_creator; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_surge_thresholds
    ADD CONSTRAINT fk_surge_threshold_creator FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: event_pricing_surge_thresholds fk_surge_threshold_pricing; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_pricing_surge_thresholds
    ADD CONSTRAINT fk_surge_threshold_pricing FOREIGN KEY (event_pricing_id) REFERENCES public.event_pricing(id) ON DELETE CASCADE;


--
-- Name: blockchain_transactions fk_ticket; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.blockchain_transactions
    ADD CONSTRAINT fk_ticket FOREIGN KEY (ticket_id) REFERENCES public.tickets(id) ON DELETE CASCADE;


--
-- Name: nft_metadata fk_ticket; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.nft_metadata
    ADD CONSTRAINT fk_ticket FOREIGN KEY (ticket_id) REFERENCES public.tickets(id) ON DELETE CASCADE;


--
-- Name: ticket_type_analytics fk_ticket_analytics_ticket_type; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_type_analytics
    ADD CONSTRAINT fk_ticket_analytics_ticket_type FOREIGN KEY (ticket_type_id) REFERENCES public.ticket_types(id) ON DELETE CASCADE;


--
-- Name: tickets fk_tickets_original_purchaser; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tickets
    ADD CONSTRAINT fk_tickets_original_purchaser FOREIGN KEY (original_purchaser_id) REFERENCES public.users(id);


--
-- Name: gas_fee_tracking fk_transaction; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.gas_fee_tracking
    ADD CONSTRAINT fk_transaction FOREIGN KEY (transaction_id) REFERENCES public.blockchain_transactions(id) ON DELETE CASCADE;


--
-- Name: smart_contract_events fk_transaction; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.smart_contract_events
    ADD CONSTRAINT fk_transaction FOREIGN KEY (transaction_signature) REFERENCES public.blockchain_transactions(transaction_signature) ON DELETE CASCADE;


--
-- Name: ticket_type_transfer_policies fk_transfer_policy_creator; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_type_transfer_policies
    ADD CONSTRAINT fk_transfer_policy_creator FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: ticket_type_transfer_policies fk_transfer_policy_ticket_type; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_type_transfer_policies
    ADD CONSTRAINT fk_transfer_policy_ticket_type FOREIGN KEY (ticket_type_id) REFERENCES public.ticket_types(id) ON DELETE CASCADE;


--
-- Name: wallet_addresses fk_user; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.wallet_addresses
    ADD CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: ticket_validations fk_validation_ticket; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_validations
    ADD CONSTRAINT fk_validation_ticket FOREIGN KEY (ticket_id) REFERENCES public.tickets(id) ON DELETE CASCADE;


--
-- Name: ticket_validations fk_validation_user; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_validations
    ADD CONSTRAINT fk_validation_user FOREIGN KEY (validated_by_user_id) REFERENCES public.users(id);


--
-- Name: venue_custom_categories fk_venue_category_category; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_custom_categories
    ADD CONSTRAINT fk_venue_category_category FOREIGN KEY (category_id) REFERENCES public.event_categories(id) ON DELETE CASCADE;


--
-- Name: venue_custom_categories fk_venue_category_creator; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_custom_categories
    ADD CONSTRAINT fk_venue_category_creator FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: venue_custom_categories fk_venue_category_venue; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_custom_categories
    ADD CONSTRAINT fk_venue_category_venue FOREIGN KEY (venue_id) REFERENCES public.venues(id) ON DELETE CASCADE;


--
-- Name: image_metadata image_metadata_file_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.image_metadata
    ADD CONSTRAINT image_metadata_file_id_fkey FOREIGN KEY (file_id) REFERENCES public.files(id) ON DELETE CASCADE;


--
-- Name: integration_data_mappings integration_data_mappings_integration_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.integration_data_mappings
    ADD CONSTRAINT integration_data_mappings_integration_id_fkey FOREIGN KEY (integration_id) REFERENCES public.venue_integrations(id) ON DELETE CASCADE;


--
-- Name: integration_logs integration_logs_integration_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.integration_logs
    ADD CONSTRAINT integration_logs_integration_id_fkey FOREIGN KEY (integration_id) REFERENCES public.venue_integrations(id) ON DELETE CASCADE;


--
-- Name: integration_logs integration_logs_original_log_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.integration_logs
    ADD CONSTRAINT integration_logs_original_log_id_fkey FOREIGN KEY (original_log_id) REFERENCES public.integration_logs(id);


--
-- Name: integration_logs integration_logs_webhook_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.integration_logs
    ADD CONSTRAINT integration_logs_webhook_id_fkey FOREIGN KEY (webhook_id) REFERENCES public.integration_webhooks(id) ON DELETE CASCADE;


--
-- Name: integration_schedules integration_schedules_integration_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.integration_schedules
    ADD CONSTRAINT integration_schedules_integration_id_fkey FOREIGN KEY (integration_id) REFERENCES public.venue_integrations(id) ON DELETE CASCADE;


--
-- Name: integration_webhooks integration_webhooks_integration_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.integration_webhooks
    ADD CONSTRAINT integration_webhooks_integration_id_fkey FOREIGN KEY (integration_id) REFERENCES public.venue_integrations(id) ON DELETE CASCADE;


--
-- Name: invoices invoices_payment_method_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoices
    ADD CONSTRAINT invoices_payment_method_id_fkey FOREIGN KEY (payment_method_id) REFERENCES public.payment_methods(id);


--
-- Name: invoices invoices_subscription_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoices
    ADD CONSTRAINT invoices_subscription_id_fkey FOREIGN KEY (subscription_id) REFERENCES public.subscriptions(id);


--
-- Name: invoices invoices_transaction_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoices
    ADD CONSTRAINT invoices_transaction_id_fkey FOREIGN KEY (transaction_id) REFERENCES public.transactions(id);


--
-- Name: invoices invoices_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoices
    ADD CONSTRAINT invoices_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: job_executions job_executions_job_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.job_executions
    ADD CONSTRAINT job_executions_job_id_fkey FOREIGN KEY (job_id) REFERENCES public.critical_jobs(id);


--
-- Name: kyc_records kyc_records_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.kyc_records
    ADD CONSTRAINT kyc_records_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: layout_accessibility_features layout_accessibility_features_layout_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.layout_accessibility_features
    ADD CONSTRAINT layout_accessibility_features_layout_id_fkey FOREIGN KEY (layout_id) REFERENCES public.venue_layouts(id) ON DELETE CASCADE;


--
-- Name: layout_accessibility_features layout_accessibility_features_section_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.layout_accessibility_features
    ADD CONSTRAINT layout_accessibility_features_section_id_fkey FOREIGN KEY (section_id) REFERENCES public.layout_sections(id);


--
-- Name: layout_pricing_zones layout_pricing_zones_layout_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.layout_pricing_zones
    ADD CONSTRAINT layout_pricing_zones_layout_id_fkey FOREIGN KEY (layout_id) REFERENCES public.venue_layouts(id) ON DELETE CASCADE;


--
-- Name: layout_seats layout_seats_section_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.layout_seats
    ADD CONSTRAINT layout_seats_section_id_fkey FOREIGN KEY (section_id) REFERENCES public.layout_sections(id) ON DELETE CASCADE;


--
-- Name: layout_sections layout_sections_layout_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.layout_sections
    ADD CONSTRAINT layout_sections_layout_id_fkey FOREIGN KEY (layout_id) REFERENCES public.venue_layouts(id) ON DELETE CASCADE;


--
-- Name: layout_sections layout_sections_parent_section_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.layout_sections
    ADD CONSTRAINT layout_sections_parent_section_id_fkey FOREIGN KEY (parent_section_id) REFERENCES public.layout_sections(id);


--
-- Name: listings listings_seller_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.listings
    ADD CONSTRAINT listings_seller_id_fkey FOREIGN KEY (seller_id) REFERENCES public.users(id);


--
-- Name: listings listings_ticket_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.listings
    ADD CONSTRAINT listings_ticket_id_fkey FOREIGN KEY (ticket_id) REFERENCES public.tickets(id) ON DELETE CASCADE;


--
-- Name: loyalty_accounts loyalty_accounts_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.loyalty_accounts
    ADD CONSTRAINT loyalty_accounts_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: loyalty_transactions loyalty_transactions_account_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.loyalty_transactions
    ADD CONSTRAINT loyalty_transactions_account_id_fkey FOREIGN KEY (account_id) REFERENCES public.loyalty_accounts(id);


--
-- Name: marketplace_transactions marketplace_transactions_buyer_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.marketplace_transactions
    ADD CONSTRAINT marketplace_transactions_buyer_id_fkey FOREIGN KEY (buyer_id) REFERENCES public.users(id);


--
-- Name: marketplace_transactions marketplace_transactions_listing_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.marketplace_transactions
    ADD CONSTRAINT marketplace_transactions_listing_id_fkey FOREIGN KEY (listing_id) REFERENCES public.listings(id);


--
-- Name: marketplace_transactions marketplace_transactions_offer_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.marketplace_transactions
    ADD CONSTRAINT marketplace_transactions_offer_id_fkey FOREIGN KEY (offer_id) REFERENCES public.offers(id);


--
-- Name: marketplace_transactions marketplace_transactions_seller_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.marketplace_transactions
    ADD CONSTRAINT marketplace_transactions_seller_id_fkey FOREIGN KEY (seller_id) REFERENCES public.users(id);


--
-- Name: marketplace_transactions marketplace_transactions_ticket_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.marketplace_transactions
    ADD CONSTRAINT marketplace_transactions_ticket_id_fkey FOREIGN KEY (ticket_id) REFERENCES public.tickets(id);


--
-- Name: notification_history notification_history_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.notification_history
    ADD CONSTRAINT notification_history_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: notification_preferences notification_preferences_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.notification_preferences
    ADD CONSTRAINT notification_preferences_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: notifications notifications_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT notifications_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: offers offers_buyer_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.offers
    ADD CONSTRAINT offers_buyer_id_fkey FOREIGN KEY (buyer_id) REFERENCES public.users(id);


--
-- Name: offers offers_listing_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.offers
    ADD CONSTRAINT offers_listing_id_fkey FOREIGN KEY (listing_id) REFERENCES public.listings(id) ON DELETE CASCADE;


--
-- Name: offers offers_previous_offer_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.offers
    ADD CONSTRAINT offers_previous_offer_id_fkey FOREIGN KEY (previous_offer_id) REFERENCES public.offers(id);


--
-- Name: offline_validation_cache offline_validation_cache_ticket_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.offline_validation_cache
    ADD CONSTRAINT offline_validation_cache_ticket_id_fkey FOREIGN KEY (ticket_id) REFERENCES public.tickets(id);


--
-- Name: order_items order_items_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_items
    ADD CONSTRAINT order_items_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.orders(id) ON DELETE CASCADE;


--
-- Name: order_items order_items_ticket_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_items
    ADD CONSTRAINT order_items_ticket_id_fkey FOREIGN KEY (ticket_id) REFERENCES public.tickets(id);


--
-- Name: order_items order_items_ticket_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_items
    ADD CONSTRAINT order_items_ticket_type_id_fkey FOREIGN KEY (ticket_type_id) REFERENCES public.ticket_types(id);


--
-- Name: order_state_transitions order_state_transitions_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_state_transitions
    ADD CONSTRAINT order_state_transitions_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.orders(id) ON DELETE CASCADE;


--
-- Name: order_state_transitions order_state_transitions_triggered_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_state_transitions
    ADD CONSTRAINT order_state_transitions_triggered_by_fkey FOREIGN KEY (triggered_by) REFERENCES public.users(id);


--
-- Name: orders orders_event_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.orders
    ADD CONSTRAINT orders_event_id_fkey FOREIGN KEY (event_id) REFERENCES public.events(id);


--
-- Name: orders orders_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.orders
    ADD CONSTRAINT orders_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: payment_intents payment_intents_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.payment_intents
    ADD CONSTRAINT payment_intents_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: payment_methods payment_methods_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.payment_methods
    ADD CONSTRAINT payment_methods_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: permission_dependencies permission_dependencies_permission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.permission_dependencies
    ADD CONSTRAINT permission_dependencies_permission_id_fkey FOREIGN KEY (permission_id) REFERENCES public.permissions(id) ON DELETE CASCADE;


--
-- Name: permission_dependencies permission_dependencies_required_permission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.permission_dependencies
    ADD CONSTRAINT permission_dependencies_required_permission_id_fkey FOREIGN KEY (required_permission_id) REFERENCES public.permissions(id) ON DELETE CASCADE;


--
-- Name: price_history price_history_event_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.price_history
    ADD CONSTRAINT price_history_event_id_fkey FOREIGN KEY (event_id) REFERENCES public.events(id);


--
-- Name: price_history price_history_listing_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.price_history
    ADD CONSTRAINT price_history_listing_id_fkey FOREIGN KEY (listing_id) REFERENCES public.listings(id);


--
-- Name: price_history price_history_ticket_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.price_history
    ADD CONSTRAINT price_history_ticket_id_fkey FOREIGN KEY (ticket_id) REFERENCES public.tickets(id);


--
-- Name: privacy_audit_log privacy_audit_log_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.privacy_audit_log
    ADD CONSTRAINT privacy_audit_log_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: qr_scan_attempts qr_scan_attempts_ticket_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.qr_scan_attempts
    ADD CONSTRAINT qr_scan_attempts_ticket_id_fkey FOREIGN KEY (ticket_id) REFERENCES public.tickets(id);


--
-- Name: rate_limit_violations rate_limit_violations_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_limit_violations
    ADD CONSTRAINT rate_limit_violations_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: refund_requests refund_requests_transaction_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.refund_requests
    ADD CONSTRAINT refund_requests_transaction_id_fkey FOREIGN KEY (transaction_id) REFERENCES public.transactions(id);


--
-- Name: refunds refunds_approved_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.refunds
    ADD CONSTRAINT refunds_approved_by_fkey FOREIGN KEY (approved_by) REFERENCES public.users(id);


--
-- Name: refunds refunds_transaction_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.refunds
    ADD CONSTRAINT refunds_transaction_id_fkey FOREIGN KEY (transaction_id) REFERENCES public.transactions(id);


--
-- Name: refunds refunds_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.refunds
    ADD CONSTRAINT refunds_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: reportable_transactions reportable_transactions_transaction_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reportable_transactions
    ADD CONSTRAINT reportable_transactions_transaction_id_fkey FOREIGN KEY (transaction_id) REFERENCES public.transactions(id);


--
-- Name: reservations reservations_event_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reservations
    ADD CONSTRAINT reservations_event_id_fkey FOREIGN KEY (event_id) REFERENCES public.events(id);


--
-- Name: reservations reservations_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reservations
    ADD CONSTRAINT reservations_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.orders(id) ON DELETE CASCADE;


--
-- Name: reservations reservations_ticket_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reservations
    ADD CONSTRAINT reservations_ticket_type_id_fkey FOREIGN KEY (ticket_type_id) REFERENCES public.ticket_types(id);


--
-- Name: reservations reservations_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reservations
    ADD CONSTRAINT reservations_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: role_permissions role_permissions_permission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.role_permissions
    ADD CONSTRAINT role_permissions_permission_id_fkey FOREIGN KEY (permission_id) REFERENCES public.permissions(id) ON DELETE CASCADE;


--
-- Name: royalties royalties_marketplace_transaction_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.royalties
    ADD CONSTRAINT royalties_marketplace_transaction_id_fkey FOREIGN KEY (marketplace_transaction_id) REFERENCES public.marketplace_transactions(id);


--
-- Name: royalties royalties_payment_transaction_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.royalties
    ADD CONSTRAINT royalties_payment_transaction_id_fkey FOREIGN KEY (payment_transaction_id) REFERENCES public.transactions(id);


--
-- Name: royalties royalties_recipient_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.royalties
    ADD CONSTRAINT royalties_recipient_id_fkey FOREIGN KEY (recipient_id) REFERENCES public.users(id);


--
-- Name: royalties royalties_venue_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.royalties
    ADD CONSTRAINT royalties_venue_id_fkey FOREIGN KEY (venue_id) REFERENCES public.venues(id);


--
-- Name: sanctions_screening sanctions_screening_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sanctions_screening
    ADD CONSTRAINT sanctions_screening_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: scanner_devices scanner_devices_venue_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.scanner_devices
    ADD CONSTRAINT scanner_devices_venue_id_fkey FOREIGN KEY (venue_id) REFERENCES public.venues(id);


--
-- Name: schedule_activities schedule_activities_depends_on_activity_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.schedule_activities
    ADD CONSTRAINT schedule_activities_depends_on_activity_id_fkey FOREIGN KEY (depends_on_activity_id) REFERENCES public.schedule_activities(id);


--
-- Name: schedule_activities schedule_activities_schedule_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.schedule_activities
    ADD CONSTRAINT schedule_activities_schedule_id_fkey FOREIGN KEY (schedule_id) REFERENCES public.event_schedules(id) ON DELETE CASCADE;


--
-- Name: schedule_conflicts schedule_conflicts_conflicting_schedule_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.schedule_conflicts
    ADD CONSTRAINT schedule_conflicts_conflicting_schedule_id_fkey FOREIGN KEY (conflicting_schedule_id) REFERENCES public.event_schedules(id) ON DELETE CASCADE;


--
-- Name: schedule_conflicts schedule_conflicts_primary_schedule_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.schedule_conflicts
    ADD CONSTRAINT schedule_conflicts_primary_schedule_id_fkey FOREIGN KEY (primary_schedule_id) REFERENCES public.event_schedules(id) ON DELETE CASCADE;


--
-- Name: schedule_exceptions schedule_exceptions_schedule_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.schedule_exceptions
    ADD CONSTRAINT schedule_exceptions_schedule_id_fkey FOREIGN KEY (schedule_id) REFERENCES public.event_schedules(id) ON DELETE CASCADE;


--
-- Name: search_index_events search_index_events_event_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.search_index_events
    ADD CONSTRAINT search_index_events_event_id_fkey FOREIGN KEY (event_id) REFERENCES public.events(id);


--
-- Name: security_audit_logs security_audit_logs_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.security_audit_logs
    ADD CONSTRAINT security_audit_logs_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: session_activities session_activities_session_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.session_activities
    ADD CONSTRAINT session_activities_session_id_fkey FOREIGN KEY (session_id) REFERENCES public.sessions(id) ON DELETE CASCADE;


--
-- Name: sessions sessions_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sessions
    ADD CONSTRAINT sessions_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: settlement_items settlement_items_batch_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.settlement_items
    ADD CONSTRAINT settlement_items_batch_id_fkey FOREIGN KEY (batch_id) REFERENCES public.settlement_batches(id);


--
-- Name: settlement_reports settlement_reports_venue_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.settlement_reports
    ADD CONSTRAINT settlement_reports_venue_id_fkey FOREIGN KEY (venue_id) REFERENCES public.venues(id);


--
-- Name: settlements settlements_bank_account_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.settlements
    ADD CONSTRAINT settlements_bank_account_id_fkey FOREIGN KEY (bank_account_id) REFERENCES public.payment_methods(id);


--
-- Name: staff_certifications staff_certifications_venue_staff_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.staff_certifications
    ADD CONSTRAINT staff_certifications_venue_staff_id_fkey FOREIGN KEY (venue_staff_id) REFERENCES public.venue_staff(id) ON DELETE CASCADE;


--
-- Name: staff_schedules staff_schedules_venue_staff_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.staff_schedules
    ADD CONSTRAINT staff_schedules_venue_staff_id_fkey FOREIGN KEY (venue_staff_id) REFERENCES public.venue_staff(id) ON DELETE CASCADE;


--
-- Name: staff_training_records staff_training_records_venue_staff_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.staff_training_records
    ADD CONSTRAINT staff_training_records_venue_staff_id_fkey FOREIGN KEY (venue_staff_id) REFERENCES public.venue_staff(id) ON DELETE CASCADE;


--
-- Name: subscriptions subscriptions_payment_method_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.subscriptions
    ADD CONSTRAINT subscriptions_payment_method_id_fkey FOREIGN KEY (payment_method_id) REFERENCES public.payment_methods(id);


--
-- Name: subscriptions subscriptions_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.subscriptions
    ADD CONSTRAINT subscriptions_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: suspicious_sessions suspicious_sessions_session_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.suspicious_sessions
    ADD CONSTRAINT suspicious_sessions_session_id_fkey FOREIGN KEY (session_id) REFERENCES public.sessions(id) ON DELETE CASCADE;


--
-- Name: tax_form_recipients tax_form_recipients_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tax_form_recipients
    ADD CONSTRAINT tax_form_recipients_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: tax_forms_1099 tax_forms_1099_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tax_forms_1099
    ADD CONSTRAINT tax_forms_1099_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: ticket_metadata ticket_metadata_ticket_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_metadata
    ADD CONSTRAINT ticket_metadata_ticket_id_fkey FOREIGN KEY (ticket_id) REFERENCES public.tickets(id) ON DELETE CASCADE;


--
-- Name: ticket_redemptions ticket_redemptions_event_schedule_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_redemptions
    ADD CONSTRAINT ticket_redemptions_event_schedule_id_fkey FOREIGN KEY (event_schedule_id) REFERENCES public.event_schedules(id);


--
-- Name: ticket_redemptions ticket_redemptions_redeemed_by_staff_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_redemptions
    ADD CONSTRAINT ticket_redemptions_redeemed_by_staff_id_fkey FOREIGN KEY (redeemed_by_staff_id) REFERENCES public.users(id);


--
-- Name: ticket_redemptions ticket_redemptions_redeemed_by_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_redemptions
    ADD CONSTRAINT ticket_redemptions_redeemed_by_user_id_fkey FOREIGN KEY (redeemed_by_user_id) REFERENCES public.users(id);


--
-- Name: ticket_redemptions ticket_redemptions_ticket_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_redemptions
    ADD CONSTRAINT ticket_redemptions_ticket_id_fkey FOREIGN KEY (ticket_id) REFERENCES public.tickets(id) ON DELETE CASCADE;


--
-- Name: ticket_refunds ticket_refunds_approved_by_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_refunds
    ADD CONSTRAINT ticket_refunds_approved_by_user_id_fkey FOREIGN KEY (approved_by_user_id) REFERENCES public.users(id);


--
-- Name: ticket_refunds ticket_refunds_requested_by_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_refunds
    ADD CONSTRAINT ticket_refunds_requested_by_user_id_fkey FOREIGN KEY (requested_by_user_id) REFERENCES public.users(id);


--
-- Name: ticket_refunds ticket_refunds_ticket_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_refunds
    ADD CONSTRAINT ticket_refunds_ticket_id_fkey FOREIGN KEY (ticket_id) REFERENCES public.tickets(id) ON DELETE CASCADE;


--
-- Name: ticket_refunds ticket_refunds_transaction_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_refunds
    ADD CONSTRAINT ticket_refunds_transaction_id_fkey FOREIGN KEY (transaction_id) REFERENCES public.ticket_transactions(id);


--
-- Name: ticket_reservations ticket_reservations_ticket_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_reservations
    ADD CONSTRAINT ticket_reservations_ticket_type_id_fkey FOREIGN KEY (ticket_type_id) REFERENCES public.ticket_types(id);


--
-- Name: ticket_reservations ticket_reservations_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_reservations
    ADD CONSTRAINT ticket_reservations_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: ticket_scans ticket_scans_ticket_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_scans
    ADD CONSTRAINT ticket_scans_ticket_id_fkey FOREIGN KEY (ticket_id) REFERENCES public.tickets(id);


--
-- Name: ticket_transactions ticket_transactions_from_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_transactions
    ADD CONSTRAINT ticket_transactions_from_user_id_fkey FOREIGN KEY (from_user_id) REFERENCES public.users(id);


--
-- Name: ticket_transactions ticket_transactions_ticket_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_transactions
    ADD CONSTRAINT ticket_transactions_ticket_id_fkey FOREIGN KEY (ticket_id) REFERENCES public.tickets(id) ON DELETE CASCADE;


--
-- Name: ticket_transactions ticket_transactions_to_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_transactions
    ADD CONSTRAINT ticket_transactions_to_user_id_fkey FOREIGN KEY (to_user_id) REFERENCES public.users(id);


--
-- Name: ticket_transfers ticket_transfers_from_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_transfers
    ADD CONSTRAINT ticket_transfers_from_user_id_fkey FOREIGN KEY (from_user_id) REFERENCES public.users(id);


--
-- Name: ticket_transfers ticket_transfers_ticket_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_transfers
    ADD CONSTRAINT ticket_transfers_ticket_id_fkey FOREIGN KEY (ticket_id) REFERENCES public.tickets(id) ON DELETE CASCADE;


--
-- Name: ticket_transfers ticket_transfers_to_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_transfers
    ADD CONSTRAINT ticket_transfers_to_user_id_fkey FOREIGN KEY (to_user_id) REFERENCES public.users(id);


--
-- Name: ticket_transfers ticket_transfers_transaction_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_transfers
    ADD CONSTRAINT ticket_transfers_transaction_id_fkey FOREIGN KEY (transaction_id) REFERENCES public.ticket_transactions(id);


--
-- Name: ticket_types ticket_types_event_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_types
    ADD CONSTRAINT ticket_types_event_id_fkey FOREIGN KEY (event_id) REFERENCES public.events(id);


--
-- Name: tickets tickets_event_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tickets
    ADD CONSTRAINT tickets_event_id_fkey FOREIGN KEY (event_id) REFERENCES public.events(id);


--
-- Name: tickets tickets_ticket_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tickets
    ADD CONSTRAINT tickets_ticket_type_id_fkey FOREIGN KEY (ticket_type_id) REFERENCES public.ticket_types(id);


--
-- Name: transactions transactions_payment_method_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transactions
    ADD CONSTRAINT transactions_payment_method_id_fkey FOREIGN KEY (payment_method_id) REFERENCES public.payment_methods(id);


--
-- Name: transactions transactions_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transactions
    ADD CONSTRAINT transactions_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: upload_sessions upload_sessions_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.upload_sessions
    ADD CONSTRAINT upload_sessions_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: user_consents user_consents_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_consents
    ADD CONSTRAINT user_consents_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: user_permissions user_permissions_permission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_permissions
    ADD CONSTRAINT user_permissions_permission_id_fkey FOREIGN KEY (permission_id) REFERENCES public.permissions(id) ON DELETE CASCADE;


--
-- Name: user_privacy_settings user_privacy_settings_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_privacy_settings
    ADD CONSTRAINT user_privacy_settings_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: user_roles user_roles_role_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_roles
    ADD CONSTRAINT user_roles_role_id_fkey FOREIGN KEY (role_id) REFERENCES public.roles(id) ON DELETE CASCADE;


--
-- Name: user_sessions user_sessions_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_sessions
    ADD CONSTRAINT user_sessions_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: users users_referred_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_referred_by_fkey FOREIGN KEY (referred_by) REFERENCES public.users(id);


--
-- Name: venue_analytics venue_analytics_venue_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_analytics
    ADD CONSTRAINT venue_analytics_venue_id_fkey FOREIGN KEY (venue_id) REFERENCES public.venues(id);


--
-- Name: venue_balances venue_balances_venue_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_balances
    ADD CONSTRAINT venue_balances_venue_id_fkey FOREIGN KEY (venue_id) REFERENCES public.venues(id);


--
-- Name: venue_compliance venue_compliance_venue_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_compliance
    ADD CONSTRAINT venue_compliance_venue_id_fkey FOREIGN KEY (venue_id) REFERENCES public.venues(id);


--
-- Name: venue_documents venue_documents_venue_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_documents
    ADD CONSTRAINT venue_documents_venue_id_fkey FOREIGN KEY (venue_id) REFERENCES public.venues(id);


--
-- Name: venue_integrations venue_integrations_venue_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_integrations
    ADD CONSTRAINT venue_integrations_venue_id_fkey FOREIGN KEY (venue_id) REFERENCES public.venues(id) ON DELETE CASCADE;


--
-- Name: venue_layouts venue_layouts_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_layouts
    ADD CONSTRAINT venue_layouts_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: venue_layouts venue_layouts_venue_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_layouts
    ADD CONSTRAINT venue_layouts_venue_id_fkey FOREIGN KEY (venue_id) REFERENCES public.venues(id) ON DELETE CASCADE;


--
-- Name: venue_operating_hours venue_operating_hours_venue_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_operating_hours
    ADD CONSTRAINT venue_operating_hours_venue_id_fkey FOREIGN KEY (venue_id) REFERENCES public.venues(id) ON DELETE CASCADE;


--
-- Name: venue_policies venue_policies_previous_version_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_policies
    ADD CONSTRAINT venue_policies_previous_version_id_fkey FOREIGN KEY (previous_version_id) REFERENCES public.venue_policies(id);


--
-- Name: venue_settings venue_settings_venue_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_settings
    ADD CONSTRAINT venue_settings_venue_id_fkey FOREIGN KEY (venue_id) REFERENCES public.venues(id) ON DELETE CASCADE;


--
-- Name: venue_staff venue_staff_added_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_staff
    ADD CONSTRAINT venue_staff_added_by_fkey FOREIGN KEY (added_by) REFERENCES public.users(id);


--
-- Name: venue_staff venue_staff_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_staff
    ADD CONSTRAINT venue_staff_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: venue_staff venue_staff_venue_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.venue_staff
    ADD CONSTRAINT venue_staff_venue_id_fkey FOREIGN KEY (venue_id) REFERENCES public.venues(id) ON DELETE CASCADE;


--
-- Name: webhook_deliveries webhook_deliveries_webhook_event_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.webhook_deliveries
    ADD CONSTRAINT webhook_deliveries_webhook_event_id_fkey FOREIGN KEY (webhook_event_id) REFERENCES public.webhook_events(id);


--
-- Name: event_categories categories_select_all; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY categories_select_all ON public.event_categories FOR SELECT USING ((is_active = true));


--
-- Name: dispute_resolution; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.dispute_resolution ENABLE ROW LEVEL SECURITY;

--
-- Name: escrow; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.escrow ENABLE ROW LEVEL SECURITY;

--
-- Name: event_capacity; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.event_capacity ENABLE ROW LEVEL SECURITY;

--
-- Name: event_categories; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.event_categories ENABLE ROW LEVEL SECURITY;

--
-- Name: event_metadata; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.event_metadata ENABLE ROW LEVEL SECURITY;

--
-- Name: event_pricing; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.event_pricing ENABLE ROW LEVEL SECURITY;

--
-- Name: event_schedules; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.event_schedules ENABLE ROW LEVEL SECURITY;

--
-- Name: events; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.events ENABLE ROW LEVEL SECURITY;

--
-- Name: financial_reports; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.financial_reports ENABLE ROW LEVEL SECURITY;

--
-- Name: fraud_prevention_rules; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.fraud_prevention_rules ENABLE ROW LEVEL SECURITY;

--
-- Name: invoices; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.invoices ENABLE ROW LEVEL SECURITY;

--
-- Name: listings; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.listings ENABLE ROW LEVEL SECURITY;

--
-- Name: market_analytics; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.market_analytics ENABLE ROW LEVEL SECURITY;

--
-- Name: marketplace_transactions; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.marketplace_transactions ENABLE ROW LEVEL SECURITY;

--
-- Name: offers; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.offers ENABLE ROW LEVEL SECURITY;

--
-- Name: payment_methods; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.payment_methods ENABLE ROW LEVEL SECURITY;

--
-- Name: price_history; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.price_history ENABLE ROW LEVEL SECURITY;

--
-- Name: refunds; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.refunds ENABLE ROW LEVEL SECURITY;

--
-- Name: royalties; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.royalties ENABLE ROW LEVEL SECURITY;

--
-- Name: settlements; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.settlements ENABLE ROW LEVEL SECURITY;

--
-- Name: subscriptions; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;

--
-- Name: ticket_metadata; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.ticket_metadata ENABLE ROW LEVEL SECURITY;

--
-- Name: ticket_redemptions; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.ticket_redemptions ENABLE ROW LEVEL SECURITY;

--
-- Name: ticket_refunds; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.ticket_refunds ENABLE ROW LEVEL SECURITY;

--
-- Name: ticket_transactions; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.ticket_transactions ENABLE ROW LEVEL SECURITY;

--
-- Name: ticket_transfers; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.ticket_transfers ENABLE ROW LEVEL SECURITY;

--
-- Name: ticket_types; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.ticket_types ENABLE ROW LEVEL SECURITY;

--
-- Name: tickets; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.tickets ENABLE ROW LEVEL SECURITY;

--
-- Name: transactions; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;

--
-- Name: users; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

--
-- Name: venue_integrations; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.venue_integrations ENABLE ROW LEVEL SECURITY;

--
-- Name: venue_layouts; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.venue_layouts ENABLE ROW LEVEL SECURITY;

--
-- Name: venue_settings; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.venue_settings ENABLE ROW LEVEL SECURITY;

--
-- Name: venue_staff; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.venue_staff ENABLE ROW LEVEL SECURITY;

--
-- Name: venues; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.venues ENABLE ROW LEVEL SECURITY;

--
-- PostgreSQL database dump complete
--

\unrestrict wYfCNY6egfx9sfCmL06xmJQZ4FZKTbFhampad9wk23ohBP6KneZDBdCScVI0KHd

